pro xg_assn, root, region, scans, proj, fitsvars, xingname,  cutoff=cutoff, big=big, tdf=tdf, time=time, noxfix=noxfix, lapack=lapack, lambda= lambda, fvi=fvi, fvv=fvv, zfv=zfv

;+
; Name:
;   XG_ASSN
; PURPOSE:
;   Once the X matrix ang y matrix have been generated by LSFXPT, XG_ASSN
;   assigns the gain parameters to each day, each beam and each xing point.
;   It saves this information in a *xing* file, completeley analogous to the 
;   *hdrs* file.
;
; CALLING SEQUENCE:
;   xg_assn, root, region, scans, proj, fitsvars
;
; INPUTS:
;   root -- The main directory in which the project directory
;             resides (e.g. '/dzd4/heiles/gsrdata/' )
;   region -- The name of the source as entered into BW_fm (e.g. 'lwa')
;   scans -- Number of days the project consists of
;   proj -- The Arecibo project code (e.g. 'a2050')
;   
; KEYWORDS PARAMETERS
;   cutoff -- if keyword set, force all inverse weights above this number to 0.
;   tdf -- use the older two-digit formatting
;   big -- if this is set, look for xtx and ytx arrays, instead of yarrall and xarrall.
;   time -- use UTC time as xaxis variable in fourier and poly components. must be
;           set the same in lsfxpt.    
;   lapack -- if set use la_svd, not svdc
;   lambda -- if set, do ridge regression a la equation (6) in Winkel
;             et at 2012, with amplitude lambda. See Section 8.3 (p
;             333) of Ivezic et al 2014 (astroML)
;   fvi -- if set, the indices of fit variables to force to the values 
;          in fvv.
;   fvv -- the values of the variables in fvi to force to.
;   zfv -- if set, zero out the output of the first value in the fit, and set it to zfv. 
; OUTPUTS:
;   fitsvars -- the output of the SVD fit we use. Good for diagnositcs on the 
;              goodness of fit, etc.
;
; MODIFICATION HISTORY:
;   Initial Documentation Monday, July 25, 2005
;   Modified to include modern fourier frequencies, October 15, 2005
;   Modified to include SVD 1/wgt cutoff, October 20, 2005
;   Modified to add la_svd functionality, October 2008, JEGP
;   Modified to add fvv, and fvi, as well as lambda (ridge regression)
;   Joshua E. Goldston, goldston@astro.berkeley.edu
;-

;if keyword_set(solname) eq 0. then begin
if keyword_set(tdf) then scnfmt = '(I2.2)' else scnfmt = '(I3.3)' 

restore, root + proj + '/' + region + '/xing/'+ region + '_lsfxpt_'+ xingname +'.sav'

; Ridge regularization? A la equation (6) of Winkel+ 2012

if keyword_set(fvi) then begin
	if not keyword_set(big) then begin
		print, 'fvi only works with /big'
		return
	endif
	szxtxold = size(xtx)
	oldxtx = xtx
	newxtx = fltarr(szxtxold[1]-n_elements(fvi), szxtxold[1]-n_elements(fvi))
	newytx = fltarr(szxtxold[1]-n_elements(fvi))
	mask = fltarr(szxtxold[1]) +1
	mask[fvi] = 0
	whm = where(mask eq 1)
	for i=0, szxtxold[1]-n_elements(fvi)-1 do newxtx[i, *] = oldxtx[whm[i], whm]
	newytx = ytx[whm]
	ytx = newytx
	xtx = newxtx
endif

if keyword_set(lambda) then begin
	szxtx = size(xtx)
	regmat = fltarr(szxtx[1], szxtx[2])
	regmat(findgen(szxtx[1])*(szxtx[1]+1)) = lambda
	xtx = xtx + regmat
endif

if keyword_set(big) then begin
    if keyword_set(la) then la_svd, xtx, w, u, v else svdc, xtx, w, u, v
    dm = diag_matrix(1./w)
    if keyword_set(cutoff) then begin
        wh = where(dm gt cutoff, ct)
        if ct ne 0 then dm[wh] = 0.
    endif
    invxtx = v##dm##transpose(u)
    f= ytx#invxtx
    if keyword_set(zfv) then f[0] = zfv
    if keyword_set(fvi) then begin
   		fold = f
   		f = fltarr(szxtxold[1])
		f[whm] = fold
   		f[fvi] = fvv
   	endif
    fitsvars = {w:w, u:u, v:v, f:f, xtx:xtx, invxtx:invxtx, ytx:ytx}
endif else begin
    lsfit_svd, xarrall, transpose(yarrall), u, v, wgt, f, vara, siga, ncov, s_sq, xxinv_svd=xxinv_svd 
	if keyword_set(zfv) then f[0] = zfv
    if keyword_set(fvi) then begin
   		fold = f
   		f = fltarr(szxtxold[1])
		f[whm] = fold
   		f[fvi] = fvv
   	endif
   	
    fitsvars = { u:u, v:v,   wgt:wgt, f:f, vara:vara, siga:siga, ncov:ncov, s_sq:s_sq, xxinv_svd:xxinv_svd}
    
    
endelse

;  if keyword_set(fvi) then f[fvi] = fvv


wgt=0.
vara=0.
siga=0.
ncov=0.
s_sq=0.
xxinv_svd=0.

if (keyword_set(cutoff) and (not keyword_set(big))) then begin
    f=0.
    wgtinv = 1./fitsvars.wgt
    if (max(wgtinv) gt cutoff) then wgtinv(where(wgtinv gt cutoff)) = 0.
    lsfit_svd, xarrall, transpose(yarrall), u, v, wgt, f, vara, siga, ncov, s_sq, xxinv_svd=xxinv_svd, wgt_inv=wgtinv
    if keyword_set(fvi) then f[fvi] = fvv
    fitsvars = { u:u, v:v,   wgt:wgt, f:f, vara:vara, siga:siga, ncov:ncov, s_sq:s_sq, xxinv_svd:xxinv_svd}
endif

if keyword_set(noxfix) then begin
    nox_fix, root, region, scans, proj, f, beamgain, daygain, degree, nf, fourier
    if keyword_set(fvi) then f[fvi] = fvv
    fitsvars = { u:u, v:v,   wgt:wgt, f:f, vara:vara, siga:siga, ncov:ncov, s_sq:s_sq, xxinv_svd:xxinv_svd}
endif

; beam gains
if (beamgain eq 1) then bg = f[0:6] else bg = fltarr(7)
; day gains
if (daygain eq 1) then dg = f[7*beamgain:7*beamgain+scans-1] else dg = fltarr(scans)
; polynomial gain matrix
if (degree ge 0) then pgm = reform(f[7*beamgain+scans*daygain:7*beamgain+scans*daygain+7*scans*(degree+1)-1.], degree+1., scans, 7)
; fouier gain matrix
if (nf gt 0.) then fgm = reform(f[7*beamgain+scans*daygain+7*scans*(degree+1):*], nf, scans, 7, 2)
if (nf gt 0.) then fmodes = fourier[0] + findgen(nf)

for i=0, scans -1 do begin
    restore, root + '/' +  proj + '/' + region + '/' + region + '_'  + string(i, format=scnfmt) + '/' + '*hdrs*'
    nsecs = n_elements(mh)
    if keyword_set(time) then ra_or_time = rebin(reform(mh.utcstamp,1, nsecs), 7, nsecs)  else ra_or_time = mh.ra_halfsec
    ; cosine terms
    if (nf gt 0) then carr = cos(rebin(reform(fmodes, 1, 1, nf), 7, nsecs, nf)*!pi*rebin(reform(locdom(mdsts[i], ra_or_time, /time), 7, nsecs, 1), 7 , nsecs, nf))
   ; sine terms 
    if (nf gt 0) then sarr = sin(rebin(reform(fmodes, 1, 1, nf), 7, nsecs, nf)*!pi*rebin(reform(locdom(mdsts[i], ra_or_time, /time), 7, nsecs, 1), 7 , nsecs, nf))
;correct size if only one fourier mode.
    if (nf gt 0) and ((size(carr))[0] eq 2) then carr = reform(carr, 7, nsecs, 1)
    if (nf gt 0) and ((size(sarr))[0] eq 2) then sarr = reform(sarr, 7, nsecs, 1)

; polynomial terms
    if (degree ge 0) then xarr = rebin(reform(locdom(mdsts[i], ra_or_time, /time), 7, nsecs, 1), 7, nsecs, degree+1)^rebin(reform(findgen(degree+1), 1, 1, degree+1), 7, nsecs, degree+1)
   
   if (degree ge 0) then begin 
       if (nf eq 0) then gain = 10^(rebin(reform(bg, 7, 1),7, nsecs) + dg[i] + total(xarr*rebin(reform(transpose(reform(pgm[*, i, *])), 7, 1, degree+1), 7, nsecs, degree+1), 3)) 
       if (nf gt 0) then gain = 10^(rebin(reform(bg, 7, 1),7, nsecs) + dg[i] + total(xarr*rebin(reform(transpose(reform(pgm[*, i, *])), 7, 1, degree+1), 7, nsecs, degree+1), 3) + total(carr*rebin(reform(transpose(reform(fgm[*, i, *, 0])), 7, 1, nf), 7, nsecs, nf), 3) + total(sarr*rebin(reform(transpose(reform(fgm[*, i, *, 1])), 7, 1, nf), 7, nsecs, nf), 3))
   endif   
   
   if (degree lt 0) then begin
       if (nf eq 0) then gain = 10^( rebin(reform(bg, 7, 1),7, nsecs) + dg[i])
       if (nf gt 0) then gain = 10^(rebin(reform(bg, 7, 1),7, nsecs) + dg[i] + total(carr*rebin(reform(transpose(reform(fgm[*, i, *, 0])), 7, 1, nf), 7, nsecs, nf), 3) + total(sarr*rebin(reform(transpose(reform(fgm[*, i, *, 1])), 7, 1, nf), 7, nsecs, nf), 3))
   endif
   if appl_xing ne 'none' then begin
     ; don't overwite the current values!
       mdsts_cur = mdsts
       degree_cur = degree
       daygain_cur = daygain
       beamgain_cur = beamgain
       gain_cur = gain
       fn_cur = fn
       nf_cur = nf
       fourier_cur = fourier
       restore, root + '/' +  proj + '/' + region + '/' + region + '_'  + string(i, format=scnfmt) + '/' + region + '_'  + string(i, format=scnfmt) +'_xing_' + appl_xing +'.sav'
    ; multiply the gains
       gain = gain_cur*gain
    ; reinstate current values
       mdsts = mdsts_cur
       degree  =  degree_cur
       daygain  =  daygain_cur
       beamgain = beamgain_cur   
       fn  = fn_cur
       nf  = nf_cur
       fourier  =  fourier_cur
   endif
   save, mdsts, degree, daygain, beamgain, gain, fn, nf, fourier, appl_xing, filename = root + '/' +  proj + '/' + region + '/' + region + '_'  + string(i, format=scnfmt) + '/' + region + '_'  + string(i, format=scnfmt) +'_xing_' + xingname +'.sav'
endfor
   save, mdsts, degree, daygain, beamgain, fn, nf, fourier, fitsvars, appl_xing, filename = root + '/' +  proj + '/' + region + '/' + 'xga_' + xingname +'.sav'

   xingarr, root, region, scans, proj, xingname=xingname

end




