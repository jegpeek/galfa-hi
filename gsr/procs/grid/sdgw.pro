pro sdgw, root, region, proj, gridname, lon0, lat0, spmax, spmin, spres, imsize,rs=rs, projection=projection, _REF_EXTRA=_extra, tdf=tdf, spname=spname,  badrxfile=badrxfile, spblfile=spblfile, xingname=xingname, fwhm=fwhm, vel=vel, allfiles=allfiles, savepath=savepath, gridfunc=gridfunc, odf=odf, norm=norm, blankfile=blankfile, arcminperpixel=arcminperpixel, pts=pts, truecart=truecart, cpp=cpp, nofits=nofits, spp=spp, strad=strad, lb=lb, nan=nan, nomedfix=nomedfix

;+
; NAME:
;  SDGW
;
; PURPOSE:
;  Grid GALFA data.
;
;
; CALLING SEQUENCE:
;        sdgw, root, region, proj, gridname, lon0, lat0, spmax, $
;	spmin, spres, imsize, rs=rs, projection=projection, _REF_EXTRA=_extra, $
;	tdf=tdf, spname=spname,  badrxfile=badrxfile, xingname=xingname, fwhm=fwhm, vel=vel, $
;	allfiles=allfiles, savepath=savepath, gridfunc=gridfunc, odf=odf, $
;	norm=norm, blankfile=blankfile, arcminperpixel=arcminperpixel, $
;	pts=pts, truecart=truecart
; INPUTS:
;   ROOT -- The main directory in which the project directory
;                 resides (e.g. '/dzd4/heiles/gsrdata/' ) 
;   REGION -- The name of the source as entered into BW_fm (e.g. 'lwa') 
;   PROJ -- The Arecibo= project code (e.g. 'a2050') 
;   GRIDNAME- The grid name to use for generated files, e.g. 'hi_res_test'
;   LON0 - The center longitude of the grid. See SDGRID for details.
;   LAT0 - The center latitude of the grid. See SDGRID for details. 
;   SPMAX - The maximum of the spectrum to use. Specify in channel 
;           number, 0 to 8191, or in km/s if /vel is specified
;   SPMIN - The minimum of the spectrum to use. Specify in channel 
;           number, 0 to 8191, or in km/s if /vel is specified.
;   SPRES - The spectral resolution desired in the output data cube. 
;           Specify in channel number, 0 to 8191, or in 
;           km/s if /vel is specified.
;   IMSIZE - Size of the image in pixels, [x, y]
;
; OPTIONAL INPUTS:
;    NONE.
;
; KEYWORD PARAMETERS:
;   XINGNAME   - The name of the file to read any XING correction data from. This file is
;             generated by xg_assn.pro
;   RS - If set as a two element array of strings, swaps out the first
;               string for the second in the path to the data.
;   BADRXFILE - Any badrx file to use (full path!)
;   SPBLFILE - Any SPBL file to use (full path, but no .sav or .fits)
;   SPNAME - Set this to the name of your spcor file to use. If you want
;      to use spcor_NAME.sav, set it to 'NAME'. If you wish to use
;      spcor.sav, just set this to 'null'. This will have been set as a
;      xingname in a previous code, but as the user might want to use
;      an spcor file from a xing file different from the xing file whose
;      xing information they want to use, this is a separate keyword from XINGNAME
;   TDF - use the older two-digit formatting
;   ODF - use older .sav data formatting
;   FWHM - will be set to 3.35 (arcmin) if not specified.
;   VEL - if set, the spectral range is in km/s, not spectral channels
;   ALLFILES - specify the this keyword to skip checking which 
;              files to use for grid. Use only if you are sure to use all data files
;              in generating grid.
;   SAVEPATH - If you wish to save the cube to a directory other than root/proj/region
;              specify the full path here.
;   PROJECTION - Specify the projection you like - 'CAR' is the default. See SDGRID
;               for details.
;   ARCMINPERPIXEL - How many arcminutes across should each pixel be. Default is 1.
;   GRIDFUNC - The gridding kernal to use. 
;              Default is GAUSS. See SDGRID for options
;   _EXTRA - You may pass any keywords to SDGRID you wish through this keyword
;            see SDGRID for full list of keywords availible
;    NORM - If set, skip the normalization using the LDS, instead divide
;           the final cube by this value. One can (of course) set this 
;           parameter to 1 to skip the LDS and leave the cube untouched.
;    BLANKFILE - put the full path to a file here that has utc times and beams
;    PTS - set to a list of RAs and decs such that the first RA is in [0,0] 
;          and the first dec is in [0, 1] in hrs, degrees, to highlite these 
;          points. Useful for registry issues.
;    TRUECART - Set this if you want a true cartesian grid, with non-oblique
;               graticules. This is to say, make a plot wherein [0,0] and [0,1]
;               have the same ra and [0,0] and [1, 0] have the same dec.
;    CPP - force C++ implementation.
;    NOFITS -- do not write a fits file, just a .sav file.
;    SPP -- an output keyword - 'seconds per pixel'
;    STRAD --  set this to remove sidelobes made by corral.pro      
;    LB -- set this to make cubes in Galactic coordiantes [l, b]. Input postions
;         (lat0, lon0) are then expected in l, b as well.
;    NAN -- if you prefer to have NaNs in your fits files rather than zeroes
; MODIFICATION HISTORY:
;  Inital documentation August 9th, 2006
;  Upgraded to 2.3-style spcor, November 16th, 2006
;  Added eta parameter for beam cleaning, January 16th 2008
;  Added lb for I-GALFA, March 30th, 2009.
;  Added nan, April 8th, 2009.
;  Added median removal March 27, 2011
;  Modified to include both _W and _N cubes in STRAD correction, JEGP, May 1, 2011
;  JEG Peek

;goldston@astro.berkeley.edu
;-
;test comment by SEC
;set the fwhm and other unset keywords
bt = 0.
if not keyword_set(fwhm) then fwhm = 3.35
if not keyword_set(arcminperpixel) then arcminperpixel = 1.
if not keyword_set(projection) then projection = 'CAR'
if not keyword_set(gridfunc) then gridfunc = 'GAUSS'
if not(keyword_set(savepath)) then savepath = root +  proj + '/' + region + '/'
; deal with weird cartesian problems
if keyword_set(truecart) then begin
    crvals = [180, 0] 
    latpole=90.
endif else begin
    crvals = [lon0, lat0] 
    latpole=90.
endelse
;print, 'ampp1', arcminperpixel
imsizex = imsize[0]
imsizey = imsize[1]

;deal with old setup
if keyword_set(tdf) then scnfmt = '(I2.2)' else scnfmt = '(I3.3)' 

; get all time-ordered data
path = root + proj + '/' + region + '/'
restore, path + 'todarr.sav';, /ver
dbt = systime(/sec)
if keyword_set(blankfile) then moveblanks, blankfile, mht 
bt = bt + (systime(/sec)-dbt)

;restore xing corrections
if keyword_set(xingname) then begin
    restore, path + 'xingarr_' + xingname +'.sav'
endif else xingname = ''
; figure out the binning

    del_vel=-2.99792458e+5*((100./14.)/8192.)/1420.405751786
    all_vel = del_vel*(findgen(8192)-4095.5)
if keyword_set(vel) then begin 
    c1 = min(abs(all_vel-spmax), x1)
    c2 = min(abs(all_vel-spmin), x2)
    respix = ceil(spres/del_vel)
    botchan = min([x1, x2])
    topchan = botchan+ceil(float(max([x1, x2])-botchan+1)/respix)*respix-1
endif else begin
    botchan = min([spmin, spmax])
    respix = spres
    topchan = botchan+ceil(float(max([spmin, spmax])-botchan+1)/respix)*respix-1
endelse
nchan = abs((topchan-botchan+1)/respix)
our_vel = rebin(all_vel[botchan:topchan], nchan)

if (gridfunc eq 'SINC') then  parm2=1.14*fwhm/3.
if (gridfunc eq 'GAUSS') then  parm2=fwhm/3.
If (gridfunc eq 'BESSEL') then  parm2=1.55*fwhm/3. 

dmin=2.355*parm2/(2.*sqrt(2.))

; Unless told otherwise, the code runs in an empty data string to look for 
; which files are needed for this grid. This saves time if the grid does
; not cover all of the data.
if not keyword_set(allfiles) then begin
; a dummy data string
data = fltarr(n_elements(mht)*7,1)+1.
;print, 'ampp2', arcminperpixel
;st1 = systime(/sec)
if keyword_set(lb) then begin
    glactc, reform(mht.ra_halfsec, n_elements(mht)*7l),  reform(mht.dec_halfsec, n_elements(mht)*7l), 2000, ll, bb, 1
    sdgrid, data, unwrap(ll, lon0), bb,  fwhm, cube, cpp=0., CRVAL=crvals, sparseout=spout, _EXTRA=_extra, crange=[0,0], projection=projection, arcminperpixel=arcminperpixel, imsize=imsize, gridfunc=gridfunc, imcen=[lon0, lat0], latpole=latpole, /quiet
endif else begin
    sdgrid, data, unwrap(reform(mht.ra_halfsec, n_elements(mht)*7l)*15., lon0), reform(mht.dec_halfsec, n_elements(mht)*7l),  fwhm, cube, cpp=0., CRVAL=crvals, sparseout=spout, _EXTRA=_extra, crange=[0,0], projection=projection, arcminperpixel=arcminperpixel, imsize=imsize, gridfunc=gridfunc, imcen=[lon0, lat0], latpole=latpole, /quiet
endelse
;st2 = systime(/sec)
;print, 'ampp3', arcminperpixel
;print, st2-st1
; which files are used?
print, n_elements(spout)
if n_elements(spout) eq 0 then begin
    cubesav=fltarr(imsizex, imsizey, nchan)
    if not keyword_set(norm) then norm=1.0
    save, cubesav, our_vel, norm, filename=savepath + gridname + xingname + '.sav'
    if not keyword_set(nofits) then  hdr = write_fits_cube(savepath + gridname + xingname +'.fits', reverse(cubesav, 3), strlowcase(projection) , arcminperpixel, imsizex, imsizey, lon0, lat0, [0,nchan], 'unknown', reverse(our_vel), 1420.40576 , sqrt((2.*dmin)^2+fwhm^2), lb=lb, nan=nan)
    spp=fltarr(imsizex, imsizey)
     return
endif

allsecs = floor(spout.col/7l)
usecs = allsecs(uniq(allsecs, sort(allsecs)))
allfiles = (mht.fn)[usecs]
endif else begin
    allfiles = mht.fn
    usecs = lindgen(n_elements(mht))
endelse
wuf = uniq(allfiles, sort(allfiles))
ufiles = allfiles[wuf]

; which days go with what?
assocday = mht[usecs].day
days = assocday[wuf]

if (keyword_set(spname)) then begin
    if spname eq 'null' then restore, root + proj + '/' + region + '/spcor.sav'
    if spname ne 'null' then restore, root + proj + '/' + region + '/spcor_' + spname + '.sav'
    if n_elements(zogains) ne 1 then fpn = fpn_sp
endif

; rootswapping
if (keyword_set(rs)) then begin
    ufiles = rootswap(ufiles, rs[0], rs[1]) 
    mht.fn = rootswap(mht.fn, rs[0], rs[1]) 
endif
;load and grid files.
for i=0, n_elements(ufiles)-1 do begin
    loop_bar,i, n_elements(ufiles)
    restore, ufiles[i]
    ;print,i,ufiles[i]
    if keyword_set(odf) then data = temporary(outdata) else data =  gsrfits(ufiles[i], /savname)

    outdata=0.
    sz=size(data)
    whichrx, mh[0].UTCSTAMP, goodrx, badrxfile=badrxfile
    fixrx, data, goodrx
	;apply spectral blanking

   	if keyword_set(spblfile) then begin
 		spblanker, data, mh, spblfile, spblank
    endif else spblank = 0
	;if total(goodrx) ne 14 then stop
    if keyword_set(spname) then spfix, data, days[i], zogains, fpn, mh.dec_halfsec[0], mh.vlsr[0]
    dbt = systime(/sec)
    if keyword_set(blankfile) then moveblanks, blankfile, mh
    bt = bt + (systime(/sec)-dbt)
    
    ; find the medians, using only data off the edges and off the line (may be some problems with m33?)
    if not keyword_set(nomedfix) then begin
    	usemedchan = [500 + findgen(4096-500-550), 4096+550 + findgen(4096-500-550)]
    	smker = 10 < (sz[4] - 1)
		data = data - rebin(reform(median((smooth(data, [1, 1, 1, smker], /edge_mirror))[usemedchan, *, *, *], dim=1), 1, 2, 7, sz[4]), 8192, 2, 7, sz[4])
    endif

    data = reform(rebin(data[botchan:topchan, *, *, *], nchan, 1, 7, sz[4]), nchan, 7, sz[4])
    if keyword_set(spblfile) then begin
    	if (size(spblank))[0] ne 0 then begin
    		spblank = rebin(spblank[botchan:topchan, *, *], nchan, 7, sz[4])
    		spblank = reform(transpose(spblank, [1, 2, 0]), 7*sz[4], nchan)
			endif
    endif
    if keyword_set(pts) then hilite_pts, mh, data, pts
    data = reform(transpose(data, [1, 2, 0]), 7*sz[4], nchan)

    if keyword_set(xingname) then begin
        whf = where(mht.fn eq ufiles[i])
        data = temporary(data)/rebin(reform(corf[*, whf], 7*sz[4]), 7*sz[4], nchan)
    endif
    if keyword_set(strad) then begin
    	if not keyword_set(norm) then begin
    		print, 'WARNING: the STRAD keyword cannot be used without an explicit NORM keyword set'
    		return
    	endif
    	if (norm ne 1) then begin
    		print, "currently not set up for NORM ne 1, sorry"
    		return
    	endif
; scale up the data by 1/eta and then subtract off the (already scaled) sidelobes 
		; still not clear why this reverse is needed...
		etaorg = [0.875729, 0.764944,0.743301,0.742042,0.764944,0.769971,0.770685]
		datadiv = data*0.
		restore, ufiles[i] + '.SL_W.sav'
		datadiff = reform(congrid(transpose(reverse(spbox, 1), [2, 1, 0]), 7, sz[4], nchan, /center), 7*sz[4], nchan)
		spbox =0
		restore, ufiles[i] + '.SL_N.sav'
		datadiff[*, 3072:5119] = reform(transpose(reverse(spbox, 1), [2, 1, 0]), 7*sz[4], 2048.)
        data = temporary(data)/(reform(rebin(reform((etaorg), 7, 1, 1), 7, sz[4], nchan), 7*sz[4], nchan)) - datadiff
        spbox=0.
    endif

    if keyword_set(lb) then begin
        glactc, reform(mh.ra_halfsec, n_elements(mh)*7l),  reform(mh.dec_halfsec, n_elements(mh)*7l), 2000, ll, bb, 1
        sdgrid_spbl, spblank, data, unwrap(ll, lon0), bb, fwhm, cube, crval=crvals, _EXTRA=_extra, /nonormalize, weight=weight, projection=projection, arcminperpixel=arcminperpixel, imsize=imsize, gridfunc=gridfunc, imcen=[lon0, lat0], latpole=latpole, cpp=cpp, threedweight=tdw, /quiet
    endif else begin
        sdgrid_spbl, spblank, data, unwrap(reform(mh.ra_halfsec, n_elements(mh)*7l)*15., lon0), reform(mh.dec_halfsec, n_elements(mh)*7l), fwhm, cube, crval=crvals, _EXTRA=_extra, /nonormalize, weight=weight, projection=projection, arcminperpixel=arcminperpixel, imsize=imsize, gridfunc=gridfunc, imcen=[lon0, lat0], latpole=latpole, cpp=cpp, threedweight=tdw, /quiet
    endelse
	;if tdw eq 1 then stop

    data=0.
    if i eq 0. then begin
        cubesav = cube
        weightsav = weight
        cube=0.
    endif
    if i ne 0. then begin
        cubesav = temporary(cube)+temporary(cubesav)
        weightsav = temporary(weight) + temporary(weightsav)
        cube=0.
    endif
;stop
endfor
;stop

if not(keyword_set(savepath)) then savepath = root +  proj + '/' + region + '/'
;stop
spp = total(weightsav, 3)/(size(weightsav))[3]
szw = size(weightsav)
invw = 1./temporary(weightsav)
;stop
feqz = where(finite(invw) eq 0., ct)
;stop
if ct ne 0 then invw(feqz) = 0.
cubesav = temporary(cubesav)*temporary(invw)
if not keyword_set(xingname) then xingname = ''
;stop
our_vel = rebin(all_vel[botchan:topchan], nchan)
;stop


hdr = write_fits_cube(savepath + gridname + xingname +'.fits', cubesav, strlowcase(projection) , arcminperpixel, szw[1], szw[2], lon0, lat0, [0,nchan], 'unknown', our_vel, 1420.40576 , sqrt((2.*dmin)^2+fwhm^2), /hdronly, lb=lb, nan=nan)
;print, 'ampp7', arcminperpixel
xdim = rebin(reform(findgen(imsizex), imsizex, 1), imsizex, imsizey)
ydim = rebin(reform(findgen(imsizey), 1, imsizey), imsizex, imsizey)

extast, hdr, astr
xy2ad, xdim, ydim, astr, allra, alldec
if keyword_set(lb) then begin
    all_l = allra
    all_b = alldec
endif else begin
    glactc, allra/15., alldec, 2000, all_l, all_b, 1
endelse

whnzer = where(spp ne 0)
all_lnz = all_l[whnzer]
all_bnz = all_b[whnzer]

ldspec = ldsregion(all_lnz, all_bnz,  getenv('GSRPATH') +'savfiles/lds.sav')
obspec = total(total(cubesav,1, /nan), 1, /nan)/(n_elements(whnzer) > 1.)
lds_vel =  findgen(151)*1.0305-75*1.0305

if not keyword_set(norm) then norm = arb_spect_rat(our_vel,obspec, lds_vel, ldspec)

cubesav = temporary(reverse(cubesav, 3))/norm
our_vel = reverse(our_vel)
save, cubesav, our_vel, norm, filename=savepath + gridname + xingname + '.sav'
;print, 'ampp8', arcminperpixel
if keyword_set(nofits) then spawn, 'rm ' + savepath + gridname + xingname +'.fits' else hdr = write_fits_cube(savepath + gridname + xingname +'.fits', cubesav, strlowcase(projection) , arcminperpixel, szw[1], szw[2], lon0, lat0, [0,nchan], 'unknown', our_vel, 1420.40576 , sqrt((2.*dmin)^2+fwhm^2), truecart=truecart, lb=lb, nan=nan)
print, 'blanktime: ' + string(bt/3600.) + ' hrs'
end


