pro carl9, xmatrix, stamod, frq0a, indx0a, fnew, $
	modfctr, g_g, rf_g, rf4_g, $
	u=u, vv=vv, wgts=wgts, wgt_inv=wgt_inv, xxinv_svd= xxinv_svd, manual=manual, $
	verbose=verbose, niter_max=niter_max, problem=problem, $
	quiet=quiet

;+ 
;NAME:
;CARL9 -- given the SMARTF data, do the lsfs solution to separate the
;if gains from the rf powers. 
;
;PURPOSE AND NOTE: this LSFS solution provides the i.f. bandpass shapes.
;The method and details are given in ATOMS tech memo 2005-03 and
;galTech memo 2005-01:
;'Obtaining the IF Bandpass Using Least-Sqwuares Frequency Switching (LSFS)'
;you should especially read this if the term 'SVD' is unfamiliar to you.
;
;CALLING SEQUENCE:
;carl9, xmatrix, stamod, frq0a, indx0a, fnew, $
;	modfctr, g_g, rf_g, rf4_g, $
;	wgts=wgts, wgt_inv=wgt_inv, xxinv_svd= xxinv_svd, manual=manual, $
;	verbose=verbose, niter_max=niter_max, problem=problem, $
;	quiet=quiet
;
;************COMMENT ON INPUTS RELATED TO THE SVD COLUTION****************
;NOTE: these are normally read from disk in lsfs.pro using the command
;	restore, getenv( 'GALFAPATH') + 'savfiles/' + 'svd512.sav'
;These SVD-related inputs include:
;	XMATRIX (X in equation 22 of the tech memos)
;	WGTS ([W] in equation 28 of the tech memos)
;	WGT_INV ([1/W]  in equation 29 of the tech memos)
;	XXINV_SVD (alpha \cdot X^T) in equation 29 of the tech memos)
;***********************END OF COMMENTS********************************

;INPUTS:
;	XMATRIX, the equation-of-condition matrix for this particular set
;of frequency offsets. XMATRIX is generated by XMATRIXGEN.PRO. if there 
;are 512 channels and seven frequencies separated by the minimum redundancy
;criteria, xmatrix[ 1055, 3585]. 
;	STAMOD, the set of input power spectra. STAMOD[ 512,7]
;	FRQ0A, the set of input frequencies. FRQ0A[ 512, 7]
;	INDX0A, the indices that tell which channels in the input power
;spectra occupy which frequency bin in FNEW. from CARL_PRELIMINARY
;	FNEW, the set of new frequencies--covers the min to max freuency 
;range for the input spectra. FNEW[ 543].  from CARL_PRELIMINARY
;	
;KEYWORDS:
;	WGTS, the vector set of weights of the SVD fit.  this is NR's
;matrix W, which is the projection of the orthonormal vectors onto the
;vector space. 
;	WGT_INV, the inverse of WGTS, with appropriate elements set
;equal to zero if they would otherwise be too big. 
;	XXINV_SVD, the equivalet inverse of TRANSPOSE(XMATRIX)##XMATRIX
;computed with the perhaps-modified WGT_INV.
;	MANUAL is set if you want to stop after the SVD call and examine
;the WGTS vector and make appropriate adjustments.
;	NITER_MAX is the limiting nr of iterations. default is 100.
;	PROBLEM is nonzero if it didn't converge.
;PROBLEM=niter if it exceeded niter_max, ;PROBLEM=-niter if we get NaN's
;	VERBOSE: give lots of informatory comments
;	QUIET: suppress standard printing and plotting
;
;OUTPUTS:
;	MODFCTR, the set of multipliers to recover the input powers
;	G_G, THE I.F. GAINS. G_G[ 512]
;	RF_G, THE RF POWERS FOR FNEW. RF_G[ 543]
;	RF4_G, THE SET OF RF POWERS FOR THE LO FREQX. RF4_G[ 512,7]
;
;NOTES:
;	the original input powers are in arbitrary units. 
;	they are normalized here in so that their average is unity.
;	to recover the original powers, multiply by modfctr.
;
;	in short:
;
;	rf powers in originl units= modfctr* (1 + rf_g)  {for fnew frequencies}
;			          = modfctr* (1 + rf4_g) {for 7 512 chnls}
;
;	or 
;	rfpowers = stamod/ gg
;
;-

;FOR TESTING...
;VERBOSE=1

;print, 'carl9quiet ', quiet

;check for windows being opened...
device, window=opnd

if keyword_set( niter_max) eq 0 then niter_max= 100

;ASSUME NO PROBLEM...
problem=0

if keyword_set( quiet) ne 1 then begin
if opnd[ 0] eq 0 then window, 0, xs=600,ys=225
if opnd[ 2] eq 0 then window, 2, xs=600,ys=225
if opnd[ 4] eq 0 then window, 4, xs=600,ys=225
endif

n736= (size( stamod))[1]
nfsw= (size( stamod))[2]

niter= 0
modfctr= mean( stamod)
p_0= stamod/ modfctr

g_g= 1.+ fltarr( n736)
rf_g= fltarr( n736, nfsw)

;for nf= 0,nfsw-1 do begin
;rf4_g[ *, nf]= rf_g[ indx0a[ *,nf]]
rf4_g= rf_g[ indx0a]

;STOPPING CRITERIA...
critold= [100.,100.]
maxcritold= max( critold)
crit_delgold= 100.
crit_delrfold= 100.

ITERATE:

;CALCULATE p_g...
p_g= fltarr( n736, nfsw)
for nf=0,nfsw-1 do p_g[ *,nf]= g_g* (1.+ rf4_g[*, nf])

;CALCULATE THE DIFFERENCE BETWEEN THE ACTUAL INPUT AND THE GUESSSED...
;THIS IS THE VECTOR OF DATA...
delp= (p_0- p_g)
delp_overg= delp
for nf=0,nfsw-1 do delp_overg[*,nf]= delp[*,nf]/g_g

;CRITERIA STUFF...
critnew= abs( minmax( delp/p_0))
maxcritnew= max( critnew)
fraccrit= (maxcritnew- maxcritold)/ maxcritold
if keyword_set( verbose) then $
	print, 'maxcritnew, fraccrit= ', maxcritnew, fraccrit
;if ( maxcritnew lt 0.01 and fraccrit gt 0.001) then print, 'continue'
critold= critnew
maxcritold= maxcritnew

IF KEYWORD_SET( QUIET) NE 1 THEN BEGIN
wset,4
plot, p_0
oplot, p_g, color= !red
oplot, delp+ .2, color=!green
ENDIF

y= reform( delp_overg, n736* nfsw)
y= [y,0]

;stop, 'STOP -- CARL9 -- 2.0'

;THE BELOW STATEMENTS DO THE FULL SOLUTION USING SVD...
lsfit_svd, xmatrix, y, U, VV, $
        wgts, unknowns, vara, siga, ncov, s_sq, $
	wgt_inv=wgt_inv, xxinv_svd= xxinv_svd
                                                                                
if keyword_set( manual) then begin
	if manual ne -1 then stop, 'STOPPING IN MANUAL MODE IN CARL9'
	if manual eq -1 then begin
		print, 'MANUAL=-1; RETURNING FROM CARL9 WITHOUT PROCESSING.'
		return
	endif
endif

;stop, 'stop carl9, manual'

;IF YOU ARE GOING TO SAVE THE RESULTS...DO THIS;
;save, xmatrix,u,vv,wgts,wgt_inv,ncov,xxinv_svd, indx0a, file= *****

delg_overg= unknowns[ 0:n736-1]
delrf= unknowns[ n736:*]

;CRITERIA STUFF FOR G_G...
crit_delgnew= abs( max( minmax( delg_overg)))
fracgcrit= ( crit_delgnew- crit_delgold)/ crit_delgold
if keyword_set( verbose) then $
	print, 'crit_delgnew, fracgcrit = ', crit_delgnew, fracgcrit
;if ( maxcritnew lt 0.01 and fraccrit gt 0.001) then print, 'continue'
crit_delgold= crit_delgnew

;CRITERIA STUFF FOR RF_G...
crit_delrfnew= abs( max( minmax( delrf)))
fracrfcrit= ( crit_delrfnew- crit_delrfold)/ crit_delrfold
if keyword_set( verbose) then $
	print, 'crit_delrfhew, fracrfcrit = ', crit_delrfnew, fracrfcrit
crit_delrfold= crit_delrfnew

indx_delg= where( finite( delg_overg) ne 1, count_delg)
indx_delrf= where( finite( delrf) ne 1, count_delrf)

;CHECK FOR GOOD SOLUTIONS...
IF  COUNT_DELG NE 0 OR COUNT_DELRF NE 0 THEN BEGIN
	problem= -niter
	print, 'nonconvergence! problem = ', problem
	goto, quit
ENDIF

g_gnew= g_g* (1. + delg_overg)
rf_gnew= rf_g+ delrf
rf4_gnew= rf_gnew[ indx0a]

IF KEYWORD_SET( QUIET) NE 1 THEN BEGIN
wset,0
plot, frq0a[ *,0], g_g  ;;;, xra=[1380, 1460], /xsty
oplot, frq0a[ *,0], g_gnew, color=!red
;plot, frq0a[ *,0], g_g - g_gnew, charsize=2, yra=1.0e-4* [-1,1]

wset,2
plot, fnew, rf_g ;;;, xra=[1380, 1460], /xsty
oplot, fnew, rf_gnew, color=!red
;plot, fnew, rf_g- rf_gnew, charsize=2, yra=1.0e-4* [-1,1]
ENDIF

niter= niter+ 1
if keyword_set( verbose) then $
	print, niter

IF ( CRIT_DELGNEW) LT 1.0E-4 THEN BEGIN
;	PRINT, 'TIME TO QUIT!'
	goto, quit
ENDIF

;KEYBOARD CONTROL...
;result= get_kbrd(1)
;if (result eq 'q')  then goto, quit

g_g= g_gnew
rf_g= rf_gnew
rf4_g= rf4_gnew

if niter gt niter_max then begin
	print, 'nr iterations = ', niter, ' exceeds niter_max ', niter_max
	problem= niter
	goto, quit
endif

goto, iterate

quit:  

if keyword_set( quiet) ne 1 then print, niter, '  iterations'
return

end

