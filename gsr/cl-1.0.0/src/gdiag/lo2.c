
//  This is -totally- Areicobo specific.  This sets the LO2 
//  frequency.  LO2 is generated by an Agilent synthesizer
//  in the rack with the galfa hardware.  The frequency
//  synth has a GPIB interface, this is connected to one of
//  those overly expensive NI GPIB/ENET convertor boxes.
//
//  Rather the deal with national instruments crazy libraries
//  and such, arecibo (jeff hagen I think) setup a machine 
//  that runs a gpib proxy sever (gpibsock).  
//
//  This routine uses Jeff Hagen's socket library to contact
//  the gpibproxy running on the machine specified in the 
//  /etc/mailboxdefs file and attempts to set LO2.
//
//  So, there are several areas where things can go wrong.
//  This code talks over a socket to gpibsock, probably
//  on the machine dataview.  dataview makes a socket connection
//  to an NI GPIB/ENET box.  The NI box talks to the freq
//  synthesizer.  If any of these devices is borked setting
//  LO2 will fail.
//
//  If you're reading this because you are trying to get it
//  working outside Arecibo, best of luck, it's going to take
//  a little work...
//


#include "ab.h"
#include "pixmap.h"
#include <math.h>
#include <fftw3.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <getopt.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>


#include "sock.h"
#include "galfa_sock/galfa_sock.h"
#include "galfa.h"

#define LO2_LEVEL   3.0         // Level for sig generator +3dBm
#define LO2_TIMEOUT 2           // How long to wait for response
#define LO2_MULT    2.0         // 2x desired mix freq for funny mixer chip
#define LO2_ERR     1e-6        // Max err (in MHz) tolerated for LO2 freq

// #define LO2_DEBUG

void
lo2_set(double f)
{
    int     ret;
    int     source, len;
    int     ct_flag = 8192;
    char    *message;
    char    cmd[256];
    double  rf;

    f *= LO2_MULT;
    sprintf(cmd, "FREQ GALFA_SYN %f %+f", f, LO2_LEVEL);
#ifdef LO2_DEBUG
    printf("LO2 command: %s\n", cmd);
#endif

    message = (char *)malloc(ct_flag);
    
    sock_bind("ANONYMOUS");
    sock_bufct(ct_flag);

    source = sock_connect("GPIB");
    if (source <= 0) {
        printf("\nLO2: connect bork\n");
        release_exit(1);
    }

    ret = sock_send(source, cmd);
    if (ret < 0) {
        printf("LO2: send failed.\n");
        release_exit(1);
    }

    ret = sock_sel( message, &len, NULL, 0, LO2_TIMEOUT, 0);
    if (ret < 0) {
        printf("LO2: Failed to get response setting freq.\n");
        release_exit(1);
    } else {
#ifdef LO2_DEBUG
        printf("LO2: Got back -%s-\n", message);
#endif
        if (strncmp(message, "OK", 3)) {
            printf("LO2: Set failed, got back: %s\n", message);
            release_exit(1);
        }
    }

    ret = sock_send(source, "REPLY GALFA_SYN FREQ:CW?");
    if (ret < 0) {
        printf("LO2: send failed.\n");
        release_exit(1);
    }
    ret = sock_sel( message, &len, NULL, 0, 2, 0);
    if (ret < 0) {
        printf("LO2: Failed to get reply reading freq\n");
        exit(1);
    } else {
        // Set in MHz, but reads back in Hz for unknown reason...
        rf = strtod(message, NULL) / 1000000.0;
#ifdef LO2_DEBUG
        printf("LO2: Got back reply %s\n", message);
        printf("LO2: Set %f, got %f\n", f, rf);
#endif
        if (fabs(f - rf) > LO2_ERR) {
            printf("LO2: Freq error: set %f, got %f\n", f, rf);
            release_exit(1);
        }
            
    } 

    sock_close(NULL);
    free(message);
    printf("LO2: Frequency synthesize set to %f MHz\n", rf);
}

