<!-- This file was generated by mk_html_help_ph.pro -->
<html>
 
<head>
<TITLE>ri (a/d) idl routines</TITLE>
</head>
 
<body bgcolor=white>
<H1>ri (a/d) idl routines</H1>
<STRONG>Last modified: </STRONG>Fri Oct 22 15:09:59 2004.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#RICROSS2DFIT - FIT 2D GAUSSIAN TO A CROSS PATTERN.">
RICROSS2DFIT - FIT 2D GAUSSIAN TO A CROSS PATTERN.</A>
<LI><A HREF="#
RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS">
RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS</A>
<LI><A HREF="#RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS">
RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS</A>
<LI><A HREF="#RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN">
RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN</A>
<LI><A HREF="#RICROSSPLT - PLOT THE DATA FROM A CROSS">
RICROSSPLT - PLOT THE DATA FROM A CROSS</A>
<LI><A HREF="#RIGET - INPUT AN RI RECORD">RIGET - INPUT AN RI RECORD</A>
<LI><A HREF="#RIGETHDR - INPUT AN RI HEADER">RIGETHDR - INPUT AN RI HEADER</A>
<LI><A HREF="#RIMONIMG - MONITOR RI DATA">RIMONIMG - MONITOR RI DATA</A>
<LI><A HREF="#RISTRIPCH - STRIPCHART RECORDING OF TOTAL POWER">
RISTRIPCH - STRIPCHART RECORDING OF TOTAL POWER</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="RICROSS2DFIT - FIT 2D GAUSSIAN TO A CROSS PATTERN.">
<H2>RICROSS2DFIT - FIT 2D GAUSSIAN TO A CROSS PATTERN.</H2></A>
<A HREF="#RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ricross2dfit - fit 2d gaussian to a cross pattern.
SYNTAX: coef=ricross2dfit(baz,bza,coefinit,azfit=azfit,zafit=zafit,$
             covar=covar,chisq=chisq,sigma=sigma,sigCoef=sigCoef,$
             trouble=trouble,weights=weights
ARGS:
   baz :{ricrossinp} azimuuth input info
   bza :{ricrossinp} za       input info
coefinit[10]:floats  initial values for coef.
              [0] - offset
              [1] - amplitude
              [2] - xoffset
              [3] - yoffset
              [4] - fwhm az (amin)
              [5] - fwhm za (amin)
              [6] - theta  rotate unprimed to primed aligned along ellipsoid 
                           of beam, degrees.
KEYWORDS:
   pol : int  0 (def) return polA, 1 --> return polB

RETURNS:
azfit[npts]: fit evaluated along az strip
zafit[npts]: fit evaluated along za strip
covar[7,7]:float covariance matrix
       chisq:float chisq of fit
      sigma :float sigma of fit
 sigCoef[7]:float sigmas for coefficients
 weights[npts,2]: weights to use az,za
                smaller number, less important
NOTES:
   Set fwhm az,za to slightly different values. The routine lets curvefit
(in idl) compute the derivatives). If the fwhm are the same, then the
rotation angle theta has not affect. The derivative comes out to be 0
and it divides by the partial derivative array when doing the fit..
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ricross2dfit.pro)</STRONG><P>
<HR>
 
<A NAME="RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS">
<H2>RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS</H2></A>
<A HREF="#RICROSS2DFIT - FIT 2D GAUSSIAN TO A CROSS PATTERN.
">[Previous Routine]</A>
<A HREF="#RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ricrosscal - compute the cal scaling factor for ri cross patterns
SYNTAX: ncal=ricrosscal(bcal,bscale,calval)
ARGS:   bcal[n]:  {cross} cal scans input from ricrossinp.
RETURNS:
      bscale[2,n]:float  scale factor to convert counts to kelvins
      calval[2,n]:float  cal value used (pola,polB)used
      ncal       : int   number of cal records processed

DESCRIPTION:
   The ricrossinp routine returns the data and cal records for a cross
pattern. This routine will compute the conversion factor from a/d counts
to Kelvins using the cal record and the cal value (in kelvins).

   The input data structure returned from ricrossinp is:

        bcal.h[nrecs]     {hdr} header from each rec of strip
        bcal.don[npts,2]  float cal On samples 
        bcal.doff[npts,2] float cal off samples
        b.d[npts,2]  - the data polA,b

   Normally then second index is polA, or polB (since the ricrossinp
routine uses detected data).

   The routine will lookup the cal value using calget().
the conversion factor from kelevins
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ricrosscal.pro)</STRONG><P>
<HR>
 
<A NAME="RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS">
<H2>RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS</H2></A>
<A HREF="#RICROSSCAL - COMPUTE THE CAL SCALING FACTOR FOR RI CROSS PATTERNS
">[Previous Routine]</A>
<A HREF="#RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ricrossinp - get 1 or more ri cross patterns
SYNTAX: patInp=ricrossinp(lun,baz,bza,bcal,patreq,scan=scan)
ARGS:   lun : long  lun to read from
      patreq: long  the number of patterns to read in
RETURNS:
        baz : {} return az strips
        bza : {} return za strips
       bcal : {} return cals here if we find them
      patInp: long number of patterns input

DESCRIPTION:
   Read in 1 or more ricross patterns. The pattern has an az strip and 
a za strip. These are return in baz and bza. If cals were taken then they
will be returned in bcal. By default, the routine starts reading from the 
current position in the file. If the scan keyword is supplied then 
it will position to scan before reading the data. The format of the returned
data for a single pattern is (either baz or bza):
   b.h[nrecs]   - header from each rec of az or za strip
   b.d[npts,2]  - all the data for 1 strip. The second dimension is polA,B
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ricrossinp.pro)</STRONG><P>
<HR>
 
<A NAME="RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN">
<H2>RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN</H2></A>
<A HREF="#RICROSSINP - GET 1 OR MORE RI CROSS PATTERNS">[Previous Routine]</A>
<A HREF="#RICROSSPLT - PLOT THE DATA FROM A CROSS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ricrossinp1 - get 1 strip of a cross pattern
SYNTAX: istat=ricrossinp1(lun,b)
ARGS:   lun : long lun to read from
        b.{ }: structure from the cross pattern (either az or za strip)
        b.d[npts,2]  - the data polA,b
DESCRIPTION:
   This routine is call by ricrossinp to input a single strip of the
ricross pattern.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ricrossinp1.pro)</STRONG><P>
<HR>
 
<A NAME="RICROSSPLT - PLOT THE DATA FROM A CROSS">
<H2>RICROSSPLT - PLOT THE DATA FROM A CROSS</H2></A>
<A HREF="#RICROSSINP1 - GET 1 STRIP OF A CROSS PATTERN">[Previous Routine]</A>
<A HREF="#RIGET - INPUT AN RI RECORD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ricrossplt - plot the data from a cross
SYNTAX: ricrossplt,baz,bza,az=az,za=za,step=step,pol=pol
ARGS:
   baz[n]: {anoncross} hold az info
   bza[n]: {anoncross} hold za info
KEYWORDS:
   az   if set then include az in plots        
   za   if set then include za in plots        
  pol:  string "a", or "b" if not provided, then plot both
step=step  if n>1 then do a strip plot with this step between strips
           default is 0.
DESCRIPTION:
   plot the data input from ricrossinp. The default is to plot
both az and za. If only az is set or only za is set, then
just that axis will be plotted. If n is > 1 then the strips will be
overplotted with a step between each strip.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ricrossplt.pro)</STRONG><P>
<HR>
 
<A NAME="RIGET - INPUT AN RI RECORD">
<H2>RIGET - INPUT AN RI RECORD</H2></A>
<A HREF="#RICROSSPLT - PLOT THE DATA FROM A CROSS">[Previous Routine]</A>
<A HREF="#RIGETHDR - INPUT AN RI HEADER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
riget - input an ri record
SYNTAX: istat=riget(lun,b,scan=scan,numrecs=numrecs,complex=complex,sl=sl,
                     verbose=verbose,hdr=hdr,search=search)
ARGS:   lun    : unit number for file (already opened)
        b[]    : {riget} return data here.
KEYWORDS:
       scan    : long . scan to position to before reading the data.
       numrecs : long .. number of records to return
       complex : if set then return d1 and or d2 as complex numbers
                 q (right bnc) real
                 i (left bnc) imaginary
       sl[]    : {scanlist} array returned from getsl(lun). This can be used
                  for random access of files (see generic routines: getsl())
       verbose : if set then print out timing info
       hdr     : if supplied, then this is the format of the header to use
       search  : if set then search for the next header if a bad hdrid is 
				  found. Use this for datafiles that don't start with a hdr.
RETURNS:
        istat  : int
       nrecs - number of records read..
           0 - hit eof
          -1 - could not position to requested scan
          -2 - bad data in hdr
DESCRIPTION:
   Read the next ri numrecs (default 1) records from lun. Start at the current
record position unless the scan keyword is present.
The data is returned in the structure b. If numrecs is set greater than
1 then b[numrecs] will be an array of structures and all the next
numrec records must be the same type (hdr and data).

   The caller should have already defined the {hdr} structure  before calling
this routine (usually done in the xxriinit routine for the particular 
datataking program). The structure contents depends on the complex keyword:
 If keyword complex is not set:

   b.h  header
     h.std
     h.ri,proc,pnt,iflo depending on the datataking program used
   b.d1[2,npts]  floats:  1st or only data channel q,i
   b.d2[2,npts]  floats:  if both input channels (fifos) used this is the 2nd

 In this case dx[0,*] is Q the rightmost bnc of the pair
              dx[1,*] is I the leftmost bnc  of the pair

 If keyword complex is set then:
   b.h  header
     h.std
     h.ri,proc,pnt,iflo depending on the datataking program used
   b.d1[npts]  complex  1st or only data channel
   b.d2[npts]  complex  if both input channels (fifos) are used then
					     this is the second channel.

 In this case real (dx[]) is Q the rightmost bnc of the pair
              img  (dx[]) is I the leftmost bnc of the pair
EXAMPLES:
	To use this routine:
	0. idl
	1. make sure the path to aodefdir() is in your path directory:
		!path='/home/phil/idl/gen' + !path  .. if you are at ao.. 
		You can also put this in your IDL_STARTUP file if you like.
	2. idl
	3. @rirawinit		.. sets up the paths, headers for ri data
   4. openr,lun,'/share/olda/datafile.12feb03.x101.1',/get_lun
	5. npat=riget(lun,b,numrecs=10,/complex)

TIMING:
   timing measurements were done on pat. Using 100 records with the 
listed samples per digitizer. The times are in seconds. The last column
is the time to process 1 million a/d samples.

 nfifo packing complex smples tmtot tmio tmcmp tm1MillionPnts

   1    12       1      16000  .803  .056  .747   .467
   1     8       1      16000                    1.202
   1     4       1      16000                    1.093
   1     2       1      16000                    1.354
   1     1       1      16384                    1.064

   1    12       0      16000                     .131
   1     8       0      16000                    1.731
   1     4       0      16000                    1.649
   1     2       0      16000                    1.615
   1     1       0      16384                    1.635


   2    12       1      6144  0.788  .079  .710  1.155
   2     8       1      6144  1.670  .041 1.629  2.652
   2     4       1     16384  3.925  .054 3.871  2.363
   2     2       1     16384  3.855  .037 3.818  2.331
   2     1       1     16384  3.637  .029 3.608  2.202

   2    12       0      6144  0.546  .051  .495   .805
   2     8       0      6144  2.347  .037 2.310  3.760
   2     4       0     16384                     3.414
   2     2       0     16384                     3.306
   2     1       0     16384                     3.339
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/riget.pro)</STRONG><P>
<HR>
 
<A NAME="RIGETHDR - INPUT AN RI HEADER">
<H2>RIGETHDR - INPUT AN RI HEADER</H2></A>
<A HREF="#RIGET - INPUT AN RI RECORD">[Previous Routine]</A>
<A HREF="#RIMONIMG - MONITOR RI DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rigethdr - input an ri header
SYNTAX: istat=rigethdr(lun,hdr,scan=scan,pos=pos)
ARGS:   lun    : unit number for file (already opened)
        hdr    : {hdr} return data here.
KEYWORDS:
       scan    : long . position to start of this scan before reading
       pos     : int  . 1 - position to start of this header before returning
RETURNS:
        istat  : int
           1 - gotit
           0 - hit eof
          -1 - could not position to requested scan
          -2 -  bad data in hdr
DESCRIPTION:
   Read the next ri header and return it. Optionally position to the start
of this header before returning. This routine is used to peak at the
header to decide how to process the record before calling riget.

   The caller should have already defined the {hdr} structure  before calling
this routine (usually done in the xxriinit routine for the particular 
datataking program). 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/rigethdr.pro)</STRONG><P>
<HR>
 
<A NAME="RIMONIMG - MONITOR RI DATA">
<H2>RIMONIMG - MONITOR RI DATA</H2></A>
<A HREF="#RIGETHDR - INPUT AN RI HEADER">[Previous Routine]</A>
<A HREF="#RISTRIPCH - STRIPCHART RECORDING OF TOTAL POWER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rimonimg - monitor ri data
SYNTAX: img=rimonimg(fbase,num,lun=lun,tmtoavg=tmtoavg,
					numx=numx,numy=numy,usefifo2=usefifo2,d=d,val=val,
					pixwin=pixwin,ilim=ilim)
ARGS:
  fbase: string Base filename to read from (eg '/share/aeron5/24jul03').
                Do not include the . or file number.
   num : int    file number of file to start on. 

KEYWORDS:
   lun : int    If provided, then process this file from the current 
                position. When done with the file return. In this case
                fbase and num are ignored. You also can not jump to other 
                files from the internal menu.
ipptoavg:long   number of ipps to average together. The default is none
tmtoavg: long   number of time points to average. default is none
numDisp: long   The number of averaged ipps to display in the image. The
                default is 900 averaged ipps.
usefifo2:       If set then use fifo 2. The default is fifo 1.
 val[2]: float  Clip the  power (a/d levels squared) to [min,max] and
                then scale to the full range of the display device (
                0 to 255). The default is to clip the power at 6 sigma
                (as measured from the first image).

 pixwin:        if set then use a pixwin when drawing a new image. This
                cuts down on the flashing. It is useful when you are
                averaging only 1 or 2 ipps.
 ilim  : long   if supplied then limit image to these indices of the 
			     data rec (0 based).
RETURNS:
   img[m,numDisp]:float    the last image displayed.
   d[n]         if this keyword is provided then the data read
                for the last image is returned here.
DESCRIPTION:
   rimonimg will make continuous images of meteor data. The mean is removed from
the voltages, power is computed, and then toavg ipps are averaged together.
numDisp averaged ipps are then displayed as height versus time. When 
the end of file is hit, the routine will advance to the next filenumber.
If no data is available, the routine will wait until it becomes available.
   The user can modify things by hitting any key and bringing up an
internal menu:

Cmd CurVal   function
 a dome      antenna ch, dome
 f   70      move to new fileNum
 l           list all files
 n           next file (or quit if 1 file)
 q           to quit
 r           rewind current file
 s  0        single step 0,1 (off,on)
 otherkey    continue

The commands are:

 a  dome/ch  This lets you switch between dome and carriage house display

 f  filenum  You can start displaying at the start of a different 
             filenumber. If the new filenumber is illegal then no 
             change is made.

 l           This will list all of the available files starting with
             fbase. The last file will also contain its size.

 n           move to the next file number.

 q           quit the routine.

 r           rewind and start over in the current file.

 s  0,1      turn on,off single step mode.When it is on, the routine
             will pause after every image waiting for the user to
             enter return.

 otherKey    any other key will cause the display to continue.
             This allows you to pause the display to look at it for
             a while.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/rimonimg.pro)</STRONG><P>
<HR>
 
<A NAME="RISTRIPCH - STRIPCHART RECORDING OF TOTAL POWER">
<H2>RISTRIPCH - STRIPCHART RECORDING OF TOTAL POWER</H2></A>
<A HREF="#RIMONIMG - MONITOR RI DATA">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ristripch - stripchart recording of total power
SYNTAX:   corstripch,lun,maxpnt=maxpnt,v1=v1,v2=v2,mean=mean,$
                   scan=scan,rec=rec,rdDelay=rdDelay,pltDelay=pltDelay,$
                   rdStep=rdStep,win=win
 ARGS:
   lun:    int     to read power from
KEYWORDS:
   maxpnt: long    max number of points to display at once. default: 1000
   v1[2] : float   min,max value for top plot
   v2[2] : float   min,max value for bottom plot (polA-polB)
   mean  : long    if set then remove mean from both plots.
   scan : long     position to scan before starting. The
                   default is the current position
   rec   : long    record of scan to position to before starting.
                   default: if scan present then:1 else current rec.
rdDelay: float     number of seconds to wait between reads if no new
                   data available.
pltDelay: float    number of seconds to wait after each plot. Use this
                   to slowly scan a file that already exists.
   rdStep: long    max number of points to try and read at a time. Plot
                   will increment by this amount when you read a file.
   win   : long    window number to plot in. Default is 0
DESCRIPTION:
   The routine makes a stripchart recording of the total power and power
difference polA-polB. It will step through the data file displaying
up to MAXPNT pnts on the screen. When this value is reached, the plot will
start scolling to the left. When the end of file is hit, the routine
will wait rdDelay seconds (default of 1 second) and then try to read
any new data in the file. This allows you to monitor data as it is 
being taken. If you are scrolling through a file offline, use PLTDELAY
to slow down the plotting rate (if it is too fast). At the end of the file
hit any key and the enter q to quit (see below).

   The top plot is the 0lag total power. The units are linear in power and the
definition is measured/optimum power (for statistics of 3/9level sampling).
You can change the vertical scale with the v1[min,max] keyword or from the
menu displayed you hit any key. The line colors correspond to the 8 
subcorrelators available on the interim correlator.

   The bottom plot is the power difference PolA-PolB for each correlator
board (NOTE: currently this only works if polA,polB are on the same board).
The vertical scale can be changed with the v2=v2[min,max] keyword or from
the menu displayed when you hit any key.

   You can stop the plotting by touching any key on the keyboard.
A menu will be presented that lets you modify some parameters and then
continue. The menu is:

command       function
q             to quit
r             rewind file
v1  min max   new min,max for top    window 
v2  min max   new min,max for bottom window 
blank line ..continue 

   You can quit, rewind the file and continue, change the vertical scale of
the top plot with v1 min max, or change the vertical scale of the bottom
plot. Any other inputline will let you continue from where you are
(unlike cormonall, you have to enter return for the program to read the
inputline.

EXAMPLES:
1. monitor the online datataking:
   lun=coronl()
   corstripch,lun

2. set fewer points per plot for better resolution. Set the top vertical
   scale to .8,2. and the bottom plot to -.4,.4.
   corstripch,lun,maxpnt=600,v1=[.8,2],v2=[-.4,.4]

3. If you want to restart from the begining of the file:
   hit any character
   r 
   and it will rewind an continue

4. If you want to monitor a file offline, with no wait between
   updates, and 500 points plotted:
   openr,lun,'/share/olcor/corfile.30apr03.x102.1',/get_lun
   corstripch,lun,maxpnt=500,v1=[.5,3]

5. Do the same thing but wait 1 second between plots and read 200 points at
   a time:
   corstripch,lun,maxpnt=500,v1=[.5,3],pltDelay=1,rdstep=200

NOTE:
   You can change the size of the plot by expanding or contracting the
plot window. The plot will rescale itself.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/ri/ristripch.pro)</STRONG><P>
<HR>
 
</body>
</html>
