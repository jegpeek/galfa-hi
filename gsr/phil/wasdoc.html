<!-- This file was generated by mk_html_help_ph.pro -->
<html>
 
<head>
<TITLE>was (wapp spectral line) idl routines</TITLE>
</head>
 
<body bgcolor=white>
<H1>was (wapp spectral line) idl routines</H1>
<STRONG>Last modified: </STRONG>Wed Oct 27 18:05:04 2004.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ARCH_GETALFARADEC - GET ALFA RA/DEC FROM THE ARCHIVE.">
ARCH_GETALFARADEC - GET ALFA RA/DEC FROM THE ARCHIVE.</A>
<LI><A HREF="#ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS">
ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS</A>
<LI><A HREF="#ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE">
ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE</A>
<LI><A HREF="#ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.">
ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.</A>
<LI><A HREF="#A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.">
A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.</A>
<LI><A HREF="#CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.">
CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.</A>
<LI><A HREF="#CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.">
CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.</A>
<LI><A HREF="#CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.">
CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.</A>
<LI><A HREF="#CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.">
CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.</A>
<LI><A HREF="#CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.">
CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.</A>
<LI><A HREF="#CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE">
CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE</A>
<LI><A HREF="#CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.">
CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.</A>
<LI><A HREF="#CORHGAINGET - RETURN THE GAIN GIVEN A HEADER">
CORHGAINGET - RETURN THE GAIN GIVEN A HEADER</A>
<LI><A HREF="#CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE">
CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE</A>
<LI><A HREF="#CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE">
CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE</A>
<LI><A HREF="#CORPLOT - PLOT THE CORRELATOR DATA.">
CORPLOT - PLOT THE CORRELATOR DATA.</A>
<LI><A HREF="#GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.">
GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.</A>
<LI><A HREF="#SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE">
SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE</A>
<LI><A HREF="#WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA">
WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA</A>
<LI><A HREF="#WASALFAPLOTCROSS - PLOT ALFA CROSS DATA">
WASALFAPLOTCROSS - PLOT ALFA CROSS DATA</A>
<LI><A HREF="#WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD">
WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD</A>
<LI><A HREF="#WASCLOSE - CLOSE A WAS FILE FOR I/O">
WASCLOSE - CLOSE A WAS FILE FOR I/O</A>
<LI><A HREF="#WASFTOCHDR - CONVERT FITS HDR TO COR HEADER">
WASFTOCHDR - CONVERT FITS HDR TO COR HEADER</A>
<LI><A HREF="#WASGET - READ A GROUP  OF WAS DATA RECORDS.">
WASGET - READ A GROUP  OF WAS DATA RECORDS.</A>
<LI><A HREF="#WASHDR - READ A WAS FITS HEADER">WASHDR - READ A WAS FITS HEADER
</A>
<LI><A HREF="#WASLIST - LIST CONTENTS OF A WAS DATA FILE">
WASLIST - LIST CONTENTS OF A WAS DATA FILE</A>
<LI><A HREF="#WASOPEN - OPEN A WAS FITS FILES FOR I/O">
WASOPEN - OPEN A WAS FITS FILES FOR I/O</A>
<LI><A HREF="#WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE">
WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE</A>
<LI><A HREF="#WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID">
WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID</A>
<LI><A HREF="#WASPWR - RETURN POWER INFORMATION FOR A NUMBER OF RECS">
WASPWR - RETURN POWER INFORMATION FOR A NUMBER OF RECS</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ARCH_GETALFARADEC - GET ALFA RA/DEC FROM THE ARCHIVE.">
<H2>ARCH_GETALFARADEC - GET ALFA RA/DEC FROM THE ARCHIVE.</H2></A>
<A HREF="#ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
arch_getalfaradec - get alfa ra/dec from the archive.

SYNTAX: npts=arch_getalfaradec,yyyymmdd1,yyyymmdd2,raHr,decDeg,$
                    projid=projid,procname=procname,srcname=srcname,$
                    numrecs=numrecs,scanRange=scanRange,$
                    slar=slar,slfilear=slfilear,indAr=indAr,scanAr=scanAr,$
                    sym=sym,plotit=plotit,verb=verb,gt12=gt12
ARGS:
   yyyymmdd1: long  first date to include in data search eg.. 20040903
   yyyymmdd2: long  last date to include in the data search.

KEYWORDS:

   Keywords to limit the data set:

   projid: string   limit the data to scans taken with this project
                    idea. An example would be 'a1943'
 procname: string   limit the data to scans taken by this pattern/procedure.
                    Some example names are: 'onoff','cal','smartf','basket', 
                    'fixedaz','spiderAn' (n=0,6),'crossAn' (n=0,6), 
					 'driftmap','driftalt','driftch'
 srcname:  string   limit the data to this source name.
 numrecs:  long     limit the data to scans that have this many records.
                    This can be used to exclude partial scans.
 scanrange[2]:long  limit the data to scans that are between 
                    scanrange[0] le scan le scanrange[1]

 Keywords for plotting/printing:
   plotit:          If set then plot the ra,dec values as they are read in.
                    It replots the data on each block of scans processed.
                    The last block of scans is always plotted in red.
   sym   : int      The symbol to used for plotting. The default is
                    2 (*). other symbols are 1(+), 3(.), 4(triangle).
   gt12  :          If set then force plotted data to be greater than
                    twelve hours. Values less than 12 hours are incremented
                    by 24. This is only for the plotted data. Use this 
                    when you have data that spans a range like: 22 to 2 hours.
   verb  :          If set then print scans and number of records as they
                    are processed (one block at a time).
  batch  :  int     By default the routine processes one scan at a time.
					 You can set batch to a larger value (say 10) and it
				     will read in and process 10 scans at at time. This
					 will speed up processing if you have the plotit option
				     set. /plotit replots all points done adding the new
					 one just processed. If the batch is set to 10 then
				     the replots will happen every 10 scans rather than
				     every scan.
   
RETURNS:
  rahr[7,npts]: dbl  The ra in hours for the 7 beams and Npts points.
decDeg[7,npts]: dbl  The declination in degrees for the beams and Npts points.
  scanAr[npts]: long The scan numbers for the npts.
  slar[m]     :{slar}     The slar for the date range and projid. 
  slfilear[j] :{slfilear} The filename array for the date range and projid.
  indar[npts] : long      The indices into slar for the data that 
                     matches all of the criteria specified. 
DESCRIPTION:
   arch_getalfaradec will search the was2 archive at the observatory
and find all of the scans that match the criteria specified by the 
user. The scans must match all of these criteria to be included (logical and).

   The matching scans are then input batch scans at a time (the default
for batch is 1). This data is passed to wasalfacmpradec to compute the 
ra/dec position for the 7 alfa beams for each of the data samples. 

	The computed ra,decs are optionally
plotted on the screen as they are processed (the user should set the
horizontal/vertical scale with hor ver if they want to exclude some
outliers in the plots).

   When done processing, the ra and dec arrays are returned to the 
caller. The slar and slfilear can optionally be returned thru the
respective keywords. The indar holding the indices into slar[] for the scans
that matched the criteria is also returned.

EXAMPLES:
   Find all of the basket weave scans taken by a1943 between 03sep04
and 06sep04 on NGC7469. Limit the scans to complete strips of 60 records.
Return only scans after scan number 424767055L (the previous scans of the
day had some problems).

yymmdd1=20040903
yymmdd2=20040906
srcname='NGC7469'
projid='a1943'
numrecs=60
procname='basket'
scanrange=[424767055L,500000000L]
npnts=arch_getalfaradec(yymmdd1,yymmdd2,raAr,decAr,projid=projid,$
            procname=procname,srcname=srcname,numrecs=numrecs,$
            scanrange=scanrange,slar=slar,slfilear=slfilear,$
            indar=indar,scanar=scanar,sym=2,/plotit,/verb,/gt12)

;  now plot out the ra,decs with a different color for each beam.

   ldcolph
   sym=2
   hor,min(rahr),max(rahr)
   ver,min(decdeg),max(decdeg)
   plot,[0,1],[0,1],/nodata
   for i=0,6 do $
       oplot,rahr[i,*],decdeg[i,*],color=colph[i+1],psym=sym

;  plot the average az,za for each scan we found

   plot,slar[indar].azavg,slar[indar].zaavg,psym=2

;  look at what else is available in slar
   help,slar,/st

SEE ALSO:
   wasalfcmpradec (was2 routines)
   alfabmpos      (gen/pnt idl pointing routines
   arch_getdata   (was2)
NOTE:
   You need to run this routine at the AO observatory (since the data 
archive does not exist at remote sites).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/arch_getalfaradec.pro)</STRONG><P>
<HR>
 
<A NAME="ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS">
<H2>ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS</H2></A>
<A HREF="#ARCH_GETALFARADEC - GET ALFA RA/DEC FROM THE ARCHIVE.
">[Previous Routine]</A>
<A HREF="#ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
arch_getdata - get cor data using the archive tbl arrays
SYNTAX: n=arch_getdata(slAr,slfileAr,indAr,b,type=type,incompat=incompat,
                       han=han,missing=missing,hdrsonly=hdrsonly)
ARGS: 
      slAr[l]   : {slwas} returned by arch_gettbl
    slFileAr[m] : {slInd} returned by arch_gettbl
     indAr[]    : long indices into slar to return
KEYWORDS:
       type     :  int  0 first  rec (hdr and data) of each scan1
                :       1 hdrs from first rec of each scan
                :       2 all recs each scan  (hdr and data)
                :       3 average rec (hdr and data) each scan
                :       4 all hdrs from scan
hdrsonly        : if set, then type 0,2,3 will return a data
                          struct with only b.n.h and b.h.hf no data will
                          be returned. For was data, types 1,4 don't
                          work since there are .h and .hf header 
                          entries.
RETURNS:
     n :    int number of elements in b
     b :    depending on type it can be {corget} or {hdr} 
slind[n]: long the index into slar for each element returned in b.
              
incompat[p]   long indices in indAr that were not returned because the
                   datatype differs from that of the first record
 missing[m]   long indices in indAr that were not in the file location
                   that the database had recorded.

DESCRIPTION:
   After using arch_gettbl() and possibly where(), call this routine
to read the header and data from disc. What you get back is determined by
the keyword type and ind. The number of elements in b[] can be greater
than the number of indices in ind[] (eg you asked for all of the records 
of the scans, or you are returning just headers). The slind keyword
array has the same number of elements as b. It contains the index into
slAr for each elements of b.

EXAMPLES

;get all data for jan02->apr02 cband
   nscans=arch_gettbl(20040101,20040430,slAr,slFileAr,rcv=9)

;  get note.. corfindpat does not yet work with was data..
;
NOTE:
   When returning just headers, each header of each board is returned
as a separate entry in b[]. Use slind to figure out which scan each
belongs to.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/arch_getdata.pro)</STRONG><P>
<HR>
 
<A NAME="ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE">
<H2>ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE</H2></A>
<A HREF="#ARCH_GETDATA - GET COR DATA USING THE ARCHIVE TBL ARRAYS
">[Previous Routine]</A>
<A HREF="#ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
arch_gettbl - input table of scans from cor archive
SYNTAX: nscans=arch_gettbl(yymmdd1,yymmdd2,slAr,slfileAr,rcvnum=rcvnum,
                            freq=freq,proj=proj)
ARGS: 
      yyyymmdd1  : long    year,month,day of first day to get (ast)
      yyyymmdd2  : long    year,month,day of last  day to get (ast)
KEYWORDS:
       rcvnum  : long  .. receiver number to extract:
                       1=327,2=430,3=610,5=lbw,6=lbn,7=sbw,8=sbw,9=cb,$
                       10=xb,12=sbn,100=430ch
       freq[2] : float  Require cfr of band to be between freq[0] and freq[1]
                        in Mhz. At least 1 sbc of scan must match this.
       proj    : string project number to match (eg. 'a1473')
RETURNS:
   slAr[count] : {sl} or {corsl}   scanlist array for each scan
   slFileAr[n] : {slInd} one entry per file found
        nscans : long   number of scans found
DESCRIPTION:
   This routine will scan the was archive and return a table 
(an array of scanlist structures) for all scans in the archive that meet 
the requested criteria. Two arrays are returned:
1. slAr[]      holds 1 entry per scan 
2. slfileAr[m] holds 1 entry per file found.

   Each slAr entry is an {sl} or {corsl} structure that contains:
a={slwas ,$
    scan      :         0L, $; scannumber this entry
    rowStart  :         0L, $; row in fits file start of scan 0 based.
    fileindex :         0L, $; lets you point to a filename array
    stat      :         0B ,$; not used yet..
    rcvnum    :         0B ,$; receiver number 1-16, 17=alfa
    numfrq    :         0B ,$; number of freq,cor boards used this scan
    rectype   :         0B ,$;1-calon,2-caloff,3-posOn,4-posOff
    numrecs   :         0L ,$; number of groups(records in scan)
    freq      :   fltarr(8),$;topocentric freqMhz center each subband
    julday    :         0.D,$; julian day start of scan
    srcname   :         ' ',$;source name (max 12 long)
    procname  :         ' ',$;procedure name used.
    stepName  :         ' ',$;name of step in procedure this scan
    projId    :         '' ,$; from the filename
    patId     :         0L ,$; groups scans beloging to a known pattern

   secsPerrec :         0. ,$; seconds integration per record
    channels  :   intarr(8),$; number output channels each sbc
    bw        :   fltarr(8),$; bandwidth used Mhz
    backendmode:  strarr(8),$; lag config each sbc
    lag0      :  fltarr(2,8),$; lag 0 power ratio (scan average)
    blanking  :         0B  ,$; 0 or 1

    azavg     :         0. ,$; actual encoder azimuth average of scan
    zaavg     :         0. ,$; actual encoder za      average of scan
    encTmSt   :         0. , $; secs Midnite ast when encoders read
;                               start of scan

    raHrReq   :         0.D,$; requested ra ,  start of scan  J2000
    decDReq   :         0.D,$; requested dec,  start of scan J2000.

;                       Delta end-start real angle for requested position
    raDelta   :         0. ,$; delta ra last-first recs. Amins real angle
   decDelta   :         0. ,$; delta dec (last-frist)Arcminutes real  angle

    pntErrAsec :         0. ,$; avg great circle pnt error


;     alfa related

     alfaAngle:         0.  , $; alfa rotation angle used in deg
     alfaCen :          0B  $; alfa pixel that is centered on ra/dec position
    }

   You can use the slAr and slFileAr to then access the actual data files
without having to search through the file.

EXAMPLES
   The following examples will read the scanlist array for all the data
beteen sep04 and dec04. The examples will then select different pieces
of information that are in this scanlist array.  The final step will
extract some of the actual datascans.

;get tbl for all data for sep04->oct04.

 nscans=arch_gettbl(20040901,20041201,slAr,slFileAr)

; work with this scanlist dataset..
; make a list of the unique source names

  srcnames=slar[uniq(slar.srcname,sort(slar.srcname))].srcname
  print,srcnames
;
; find all of the on/off position switch data for cband (rcv=9)
;; not yet... n=corfindpat(slar,indar,pattype=1,rcv=9)
; find source NGC2264
  indar=where(slar.srcname eq 'NGC2264',count)

 now extract the scan averaged data. It will extract all data scans
that match the dataformat of the first entry of indar[0] (see arch_getdata().

  n=arch_getdata(slar,slfilear,indar,b,type=3,/han,incompat=incompat)

SEE ALSO:getsl, arch_getdata,corfindpat. 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/arch_gettbl.pro)</STRONG><P>
<HR>
 
<A NAME="ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.">
<H2>ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.</H2></A>
<A HREF="#ARCH_GETTBL - INPUT TABLE OF SCANS FROM COR ARCHIVE
">[Previous Routine]</A>
<A HREF="#A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
arch_summary - print summary info of arhive list.

SYNTAX: arch_summary,slar,logfile=logfile,append=append

ARGS:
   slar[n]: {wassl}   slar input from arch_gettbl
  
KEYWORDS:
	logfile: string	  file name to write the data. If append keyword is
					  set the append to file rather than overwriting.

DESCRIPTION:
   Output a 1 line summary for every scan in the slar. If logfile is
supplied then output to this file. The file will be overwritten unless
the append keyword is set.
proj    scan      srcname      procNm    step  rcv recs    ra    dec
a1946xsssssssssxllllllllllllxppppppppppxsssssssxrrxnnnnxhh:mm:ssxdd:mm:ss
12345 123456789 123456789012 1234567890 1234567 12 1234 12345678 12345678
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/arch_summary.pro)</STRONG><P>
<HR>
 
<A NAME="A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.">
<H2>A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.</H2></A>
<A HREF="#ARCH_SUMMARY - PRINT SUMMARY INFO OF ARHIVE LIST.
">[Previous Routine]</A>
<A HREF="#CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
a_was2examples - Accessing was (wapp) fits files.

   The wapp run in spectral line mode creates fits files. This is a 
different file format than the one used by the interim correlator. 
A set of routines has been written to access the fits files and map 
them into the same data structure as the interim correlator.
After this mapping, the normal corget,corplot,corxxx routines can be
used to process the data. 

   There are a few routines that are unique to this data format. They
begin with wasxxx: Wideband Arecibo Spectrometer (the prefix wapp was
already in use for the wapp pulsar data). These routines that 
users should access are:
 wasopen()  - open a file
 wasclose() - close a file
 waslist()  - list a scan summary of file
 washdr()   - return the fits headers (only works on most recent
              fits header version).

   Some corxxx routines have been rewritten to process the was data. 
These are documented here at corxxx(). I have tried to make the
functionality the same. If in doubt, read the documentation here to
see if there is anything different from the interrim correlator verion.

   This documentation is for the verion that writes all of the 
wapp data into a single datafile.

Running idl:
   To process the was datasets:

   idl
   @phil     (or whatever you need to add your base directory) 
   @wasinit2  ..initialize for was data. This calls @corinit and then 
               adds the ./was2 directory path in front of the ./Cor2
               directory path. Any corxxx() files in ./was2 will override
               the files with the same name in ./Cor2.
 -----------------------------------------------------
NOTE: These routines use the goddard binary fits table routines to
      access the file. At AO they are in the directory:
      /pkg/rsi/idl/lib/locallib/astron/pro/fits_bintable. If you download
      the AO idl routines, you will also need to get a copy of the 
      goddard routines and add the fits_bintable directory to the path.
 -----------------------------------------------------
 


; open the file
;
   file='/share/pserverf.sda3/wappdata/wapp.20040118.a1849.0010.fits'
   istat=wasopen(file,desc)
;
;  list contents of the file
;
   waslist,desc
;
;  read a recod
;
   istat=corget(desc,b)
;  there is a new corplot keyword: sbc=123 that would plot
;  sbc 1,2, and 3. This serves the same functionality as the m=
;  keyword but it is easier to use.

   corplot,b

;
;  read a scan
;
   istat=corinpscan(desc,b,scan=401867463L,maxrec=600)

; position to a scan in the file   
;
   istat=posscan(desc,401868066)
;
;  process on,off position switched data.
;
   istat=corposonoff(desc,b,scan=scan,/han)
;
;  read 1 or more raw fits headers into a structure
;  it reads by rows so you need to ask for numberOfRec*rowsPerRecs
;  to get all the data in a scan.
;  eg the the scan has 600 recs but we read 600*2*4  headers
;  since there are 2 IFs per sbc and 4 sbc per measuremetns

   istat=washdr(desc,h,scan=401864155L,numhdr=600*8)

;
; close the file when done. After calling this you must reopen
;       the file with wasopen() to access it.
;
   wasclose,desc

  SOME NOTES (20aug04) ;

1. All wapp data is now in a single file
2. Things that i have used and i thing work:
    corget,corinpscan,corplot,corgetm, corimgdisp() works
3. Some things that are not yet ready:
   The velocities may still need some work
   cormapping does not yet work. We need to add the mapping parameters
           to the fits header.
4. Some header values are not moved from the fits file to the 
   old interim correlator data structure. If a corxxx routine 
   fails it may be because the header info is not yet there.
6. Let me know things that you find that don't work (phil@naic.edu). 
    You can also look at http://www.naic.edu/~phil
    --> software documenation
      --> Using single dish fits header for wapp spectral line data..
   toward the bottom of this page is a list of the current things
   we are working on in the header.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/a_was2examples.pro)</STRONG><P>
<HR>
 
<A NAME="CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.">
<H2>CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.</H2></A>
<A HREF="#A_WAS2EXAMPLES - ACCESSING WAS (WAPP) FITS FILES.
">[Previous Routine]</A>
<A HREF="#CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
coracftospcpol - convert acf to spectra for polarization data.

SYNTAX: istat=coracftospcpol(acf,spc)

ARGS:
   acf[m]: {corget}    array of corget structures hold acf data (from the
                       wapps).
RETURNS:
   spc[m]: {corget}    array of corget structures holding computed
                       specra.

DESCRIPTION:
   
   Convert acfs to spectra for polarization data taken on the wapps.
You can pass in a single or an array of corget records.

The processing is:
1. The wapp data has already had the bias removed and it has been
   normalized to the number of multiplies.
2. Do the 3 level correction  (this does not yet work for 9 level data).
   Use the routine cor3lvlstokes in the gen/ directory.
3. compute the spectra for the auto correlations and the cross correlation.
4. compute spc[].ibrd.d[*,0]= I  = (polA + polB)/ (pwrA+pwrB)
           spc[].ibrd.d[*,1]= Q  = (polA - polB)/ (pwrA+pwrB)
           spc[].ibrd.d[*,2]= U  = real(ccfSpectra)/sqrt(pwrA*pwrB)
           spc[].ibrd.d[*,3]= V  = -img(ccfSpectra)/sqrt(pwrA*pwrB)
  where ibrd is b1,b2,b3, or b4.
          
   The spectra are normalized to the total power (I). To convert back to
power units use the lag0pwrratios[2] in the header

    spc.[].ibrd.h.cor.lag0pwrratio[2]  [0] is polA power, [1] is polB
 power in units of Optimum/Measured power.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/coracftospcpol.pro)</STRONG><P>
<HR>
 
<A NAME="CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.">
<H2>CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.</H2></A>
<A HREF="#CORACFTOSPCPOL - CONVERT ACF TO SPECTRA FOR POLARIZATION DATA.
">[Previous Routine]</A>
<A HREF="#CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhcalrec- check if an input rec is a cal rec.
SYNTAX:    istat=corhcalrec(hdr)
ARGS  :    hdr - header from 1 of the boards
RETURNS:  istat- 0 not a cal rec, 1-on, 2-off
DESCRIPTION:
   Check if a record input is part of a cal record.
EXAMPLE:
   corget(lun,b)
   istat=corhcalrec(b.b1.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.">
<H2>CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.</H2></A>
<A HREF="#CORHCALREC- CHECK IF AN INPUT REC IS A CAL REC.
">[Previous Routine]</A>
<A HREF="#CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhcalval - return the pol A/B  cal values for a sbc.

SYNTAX: stat=corhcalval(hdr,calval,date=date,swappol=swappol)

ARGS:
     hdr: {hdr}    header for board to check

KEYWORDS:
 date[2]: intarray [year,dayNum] if provided, then compute the calvalues
                      that were valid at this epoch.
 swappol:          if set then swap the pola,polb cal values. This can
					be used to correct for the 1320 hipass cable switch
					problem or the use of a xfer switch in the iflo.

RETURNS:
 calval[2]: float .. calValues in deg K for polA,polB
      stat: int   .. -1 error, 0 got the values ok.

DESCRIPTION:
   Return the cal values in degrees K for the requested sbc. This 
routine always returns 2 values (polA then polB) even if the header
is for a board that uses only one polarization.
   The calvalues for the receiver in use are looked up and then the
values are interpolated to the observing frequency.

EXAMPLE:
   input a correlator record and then get the calvalues for the 
   3rd correlator board:
   print,corget(lun,b)
   istat=corhcalval(b.b3.h,calval)
   .. calval[2] now has the cal values in degrees K for polA and polB.

NOTE:
   Some cals have measurements at a limited range of frequencies (in some
cases only 1 frequency). If the frequency is outside the range of measured
frequencies, then the closest measured calvalue is used (there is no 
extrapolation).
   The year daynum from the header is used to determine which set of
calvalue measurements to use (if the receiver has multiple timestamped
sets).

   This routine computes the frequency of the sbc from hdr and then calls
calget(). 

SEE ALSO:
gen/calget gen/calval.pro, gen/calinpdata.pro
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.">
<H2>CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.</H2></A>
<A HREF="#CORHCALVAL - RETURN THE POL A/B  CAL VALUES FOR A SBC.
">[Previous Routine]</A>
<A HREF="#CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhcfrrest - return the rest freq of band center.
SYNTAX: cfr=corhcfrrest(hdr)
ARGS:
    hdr: {hdr}  .. header for board to check
RETURNS:
    cfr: double .. rest center freq of band in Mhz
DESCRIPTION:
   Return the rf rest frequency for the band center of the requested board.
EXAMPLE:
   get the rest freq of the 3nd board: cfrMhz=corhcfrrest(b.b3.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.">
<H2>CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.</H2></A>
<A HREF="#CORHCFRREST - RETURN THE REST FREQ OF BAND CENTER.
">[Previous Routine]</A>
<A HREF="#CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhcfrtop - return the topocentric freq of band center.
SYNTAX: cfr=corhcfrtop(hdr)
ARGS:
    hdr: {hdr}  .. header for board to check
RETURNS:
    cfr: double .. center freq of band in Mhz
DESCRIPTION:
   Return the topocentric rf center of the band for the requested board.
hdr can be an array of hdrs but they must all come from the same
board. eg b[].b1.h

EXAMPLE:
   get the freq of the 2nd board: cfrMhz=corhcfrtop(b.b2.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE">
<H2>CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE</H2></A>
<A HREF="#CORHCFRTOP - RETURN THE TOPOCENTRIC FREQ OF BAND CENTER.
">[Previous Routine]</A>
<A HREF="#CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhdnyquist - check if rec taken in double nyquist mode
SYNTAX:    istat=corhdnyquist(hdr)
ARGS  :    hdr{} - header from 1 of the boards of the record
RETURNS:  istat- 0 not taken in double nyquist mode. 
                 1 taken in double nyquist mode. 
DESCRIPTION:
   Check if a record was taken in double nyquist mode.
EXAMPLE:
   corget(lun,b)
   istat=corhdnyquist(b.b1.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.">
<H2>CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.</H2></A>
<A HREF="#CORHDNYQUIST - CHECK IF REC TAKEN IN DOUBLE NYQUIST MODE
">[Previous Routine]</A>
<A HREF="#CORHGAINGET - RETURN THE GAIN GIVEN A HEADER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhflipped - check if current data is flipped in freq.
SYNTAX: stat=corhflipped(corhdr)
ARGS:
   corhdr[]: {corhdr} to check.
RETURNS:   istat- 0 increasing frq, 1- decreasing freq order.
             if corhdr[] is an array then istat will be an array of ints.
DESCRIPTION:
   Check if the correlator data for this sbc is stored in increasing
or decreasing frequency order (even or odd number of high side lo's).
EXAMPLE:
   check first board: istat=corhflipped(b.b1.h.cor)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHGAINGET - RETURN THE GAIN GIVEN A HEADER">
<H2>CORHGAINGET - RETURN THE GAIN GIVEN A HEADER</H2></A>
<A HREF="#CORHFLIPPED - CHECK IF CURRENT DATA IS FLIPPED IN FREQ.
">[Previous Routine]</A>
<A HREF="#CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhgainget - return the gain given a header

SYNTAX: stat=corhgainget(hdr,gainval,date=date,az=az,za=za,onlyza=onlyza)

ARGS:
  hdr[n]: {hdr}    header for board to check

KEYWORDS:
 date[2]: intarray [year,dayNum] if provided, then compute the gain value
                   at this epoch.
   az[n]: fltarray If provided, use this for the azimuth value rather than
                   the header values
   za[n]: fltarray If provided, use this for the zenith angle values rather
                   than the header values
  onlyza:          If set then return the za dependence (average of az)
RETURNS:
 gainval: float .. gainvalue in K/Jy
    stat: int   -1 --> error, no data returned
                 0 --> requested freq is outside freq range of fits.
                       Return gain of the closed frequency.
                 1 --> frequency interpolated gain value returned.
DESCRIPTION:
   Return the telescope gain value in K/Jy for the requested sbc. 
The gain fits for the receiver in use are input and then the
values are interpolated to the az, za and observing frequency.
   If hdr[] is an array then the following restrictions are:
   1. each element must be from the same receiver and at the same 
      frequency (eg. all the records from a single scan).
   2. If the az,za keywords are provided, they must be dimensioned the same
      as hdr

EXAMPLE:
   input a correlator record and then get the gain value for the 
   3rd correlator board:
   print,corget(lun,b)
   istat=corhgainget(b.b3.h,gain)
   .. gain now has the gain value in K/Jy
   
   input an entire scan and compute the gain for all
   records of 1 sbc. assume 300 records..
   print,corinpscan(lun,bar)
   istat=corhgainget(bar.b3.h,gain)
   gain is now a array of 300 records

NOTE:
   Some receivers have measurements at a limited range of frequencies (in some
cases only 1 frequency). If the frequency is outside the range of measured
frequencies, then the closest measured gain is used (there is no 
extrapolation in frequency).
   The year daynum from the header is used to determine which set of
gain fits to use (if the receiver has multiple timestamped sets).
   This routine takes the az,za, date, and frequency from the
header and then calls gainget().
   If you input an array of corget recs , then they must all be from the
same sbc.

SEE ALSO:
gen/gainget gen/gaininpdata.pro
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE">
<H2>CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE</H2></A>
<A HREF="#CORHGAINGET - RETURN THE GAIN GIVEN A HEADER">[Previous Routine]</A>
<A HREF="#CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corhstokes - check if record taken in stokes mode
SYNTAX:    istat=corhstokes(hdr)
ARGS  :    hdr{} - header from 1 of the boards of the record
RETURNS:  istat- 0 not taken in stokes mode. 1-->taken in stokes mode
DESCRIPTION:
   Check if a record was taken stokes (polarization) mode.
EXAMPLE:
   corget(lun,b)
   istat=corhstokes(b.b1.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corhquery.pro)</STRONG><P>
<HR>
 
<A NAME="CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE">
<H2>CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE</H2></A>
<A HREF="#CORHSTOKES - CHECK IF RECORD TAKEN IN STOKES MODE
">[Previous Routine]</A>
<A HREF="#CORPLOT - PLOT THE CORRELATOR DATA.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corimgdisp - display a set of correlator records as an image
SYNTAX: img=corimgdisp(b,clip=clip,sbc=sbc,brdlist=brdlist,pol=pol,col=col,$
                   median=median,bpc=bpc,ravg=ravg,nobpc=nobpc,$
                   win=win,wxlen=wxlen,wylen=wylen,wxpos=wxpos,wypos=wypos,$
                   zx=zx,zy=zy,$
                   scan=scan,lun=lun,han=han,maxrecs=maxrecs,mytitle=mytitle,$
                   hlind=hlind,hlval=hlval,hldash=hldash,hlvlines=hlvlines,$
                   useind=useind,ln=ln,chn=chn)
ARGS:
   b[nrecs]: {corget} correlator data to make image of 
RETURNS:
   img[nchns,nrecs]: float image of last sbc displayed (before clipping).

KEYWORDS:
                  
     clip[]: float  value to clip the normalized data to. Default is
                    .02 (of Tsys). If clip has 1 value then 
                    normalize to (img > (-clip)) < clip. If two value are
                    provided, then they will the [min,max].
        sbc: int 1-4. sub correlator to plot. default is all 4.
    brdlist: long   A single number whose decimal digits specify the boards
					 to display. eg brds 1,2,3,4 would be: brdlist=1234
					 The boards are numbered 1 thru 8.
        pol: int 1,2  polarization to plot. default is 1:polA
        win: int window number to plot in. default is 1.
      wxlen: int xlen of window. default 700
      wylen: int ylen of window. default 870
      wxpos: int xpos of lower left edge of window.default 445
      wypos: int ypos of lower left edge of window.default:35
         zx: int ..-3,-2,2,3,4 zoom factor x dimension. Negative numbers 
                   shrink the image positive numbers expand. Negative number 
                   must divide evenly into the number of channels.
         zy: int ..-3,-2,2,3,4 zoom factor y dimension (same format as zx)
     col[2]: int .. x columns to use to flatten the image in the time
                    direction. count 0..numberoflags-1. If multiple sbc 
                    plotted then the same cols are used for all sbc. The
                    default is no flattening in the time direction.
        chn:        if set then plot vs channel number rather than freq
        bpc:{corget} if supplied then this data will be used to do the
                    bandpass correction. The default is to average over
                    all of the nrecs.
      nobpc:        if set then no bandpass correction is done.
     median:        if set and bpc not provided, then bandpass correct using
                    the median of the nrecs rather than the average.
       ravg: long   bandpass correct with a running average of ravg spectra
     scan  : long   if provided,then routine will input scans data into
                    b[] before making image. In this case you must also
                    supply the lun keyword to tell the routine where to
                    read from.
       lun : int    if scan keyword provided, then you must also supply
                    this keyword. It should contain the lun for the 
                    corfile that you have previously opened.
       sl[]:{scanlist} This array can be used for direct access when the
                     scan keyword is used. The sl[] (scanlist) array is
                     returned from the sl=getsl(lun) routine. The routine
                     scans the entire file recording where the scans start.
       han:          if set and scan keyword set, then hanning smooth the
                     data on input.
   maxrecs: int      if lun used then the max records of a scan to input.
                     default:300
   mytitle:string    user supplied tittle instead of scan,srcname,az,za
                     az,za at top of the plot.
   hlind[]: ind      index into img array (2nd dimension) to draw
                     horizontal lines.
   hlval  : float    value to use for horizontal lines (in img units)
                     default is clip value.
   hldash : int      The dash lengths to used for the horizontal lines.
                     2*ldash must divide into x dimension.default is 4
   hlvlines:int      Number of engths to used for the horizontal lines.
                     default=1
   useind[2]:int     if provided then use these indices from data array
                     0 .. lengthsbc -1
                     default=1
   ln       :int     linenumber for title..0..33 def:3
   extra_=e          this allows you to input keywords that will be
                     passed to the plotting routine. eg title=title..
  
DESCRIPTION:
   Corimgdisp will display a set of correlator records (usually a scans
worth) as an image. By default it will make a separate image for each
subcorrelator (board). The sbc keyword lets you choose just 1 sbc to image.
The data for the image is taken from polA  by default. Use the pol keyword 
to make the image from the other polarization.
   You can input the data outside of this routine (eg with corinpscan) or 
use the scan,lun keywords to have corimgdisp input the data directly. 

   By default, the image is bandpass normalized by the average of all the
records (sbc/avg(sbc) - 1). If the median keyword is used then
 avg(sbc) is replaced by median(sbc). The bpc keyword allows you to input
a separate correlator record to use as the normalization.
   The col keyword lets you also flatten the image in the time (record)
dimension by specifying the first/last columns to average and then divide 
into all of the other columns (the columns are counted from 0). By default
this is not done.

   After bandpass correction and flattening in the record dimension, the
image is clipped (by default) to +/- .02 (tsys) and then scaled
from 0 to 256 for the image display. The clip  keyword lets you change the
clipping value.

   The zx,zy keywords let you scale the image in the x and y dimensions by
integral amounts. Negative numbers will shrink it by that amount (Note:
the negative numbers must divide evenly into the number of channels in
each sbc). -1,0,1 do no scaling. This scaling is only applied for the single
sbc displays. The multiple sbc displays are always scaled to fit 
inside the window (700 by 870 pixels).

   The scan keyword can be used to input the data directly from a file.
In this case the scannumber is the scan keyword value and the lun keyword
should be set the the logical unit number of the already open file. The
sl keyword can be used to do direct access to the file. It's argument
comes from a call to sl=getsl(lun) prior to calling this routine.

   After displaying the image, use xloadct to manipulate the color table.

   The routine returns the last image displayed (before clipping).

EXAMPLES:
   input a scans worth of data.
   print,corinpscan(lun,b,/han)    .. input scan with hanning smoothing
1. display the image of all 4 sbc.
   img=corimgdisp(b)
2. display only sbc 2, scale y by 2, and x by -2
   img=corimgdisp(b,sbc=1,zx=-2,zy=2)
3. display all 4, clip to .015 Tsys , display polB and median filter the
   bandpass correction:
   img=corimgdisp(b,pol=2,/median)
4. assume scan 12730084 in an on position and 12730085 is the off position.
   Suppose you want to display the on image normalized by the off.
   scan=12730084L
   print,corinpscan(lun,bon,scan=scan,/han)
   print,corinpscan(lun,boff,scan=scan+1,/han)
   bpc=coravgint(boff)             ; compute the average of the off.
   img=corimgdisp(bon,bpc=bpc)
5. Have the routine input and plot a scans worth of data:
   openr,lun,'/share/olcor/corfile.27sep01.x101.1',/get_lun
   scan=12730084L
   img=corimgscan(b,lun=lun,scan=scan)
6. Have the routine input and plot a scans worth of data, use the sl
   keyword for direct access.
   openr,lun,'/share/olcor/corfile.27sep01.x101.1',/get_lun
   sl=getsl(lun)
   scan=12730084L
   img=corimgscan(b,lun=lun,scan=scan,sl=sl)

This routine calls imgflat, and imgdisp for the image scaling and display.
SEE ALSO:
   imgdisp,imgflat
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corimgdisp.pro)</STRONG><P>
<HR>
 
<A NAME="CORPLOT - PLOT THE CORRELATOR DATA.">
<H2>CORPLOT - PLOT THE CORRELATOR DATA.</H2></A>
<A HREF="#CORIMGDISP - DISPLAY A SET OF CORRELATOR RECORDS AS AN IMAGE
">[Previous Routine]</A>
<A HREF="#GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corplot - plot the correlator data.
SYNTAX : corplot,b,m=pltmsk,vel=vel,rest=rest,off=ploff,pol=pol,over=over,$
                   nolab=nolab,extitle=extitle,newtitle=newtitle,col=col, $
                   sym=sym,chn=chn,cmask=cmask,xtitle=xtitle,ytitle=ytitle,$
				    brd=brdlist
ARGS:
       b:  {corget} data to plot
KEYWORDS:
           m: int bitmask 0-15 to say which boards to plot
         brd: int number containing the boards to plot Use this instead of
				   m=. eg boards 1,3,5,7 is brd=1357
         vel:  if set, then plot versus velocity
        rest:  if set, then plot versus rest frequency
         off:  float, if plotting multiple integrations then this is the
               offset to add between each plot of a single sbc. def 0.
         pol:  int if set, then plot only one of the pol(1,2 ..3,4 for stokes) 
        over:  if set then overplot with whatever was previously plotted.
               This only works if you plot 1 sbc at a time (eg m=1).
       nolab:  if set then don't plot the power level labels in the middle
               of the plot for stokes data.
       extitle: string add to title line
       newtitle: string replace title line
       xtitle  : string title for x axis
       ytitle  : string title for y axis
       col[4]  : int Change the order of the default colors. The 
                 order is PolA,polB,stokesU,stokesV colors.
                 values are:1=white(on black),2-red,3=green,4=blue,5=yellow
       sym     : int symbol to plot at each point. The symbols are labeled
                 1 to 9. Positive numbers only plot the symbol (no connecting
                 lines). Negative numbers (-1 to -9) plots the symbol and a 
                 connecting line. sym=10 will plot in histogram mode.
       chn     : if set then plot vs channel
       cmask    :{cmask} if provided then overplot the mask on each plot
DESCRIPTION:
   corplot will plot the correlator data in b. It can be from a single
record (corget) or it can be an array from corinpscan. You can plot:
 - any combination of sbc using m=pltmsk and pol=pol
 - by topocentric frequency (defaul), rest frequency, or by velocity
 - make a strip plot if b is an array by using off=ploff.
   If the data passed in has been accumulated by coraccum() then the
average will be computed before plotting.
EXAMPLES:
   corget,lun,b
   corplot,b           plot all sbc
   corplot,b,m=1       plot first sbc only
   corplot,b,m=2       plot 2nd sbc
   corplot,b,m=4,pol=2 plot 3rd sbc,polB only
   corplot,b,m=8,pol=1 plot 4th sbc, pola only
   corplot,b,m=5,/vel  plot 1st and 3rd sbc by velocity
   istat=corinpscan(lun,b) .. input entire scan
   corplot,b,m=1,pol=1 plot sbc 1, pola, overplotting
   corplot,b,m=2,off=.01  plot sbc 2, with .01 between records
.. overplot sbc 1 from b[0] (red) and b[1] yellow
   corplot,b[0],m=1
   corplot,b[1],m=1,/over,col=[5,5]
NOTE: 
   use hor,ver to set the plotting scale.
   oveplotting only works if you display 1 sbc at a time.
SEE ALSO:
   corget,coraccum. hor,ver in the generic idl routines.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/corplot.pro)</STRONG><P>
<HR>
 
<A NAME="GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.">
<H2>GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.</H2></A>
<A HREF="#CORPLOT - PLOT THE CORRELATOR DATA.">[Previous Routine]</A>
<A HREF="#SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
getsl  - scan a wapp fits file  and return the scan list.
SYNTAX: sl=getsl(desc)
ARGS:
       desc:   {} assigned to open file
                   default: 5000L
RETURNS:
      sl[nscans]:{sl} holds scan list info
DESCRIPTION
   This routine reads a wapp fits file and returns an array of scanlist
structures.
This array contains summary information for each scan of the file:

   sl.scan       - long   scan number for this scan
   sl.bytepos    - unsigned long for start of this scan
					       for fits data this is the starting row of the
					       scan in the file, not the byte offset.
   sl.stat       - .. not used yet..
   sl.rcvnum     - byte receiver number 1-16
			        note: ch is rcvnum 100
   sl.numfrq     - byte  .. number of freq,cor boards used this scan
   sl.rectype    - byte 1 -calon
                        2 -caloff
                        3 -onoff on  pos
                        4 -onoff off pos
                        5 -coron (stdon) (track just on position)
                        6 -cormap1 (radecmap)
                        7 -cormapdec (decramap)
                        8 -cordrift  (driftmap)
                        9 -corcrossch (spidera0 thru a7)
                       10 -x111auto (rfi monitoring)
                       11 -one      murrays on with calon/off at the null
                       12 -onoffbml murrays on, off and cal at null
					    20 -spidera0
					    21 -spidera1
					    22 -spidera2
					    23 -spidera3
					    24 -spidera4
					    25 -spidera5
					    26 -spidera6
					    25 -wappcrossmap
					    26 -wapphexmap  
					    27 -altdriftmap 
					    28 -fixedazdrift
					    29 -basketweave
					    30 -CROSSA0
					    31 -CROSSA1
					    32 -CROSSA2
					    33 -CROSSA3
					    34 -CROSSA4
					    35 -CROSSA5
					    36 -CROSSA6
                       
   sl.numrecs    - long  .. number of groups(records in scan)
   sl.freq[4] float- topocentric frequency center each subband
   sl.julday  double- julian date start of scan
   sl.srcname  string  - source name (max 12 long)
   sl.procname string  - procedure name used.

   Some routines can use the sl structure to perform random access to
files (bypassing the need to search for a scan). The sl[] array can
also be used with the where() command to rapidly extract subsets of a
file.

EXAMPLE:
   openr,lun,'/share/olcor/corfile.02nov00.x101.1',/get_lun
   sl=getsl(lun)
   1. process all of the lband wide data in a file:
       ind=where(sl.rcvnum eq 5,count)
       for i=0,n_elements(ind)-1
           print,corinpscan(lun,b,scan=sl[ind[i]].scan,sl=sl)
           .. process
       endfor
   2. Find all of the on/off patterns in a file. Make sure that the
      number of records in the on equals the number in the off.
      indon=where(sl.rectype eq 3 ,count)
      if count le 0 then goto,nopairs
;   make sure an off follows the on and has the same number of records..
;   (actually this will fail if the last rec of the file is an on since
;   indon+1 will go beyond the end of the sl array..)
      ind=  where((sl[indon+1].rectype eq 4) and $
            (sl[indon].numrecs eq sl[indon+1].numrecs),count)
      if count le 0 then goto,nopairs
      indon=indon[ind]
   3. plot all of the cal on/off records in a file with cormon().
       ind=where(sl.rectype le 2)
       cormon,lun,sl=sl[ind]

Note this will not work with files > 2gigabytes since it is
using a 32 bit integer.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/getsl.pro)</STRONG><P>
<HR>
 
<A NAME="SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE">
<H2>SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE</H2></A>
<A HREF="#GETSL  - SCAN A WAPP FITS FILE  AND RETURN THE SCAN LIST.
">[Previous Routine]</A>
<A HREF="#WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
sl_mkarchive - create scan list for archive

SYNTAX: nscans=sl_mkarchive(listfile,slAr,slFileAr,logfile=logfile,$
							 verbose=verbose)

ARGS:
   listfile: string. filename holding names of files to scan
                     (one per line). semi-colon as the first char is a comment.
RETURNS:
   slAr[nscans] {sl}    One large scanlist array for all the files
   slfileAr[m]: {slInd} One entry per file showing where each file starts/
                        stops in slAr.
   nscans     : long  number of scans found

KEYWORDS:
   verbose:    If set then print each file as we process it.
   logfile: string   name of file to write progress messages. by default 
               messages only go to stdout.


DESCRIPTION:
   sl_mkarchive is given a list of spectral line fits files. It scans 
each of these files and extracts information to put into an archive record.
There is on archive record per scan. This information is then stored
on disc in an idl save file format (usually by month). The routine
arch_gettbl() can then be used to read this information in and process it.

   The archive record consists of:
  scan      :         0L, $; scannumber this entry
    rowStart  :         0L, $; row in fits file start of scan 0 based.
    fileindex :         0L, $; lets you point to a filename array
    stat      :         0B ,$; not used yet..
    rcvnum    :         0B ,$; receiver number 1-16, 17=alfa
    numfrq    :         0B ,$; number of freq,cor boards used this scan
    rectype   :         0B ,$;1-calon,2-caloff,3-posOn,4-posOff
    numrecs   :         0L ,$; number of groups(records in scan)
    freq      :   fltarr(8),$;topocentric freqMhz center each subband
    julday    :         0.D,$; julian day start of scan
    srcname   :         ' ',$;source name (max 12 long)
    procname  :         ' ',$;procedure name used.
    stepName  :         ' ',$;name of step in procedure this scan
    projId    :         '' ,$; from the filename
    patId     :         0L ,$; groups scans beloging to a known pattern

   secsPerrec :         0. ,$; seconds integration per record
    channels  :   intarr(8),$; number output channels each sbc
    bw        :   fltarr(8),$; bandwidth used Mhz
    backendmode:  strarr(8),$; lag config each sbc
    lag0      :  fltarr(2,8),$; lag 0 power ratio (scan average)
    blanking  :         0B  ,$; 0 or 1

    azavg     :         0. ,$; actual encoder azimuth average of scan
    zaavg     :         0. ,$; actual encoder za      average of scan
    encTmSt   :         0. , $; secs Midnite ast when encoders read
;                               start of scan

    raHrReq   :         0.D,$; requested ra ,  start of scan  J2000
    decDReq   :         0.D,$; requested dec,  start of scan J2000.

;                       Delta end-start real angle for requested position
    raDelta   :         0. ,$; delta ra last-first recs. Amins real angle
   decDelta   :         0. ,$; delta dec (last-frist)Arcminutes real  angle

    pntErrAsec :         0. ,$; avg great circle pnt error


;     alfa related

     alfaAngle:         0.  , $; alfa rotation angle used in deg
     alfaCen :          0B  $; alfa pixel that is centered on ra/dec position


   The routine sl_mkarchive is run monthly and the info is stored in 
files by month. This routine can then be run to create the slar data
for the was

EXAMPLE:

   The monthly processing would look like:
;
;1. create listfile from corflist.sc 010101 010131 excl.dat outside of idl.
;2. make the slAr, slFileAr and save it

nscans=sl_mkarchive(listfile,slAr,slfilear)
save,sl,slar,file='/share/megs/phil/x101/archive/was/f010101_010131.sav'
;

SEE ALSO:sl_mkarchive,arch_gettbl,arch_getdata
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/sl_mkarchive.pro)</STRONG><P>
<HR>
 
<A NAME="WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA">
<H2>WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA</H2></A>
<A HREF="#SL_MKARCHIVE - CREATE SCAN LIST FOR ARCHIVE">[Previous Routine]</A>
<A HREF="#WASALFAPLOTCROSS - PLOT ALFA CROSS DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
 wasalfacmpradec - compute ra/dec for alfa using wasdata

SYNTAX: wasalfacmpradec,b,raHr,decDeg
  ARGS:
   b[n] {wasget} - data as returned from corget(). It is ok to use the 
                   /hdronly keyword to corget() to speed up i/o.

 RETURNS:  
   rahr[7,n]: double ra in hours for the n samples. The first dimension
                     has the 7 beams 0 thru 6
 decDeg[7,n]: double declination in degrees for the n sampled points. 
                     The first dimension has the 7 beams 0 thru 6
DESCRIPTION:
   Compute the ra,dec J2000 for the alfa beams using the data structures
read from the fits files via corget, corinpscan,corgetm etc.. To
compute the ra/dec the routine does the following:

1. Grab the encoder az,za, and encoder timestamps.
2. Get the daynumber, year from the scan number
3. compute the julian day timestamp for the az,za timestamps.
4. search thru each scan looking for midnite crossings. If there is
   a midnite crossing (ast) then increment the jd for this stretch.
5. For each scan do the following:
 a. Get the julian dates for the data samples from the header
   location mjd_obs (converting to jd). Increment these values
   by (recIntegrationSecs*.5)/86400D to get the time stamps at the center 
   of each integration.
 b. interpolate the az,za values sampled at encoder time to the 
    az za at the data sample time.
 c. call alfabmpos,az,za,juldayData to get the ra,dec for the alfa
   beams for the data positions/times.
   return these values as the  ra,dec of the beam positions.

   The data is returned as:
 rahr[7,n]
 decDeg[7,n]
   Where the first index runs over the 7 pixels of alfa. The second index is
for the data samples.

   It  is ok if the b[] array contains more than one scan. The routine
searchs for the start of each scan in the b[] array. It is also ok
to pass in a b[] array that contains only the headers (see corget(),
corinpscan(), arch_getdata() /hdronly keyword). This can speed up the
i/o if you are only interested in the positions and not the spectra.

EXAMPLE:
 1. input a scan and compute the beam positions.

   print,corinpscan(desc,b)
   wasalfacmpradec,b,rahr,decdeg
 2.use arch_getalfaradec to input a set of scans
   yyyymmdd1=20040903
   yyyymmdd2=20040906
   projid='a1943'
   procname='basket'
   numrecs=60
   npnts=arch_getalfaradec(yyyymmdd1,yyyymmdd2,raHr,decDeg,projid=projid,$
              procname=procname,slar=slar,slfilear=slfilear,indar=indar,$
              /plotit,/verb,/gt12)
SEE ALSO
   alfabmpos (in pointing related idl routines).
   arch_getalfaradec() (in wapp spectral line routines).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasalfacmpradec.pro)</STRONG><P>
<HR>
 
<A NAME="WASALFAPLOTCROSS - PLOT ALFA CROSS DATA">
<H2>WASALFAPLOTCROSS - PLOT ALFA CROSS DATA</H2></A>
<A HREF="#WASALFACMPRADEC - COMPUTE RA/DEC FOR ALFA USING WASDATA
">[Previous Routine]</A>
<A HREF="#WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasalfaplotcross - plot alfa cross data
SYNTAX: alfaplotcross,(baz,bza,proj=proj,auto=auto,two=two)
ARGS:
 baz[60]   : {corget}   az strip data
 bza[60]   : {corget}   az strip data

KEYWORDS:
   proj    : string    projid.
   auto    :           if set then autoscale each plot
   two     :           if set then two cols by 4 rows..default ,1 by 8.
     cs    : float     charsize keyword for labels. def: 1.7

RETURNS:

DESCRIPTION:
   plot alfa cross total power by beam. There will a separate plot window
for each beam. A single beam will have 120 points (az,za points) for pol
a (black or white) and polB in Red.
   Dashed red lines will be plotted at the center of the azimuth and
za strips. A dashed green line will be plotted at at the start of the
za strip.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasalfaplotcross.pro)</STRONG><P>
<HR>
 
<A NAME="WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD">
<H2>WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD</H2></A>
<A HREF="#WASALFAPLOTCROSS - PLOT ALFA CROSS DATA">[Previous Routine]</A>
<A HREF="#WASCLOSE - CLOSE A WAS FILE FOR I/O">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasalignrec - align the row to the start of a record

SYNTAX: istat=wasalignrec(desc,aligndown=aligndown,scanInd=scanInd,$
                           recInd=recInd)

ARGS: 
   desc:{wasdesc} was descriptor returned from wasopen()

KEYWORDS: 
aligndown:  If the current pointer is in the middle of a 
            record, the routine will round up to the next record. If the
            aligndown keyword is set, then the routine will round down
            to the closest record.

RETURNS:
   istat: int   1 ok, 0 eof, -1 error.
 scanInd: long  index into desc.scanI[] for the current position (0 based)
 recInd:  long  the record number within the current scan (0 based)

DESCRIPTION:
   The fits data is stored in a fits binary table by row. There are
multiple rows for a single integration (rec). This routine will 
guarantee that the next read position will be positioned at the
start of a record.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasalignrec.pro)</STRONG><P>
<HR>
 
<A NAME="WASCLOSE - CLOSE A WAS FILE FOR I/O">
<H2>WASCLOSE - CLOSE A WAS FILE FOR I/O</H2></A>
<A HREF="#WASALIGNREC - ALIGN THE ROW TO THE START OF A RECORD
">[Previous Routine]</A>
<A HREF="#WASFTOCHDR - CONVERT FITS HDR TO COR HEADER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasclose - close a was file for i/o

SYNTAX: wasclose,desc 

ARGS:
   desc: {wasdescr} - descriptor to close (returned by wasopen)
KEYWORDS:
	 all:			   if set then close all open descriptors.

DESCRIPTION:
   Files opened with wasopen() need to be closed with wasclose() so that
the resources are freed up.

EXAMPLE:
   filename='/share/wapp11/wapp1.20040121.a1849.0004.fits'
   istat=wasopen(filename,desc)
   .. process the data in the file
   wasclose,desc   .. this closes the file when done with the processing.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasclose.pro)</STRONG><P>
<HR>
 
<A NAME="WASFTOCHDR - CONVERT FITS HDR TO COR HEADER">
<H2>WASFTOCHDR - CONVERT FITS HDR TO COR HEADER</H2></A>
<A HREF="#WASCLOSE - CLOSE A WAS FILE FOR I/O">[Previous Routine]</A>
<A HREF="#WASGET - READ A GROUP  OF WAS DATA RECORDS.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasftochdr - convert fits hdr to cor header

SYNTAX: istat=wasftochdr(desc,h,hf=hf,nrows=nrows,pol=pol,iscan=iscan)

ARGS: 
   desc:{wasdesc} was descriptor returned from wasopen()

RETURNS:
   istat: int  1 ok, 0 eof, -1 error.
    h: {corhdr}  correlator header
    hf:{washdr}  was hdr extension..
 nrows:   long   number of rows to advance desc.curpos if you
                 want to update the position.
pol[2,nbrds]:  long   codes the pol type polA=1, polB=2 for each 
                 spectra on each board.
iscan :   long   index into desc.scanI[] for this scans data.

DESCRIPTION:
   Read in fits header for the current group and convert it
to a correlator header. If the file is not positioned at
the start of a group, then move forward to the start of the
next group.

NOTE: this routine does not update the position in the file.
You are left pointing at the input position.

 current data being loaded into b1.h from fits header:
 tointerimHdr      from fitsHdr
 --------------------
 STD
h.std.grpTotRecs    desc.scanI.nbrds 
h.std.time          fits.crval5 convert to ast secs
h.std.scannumber    fits.SCAN_NUMBER
h.std.grpNum        desc.scanI.rowsInRec, curpos,
h.std.grpCurRec     1..nbrds .. used for dop offsets
h.std.azttd         fits.ENC_AZIMUTH
h.std.grttd         fits.ENC_ELEVATIO
h.std.chttd         fits.ENC_ALTEL
h.std.posTmMs       fits.ENC_TIME
h.std.grpTotRecs    desc.scanI.nbrds 
h.std.grpTotRecs    desc.scanI.nbrds 
 --------------------
 COR
h.cor.numbrdsused   desc.scanI.nbrds
h.cor.numSbcOut     desc.scanI.nsbc
h.cor.lagsbcout     desc.scanI.nlags
h.cor.boardId       desc.scanI.brdNum
h.cor.calon         desc.scanI.brdNum
h.cor.caloff        desc.scanI.brdNum
h.cor.lagconfig     fits.BACKENDMODE with translations..
h.cor.bwnum         fits.BANDWID  0=100 MHZ
h.cor.lag0pwrratio  fits.TOT_POWER 
h.cor.attndb        desc.scanI.corattn

h.cor.state.flipped fits.UPPERSB ..1 --> flipped
 --------------------
 IFLO
h.iflo.if1.st1.rfnum     fits.rfnum
h.iflo.if1.st1.ifnum     fits.ifnum
h.iflo.if1.st1.hybrdIn   fits.hybrid
h.iflo.if1.st1.lo1Hsd    ...
h.iflo.if1.st1.lbwLinPol fits.LBWHYB
h.iflo.if1.st1.syn1RfOn  ...
h.iflo.if1.st1.syn2RfOn  ...
h.iflo.if1.st1.lbFbA     ...
h.iflo.if1.st1.lbFbB     ...
h.iflo.if1.st1.useFiber  ...

h.iflo.if1.st2.calRcvMux ...
h.iflo.if1.st2.calType   fits.CALTYPE
h.iflo.if1.st2.ac1PwrSw  ...
h.iflo.if1.st2.ac2PwrSw  ...
h.iflo.if1.st2.zmNormal  ...
h.iflo.if1.st2.sbShClosed...
h.iflo.if1.st2.lo2Hsd    ...

h.iflo.if1.lo1           FITS.SYN1
  IF2
h.iflo.if2.synfreq       FITS.SYNFRQ
h.iflo.if2.st .ifInpFreq .. not in fits header
h.iflo.if2.st4.mixerCfrq .. FITS.MIXER 0,1,2,3 750,1250,1500,1750 MIXER CFR
 --------------------
 DOP
h.iflo.dop.stat.copCorAllBands  ...
h.iflo.dop.stat.velCrdSys fits.CTYPE1
h.iflo.dop.stat.velType  ...

h.iflo.dop.velObsProj    fits.velocity,fits.RESTFREQ,fits.crval1
                 velObsProj=(1D + velocity[0]/c - (restFreq[0]/crval1[0]))*c
                        sign of velocity in fits hdr wrong??

h.iflo.dop.freqOffsets   .. force to 0,0,0,0 since bandcfr changes each brd.
h.iflo.dop.freqBCRest    .. fits.RESTFREQ
h.iflo.dop.velOrZ        .. fits.VELOCITY.. does not check for z.
h.iflo.dop.factor        .. fits.crval1/fit.restFreq
 --------------------
 PNT
h.pnt.stat.grMaster Hardcode to 1. 
h.pnt.m.rajcumrd         .. warning time stamp not provided.
h.pnt.m.decjcumrd           probably close to h.std.posTmMs
h.pnt.r.azttd            .. same as in h.std.azttd...
h.pnt.r.grttd
h.pnt.r.chttd
h.pnt.r.agctmstamp
h.pnt.r.secMid           .. fit.off_time which come from pnt time stamp
 --------------------
 PROC
h.proc.srcname      fits.OBJECT
h.proc.procname     fits.OBSMODE with name translation new to old
h.proc.car
  onoff  car[0]     cal fits.OBS_NAME with name translation new to old
  spider car[0]     stripnum: fits.OBS_NAME translate 1,2,3,4

h.proc.iar
  onoff  iar[1]     fits.OBS_NAME onoff: 1,0 for cal
  spider iar[1]     secsStrip: fits.exposure*fits.total_pattern
         iar[2]     recsstrip: fits.total_pattern
         iar[3]     stripsPattern : hardcoded to 4
h.proc.dar
  spider dar[1]     azoffset:fits.croff2,fits.rate_ra,fits.enc_time,
                             fits.rate_dur,fits.crval5 and some computations
  spider dar[2]     zaoffset:fits.croff3,fits.rate_dec,fits.enc_time,
                             fits.rate_dur,fits.crval5 and some computations
  spider dar[3]     rateAz  :fits.rate_ra
  spider dar[4]     rateZa  :fits.rate_dec
 --------------------
 PROC
 -
history
 25jun04 - if frontend = alfa, force rfnum to be 17
 13jul04 - check for eof by row.
 18jul04 - added if2.. mixer
 09aug04 - added rajcumrd decjcumrd
 12aug04 - for spider scans with alfa include the pixel number in iar[5]
           taken from the pattern name .
 14aug04 - for spider scans load iar[0] with a beamwidth.Use stripLen/6.
 20aug04 - added iscan keyword to return to user
 26aug04 - <pjp001> version 1 of hf header
       lst  - same for all
    equinox - same for all boards. 2000.0    
    crval2a - true ra pointing this beam on sky .changes for each beam     
    crval3a - true dec pointing this beam on sky. changes each beam
    crval2b - true az pointing this beam on sky . changes each beam
    crval3b - true za pointing this beam on sky . changes each beam 
    crval2c - raj ant pointing without rx offset. same for all
    crval3c - decj ant pointing without rx offset. same for all
    crval2g - true galactic l pointing this beam on sky. change each beam
    crval3g - true galactic b pointing this beam on sky. change each beam
    date_obs- observation date. same for all beams
    bandwid - bandwidth hz. changes for each pixel(if not alfa)
    crval1v - requested velocity (could change each spectra?) 
    crpix1v - ref pixel for velocity          : different 
    cunit1v - units of crval1v                : same for all
    ctyp1v  - units for velocity coord system : same for all
    specsys - velocity frame                  : same for all
    croff2b - true az off to commanded map center:different 
    croff3b - true za off to commanded map       : different

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasftochdr.pro)</STRONG><P>
<HR>
 
<A NAME="WASGET - READ A GROUP  OF WAS DATA RECORDS.">
<H2>WASGET - READ A GROUP  OF WAS DATA RECORDS.</H2></A>
<A HREF="#WASFTOCHDR - CONVERT FITS HDR TO COR HEADER">[Previous Routine]</A>
<A HREF="#WASHDR - READ A WAS FITS HEADER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasget - read a group  of was data records.

SYNTAX: istat=wasget(desc,b,scan=scan,han=han,hdronly=hdronly)

ARGS: 
   desc:{wasdesc} was descriptor returned from wasopen()
hdronly:          If set then return the b descriptor with only the
                  headers. No data is returned. The datastruture will not
                  contain the b.b1.d[nlags,npol] entry.

RETURNS:
   istat: int  1 ok, 0 eof, -1 error.
       b: {wasget}  data structure holding data. If the hdronly keyword is
                    set then the b datastructure will only contain the
                    headers.

DESCRIPTION:
   This is the lowlevel routine that reads the data from the fits file.
This routine in normally not called by users. The user interface to the
data in the file is via corget(). corget() will call this routine 
automatically when it is passed a wasDescriptor rather than a
logical unit number(lun).

18jan04 - added h.dop. set it so that it is doppler update 
          each sbc even if it is not being done. We will load the
          correct frequency, velocity into the header so that this
          will be true.
19jan04 - force returned data to always be in increasing freq order.
          for now key off of flipped keyword (until cdelta1 is fixed).
02feb04 - switch to use wasftochdr() to get/convert the header.
14jul04 - if pol data then acf's, do not flip data
20aug04 - added iscan call to wasftochdr.
		   use indar to return the data arrays independant of the order
          they are stored on disc.
06sep04 - added hdronly keyword
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasget.pro)</STRONG><P>
<HR>
 
<A NAME="WASHDR - READ A WAS FITS HEADER">
<H2>WASHDR - READ A WAS FITS HEADER</H2></A>
<A HREF="#WASGET - READ A GROUP  OF WAS DATA RECORDS.">[Previous Routine]</A>
<A HREF="#WASLIST - LIST CONTENTS OF A WAS DATA FILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
washdr - read a was fits header

SYNTAX: istat=washdr(desc,h,scan=scan,rec=rec,numhdr=numhdr,inc=inc)

ARGS: 
   desc:{wasdesc} was descriptor returned from wasopen()
   scan: long     scan number default is current position in file
    rec: long     record number of scan, default is current record
    inc:          if set then increment position in file after reading
                  the default is to do do no increment.
    numhdr:       number of headers to read. default is 1

RETURNS:
   istat: int  1 ok, 0 eof,-1 bad (could not find scan or rec)
       h: {wasfhdr}  was fits header

DESCRIPTION:
   This routine will read the fits headers on disc into a data structure.
By default the header from the current row position is input. Multiple
rows can be read with the numhdr keyword. You can position in the file
before reading by using the scan, rec keywords. After the i/o the file
is left positioned at the original position (on entry to this routine). The
inc keyword will position the file after the last header read (be careful
since  integrations or records may contain multiple rows in the file).

WARNING:
   This routine reads the memory in the fits header directly into a
structure. If / when the header changes, this routine will fail (
I need to make it more robust).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/washdr.pro)</STRONG><P>
<HR>
 
<A NAME="WASLIST - LIST CONTENTS OF A WAS DATA FILE">
<H2>WASLIST - LIST CONTENTS OF A WAS DATA FILE</H2></A>
<A HREF="#WASHDR - READ A WAS FITS HEADER">[Previous Routine]</A>
<A HREF="#WASOPEN - OPEN A WAS FITS FILES FOR I/O">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
waslist - list contents of a was data file

SYNTAX: waslist,lun,recperpage

ARGS:
      desc: {wasdesc}  was descriptor returned by wasopen
recperpage:    lines per page before wait for response. def:30

DESCRIPTION:
   List the hdr contents of a fits data file. A single line summary is 
printed for each scan found in the file. The routine will print 30 lines 
at a time before prompting the user to continue. This can be changed with 
the recperpage keyword.

   The listing contains:

    SOURCE      SCAN     RA       DEC   C GRPS NIF NLAG    PatNm TopFrq RCV

Where :
 label :  fits keyword
 SOURCE:  OBJECT
     RA:  CRVAL2
    DEC:  CRVAL3
      C:   ?       coordinate system for ra,dec. not yet implemented
   GRPS:   OBS_NUM number of integrations in scan. Use last obs_num of scan 
                   and switch to make it 1 based.
    NIF:   NIFS    number of IFs this integration 1,2, 4 for stokes.
   NLAG:   LAGS_IN number of channels in spectrum.
  PatNm:   PATTERN_NAME name of dataking pattern used to take the data.
 TopFrq:   CRVAL1  topocentric frequency at reference pixel (Mhz). 
    Rcv:   RFNUM   id number for reciever (lbw is 5).

NOTE:
   Listing the file does not change the position of where the next read will
occur in the file.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/waslist.pro)</STRONG><P>
<HR>
 
<A NAME="WASOPEN - OPEN A WAS FITS FILES FOR I/O">
<H2>WASOPEN - OPEN A WAS FITS FILES FOR I/O</H2></A>
<A HREF="#WASLIST - LIST CONTENTS OF A WAS DATA FILE">[Previous Routine]</A>
<A HREF="#WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasopen - open a was fits files for i/o

SYNTAX: istat=wasopen(filename,desc)

ARGS:
   filename: string  filename to open

KEYWORDS:
       all:  if the keyword is set, open all files that were taken at
             this time. In this case filename should be the name
             of one of the files.
RETURNS:
  istat: int          0 couldn't open file
                      1 file opened successfully
   desc: {wasdescr} - descriptor holding info for file i/o.

DESCRIPTION:
   Open a was (wapp) spectral line fits file. Load
the descriptor with the scan info for the entire file. This
descriptor will be passed to the wasxxx corxxx routines to do the 
file i/o. This descriptor replaces the standard lun that is 
used for the interim correlator data.
   The descriptor contains:
 
   help,desc,/st

   LUN       LONG     0        .. idl lun 
   FILENAME  STRING '/share/wapp11/a9999_wapp1_0027.fits' ..filename 
   TOTSCANS  LONG     1        .. total scans in file (obs scans not pattern)
   TOTRECS   LONG     1        .. total recs (integ)  in file 
   TOTROWS   LONG  7216        .. total number of rows in bintable
   CURPOS    LONG     1        .. position for next read 0 based (row-1)
   SCANIND   LONG     1        .. scan index for next read 0 based 
   colI      struct            .. column number in table for various info
   onlI      struct            .. info to process online files.
   onLine    long              .. true if file is growing (hole exists)
   SCANI     STRUCT  Array[totscans]   .. scan info  
   ------------------------------
   help,desc.scanI,/st
   SCAN      LONG  327939505   .. this scan number
   nbrds     long           1  .. number of wapps used
   nlags     intarr(MAXBRDS)   .. lags sbc per board
   brdNum    bytarr(MAXBRDS)   .. brd number 1..7
   nsbc      bytarr(MAXBRDS)   .. number sbc this board 1,2,4
   level     bytarr(MAXBRDS)   .. 3 or 9 level
   pol       bytarr(4,MAXBRDS) .. pol id for each sbc of each board
   corrattn  bytarr(4,MAXBRDS) .. 0 to 15 each pol each board
                                  1,2,3,4 or 0 not used.
   rowsinrec  long           0 .. rows in 1 rec
   rowsinscan LONG           0  .. number of recs (rows) this scan
                                  multiple recs per observation.
   recsInScan long           0 .. records in scan
   cumRecStart long            .. cumulative rec number in file start this scn
   rowStartInd long          0 .. rowIndex for start of this scan
   cumRecStartInd lONG       0 .. cum rec index for start of this scan
  -------------------------------
   help,desc.colI           .. column numbers for various info
   scan   long              .. col that scan info in 
   grp    long              .. col that scan info in 
   az     long              .. col for az encoder
   el     long              .. col for main elevatio encoder
   elAlt  long              .. col for alternate za encoder
   enctm  long              .. col for the encoder time.
   patnam long              .. col for the pattern name.
   flip   long              .. col for the flip spectra
WAPPMASK  LONG                65
   CTYPE1 LONG                20
   JD     LONG                21
 RESTFREQ LONG                14
VELOCITY  LONG                15

EXAMPLE:
   filenm='/share/wapp11/wapp1.20040118.a1849.0010.fits'
   istat=wasopen(filenm,desc)

   waslist,desc            ; list scan summary
   istat=corget(desc,b)    ; read a record
   corplot,b               ; plot it
   istat=corinpscan(desc,b,scan=401864155,maxrecs=600) ; input a scan
   wasclose,desc           ; when done.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasopen.pro)</STRONG><P>
<HR>
 
<A NAME="WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE">
<H2>WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE</H2></A>
<A HREF="#WASOPEN - OPEN A WAS FITS FILES FOR I/O">[Previous Routine]</A>
<A HREF="#WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
waspos - position to a scan/record in a was fits file

 SYNTAX: istat=waspos(desc,scan,rec)

 ARGS:
      desc:   {wasdesc} .. was descriptor
      scan:    long.. scan number 0--> current scan or whateverr scan fits
                      full scan number --> position to scan
       rec:    long  grp number within scan.
                     0 or not included--> next record available
                               number --> record of current scan
 RETURNS: 1 positioned ok
         -2 requested scan/rec not found

DESCRIPTION:
   Position to a scan/record in a was fits file. The algorithm is:

1. position to start of scannumber. If scannumber is zero then remain
   in current scan.
2. if record is provided then position to record within current scan. If
   record is not provided then position to next record in file.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/waspos.pro)</STRONG><P>
<HR>
 
<A NAME="WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID">
<H2>WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID</H2></A>
<A HREF="#WASPOS - POSITION TO A SCAN/RECORD IN A WAS FITS FILE
">[Previous Routine]</A>
<A HREF="#WASPWR - RETURN POWER INFORMATION FOR A NUMBER OF RECS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wasprojfiles - find the files belonging to a project id

 SYNTAX: istat=wasprojfiles(proj,fileInfo)

 ARGS:
      proj:  string  proj name to search for
 RETURNS: 
     istat:  number of files found 
fileinfo[istat]:   array of file info structures containing the name 
                   and size of the file

DESCRIPTION:
   Search through the wapp fits directories looking for files that
belong to a particular project. Return an array of stuctures containing
the filename and file size.

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/wasprojfiles.pro)</STRONG><P>
<HR>
 
<A NAME="WASPWR - RETURN POWER INFORMATION FOR A NUMBER OF RECS">
<H2>WASPWR - RETURN POWER INFORMATION FOR A NUMBER OF RECS</H2></A>
<A HREF="#WASPROJFILES - FIND THE FILES BELONGING TO A PROJECT ID
">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
waspwr - return power information for a number of recs
SYNTAX: nrecs=waspwr(desc,reqrecs,pwra,lasthdr)
ARGS:
   desc     - descriptor opened via wasopen.
   reqrecs  - requested records to return

RETURNS:
   pwra     - returns an array pwra[nrecs]  of {corpwr} struct
   nrecs    - number of recs found, 0 if at eof, -1 if hdr alignment/io error

DESCRIPTION:

   Return the total power information for the requested number of
records. The data is returned in the array pwra. Each element of the
array contains:

pwra[i].scan - scan number
pwra[i].rec  - record number
pwra[i].time - seconds from midnight end of record.
pwra[i].nbrds- number of boards in use
pwra[i].az   - az (deg) end of this record.
pwra[i].za   - za (deg) end of this record.
pwra[i].azErr- az (asecs great circle) end of this record.
pwra[i].zaErr- za (asecs great circle) end of this record.
pwra[i].pwr[2,4] - total power info. first index in pol1,pol2
                   2nd index are 4 correlator boards.

There will only be valid data in the first pwra[i].nbrds entries of
pwra.
   In pwra[i].[i,j], i=0,1 will be pola, polb if two polarizations were
recorded in the board. If only one polarization was recorded on the
board, then i=0 holds the data (either pola,polB) and i=1 has no data.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/was2/waspwr.pro)</STRONG><P>
<HR>
 
</body>
</html>
