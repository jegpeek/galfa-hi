<!-- This file was generated by mk_html_help_ph.pro -->
<html>
 
<head>
<TITLE>general purpose idl routines</TITLE>
</head>
 
<body bgcolor=white>
<H1>general purpose idl routines</H1>
<STRONG>Last modified: </STRONG>Fri Oct 22 15:09:57 2004.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ADDPATH - ADD A DIRECTORY TO THE START OF THE PATH VARIABLE">
ADDPATH - ADD A DIRECTORY TO THE START OF THE PATH VARIABLE</A>
<LI><A HREF="#ALLMKDOC - CREATE ALL HTML DOCUMENTATION.">
ALLMKDOC - CREATE ALL HTML DOCUMENTATION.</A>
<LI><A HREF="#AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.">
AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.</A>
<LI><A HREF="#ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA">
ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA</A>
<LI><A HREF="#AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.
">AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.</A>
<LI><A HREF="#BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT">
BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT</A>
<LI><A HREF="#BLUSER - INTERACTIVELY BASELINE A FUNCTION.">
BLUSER - INTERACTIVELY BASELINE A FUNCTION.</A>
<LI><A HREF="#BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA">
BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA</A>
<LI><A HREF="#BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE">
BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE</A>
<LI><A HREF="#CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.">
CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.</A>
<LI><A HREF="#CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.">
CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.</A>
<LI><A HREF="#CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.">
CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.</A>
<LI><A HREF="#CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE">
CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE</A>
<LI><A HREF="#CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.">
CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.</A>
<LI><A HREF="#CATALOGINP - INPUT A POINTING CATALOG">
CATALOGINP - INPUT A POINTING CATALOG</A>
<LI><A HREF="#CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL">
CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL</A>
<LI><A HREF="#CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA">
CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA</A>
<LI><A HREF="#CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED">
CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED</A>
<LI><A HREF="#
CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED">
CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED</A>
<LI><A HREF="#COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.">
COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.</A>
<LI><A HREF="#CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP">
CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP</A>
<LI><A HREF="#CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.">
CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.</A>
<LI><A HREF="#CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.">
CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.</A>
<LI><A HREF="#CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.">
CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.</A>
<LI><A HREF="#
CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).">
CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).</A>
<LI><A HREF="#COVARNORM - NORMALIZE THE COVARIANCE MATRIX">
COVARNORM - NORMALIZE THE COVARIANCE MATRIX</A>
<LI><A HREF="#CP - READ CURSOR POSITION AFTER BUTTON PRESS.">
CP - READ CURSOR POSITION AFTER BUTTON PRESS.</A>
<LI><A HREF="#CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.">
CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.</A>
<LI><A HREF="#CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.">
CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.</A>
<LI><A HREF="#DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH">
DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH</A>
<LI><A HREF="#DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY">
DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY</A>
<LI><A HREF="#DBIT - CONVERT TO DB'S">DBIT - CONVERT TO DB'S</A>
<LI><A HREF="#DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.">
DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.</A>
<LI><A HREF="#DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.">
DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.</A>
<LI><A HREF="#
DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS">
DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS</A>
<LI><A HREF="#DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.">
DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.</A>
<LI><A HREF="#DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER">
DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER</A>
<LI><A HREF="#DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD">
DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD</A>
<LI><A HREF="#DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS">
DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS</A>
<LI><A HREF="#EXPLAIN - LIST DOCUMENTATION">EXPLAIN - LIST DOCUMENTATION</A>
<LI><A HREF="#FIGNUM - PUT FIGURE NUMBER ON THE PAGE">
FIGNUM - PUT FIGURE NUMBER ON THE PAGE</A>
<LI><A HREF="#FILE_EXISTS - CHECK IF A FILE NAME EXISTS">
FILE_EXISTS - CHECK IF A FILE NAME EXISTS</A>
<LI><A HREF="#FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS">
FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS</A>
<LI><A HREF="#FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE">
FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE</A>
<LI><A HREF="#FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.">
FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.</A>
<LI><A HREF="#FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE">
FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE</A>
<LI><A HREF="#FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT">
FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT</A>
<LI><A HREF="#FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT">
FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT</A>
<LI><A HREF="#FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX">
FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX</A>
<LI><A HREF="#FITNGAUSS - FIT N GAUSSIANS">FITNGAUSS - FIT N GAUSSIANS</A>
<LI><A HREF="#FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS">
FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS</A>
<LI><A HREF="#FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)">
FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)</A>
<LI><A HREF="#FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS">
FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS</A>
<LI><A HREF="#FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.">
FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.</A>
<LI><A HREF="#FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN">
FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN</A>
<LI><A HREF="#FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA">
FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA</A>
<LI><A HREF="#FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS">
FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS</A>
<LI><A HREF="#FLUXSRC - RETURN SOURCE FLUX">FLUXSRC - RETURN SOURCE FLUX</A>
<LI><A HREF="#FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE">
FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE</A>
<LI><A HREF="#FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK">
FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK</A>
<LI><A HREF="#FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.">
FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.</A>
<LI><A HREF="#FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA">
FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA</A>
<LI><A HREF="#GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.">
GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.</A>
<LI><A HREF="#GAININPDATA - INPUT GAIN DATA FOR RCVR.">
GAININPDATA - INPUT GAIN DATA FOR RCVR.</A>
<LI><A HREF="#GETSCANIND - GET INDICES FOR START OF EACH SCAN">
GETSCANIND - GET INDICES FOR START OF EACH SCAN</A>
<LI><A HREF="#GETSCANINDX - EXTRACT SCAN FROM ARRAY.">
GETSCANINDX - EXTRACT SCAN FROM ARRAY.</A>
<LI><A HREF="#GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.">
GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.</A>
<LI><A HREF="#GS - GENERATE A GAUSSIAN">GS - GENERATE A GAUSSIAN</A>
<LI><A HREF="#GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.">
GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.</A>
<LI><A HREF="#GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI">
GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI</A>
<LI><A HREF="#GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA">
GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA</A>
<LI><A HREF="#HANSMO - HANNING SMOOTH A DATASET">
HANSMO - HANNING SMOOTH A DATASET</A>
<LI><A HREF="#HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.">
HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.</A>
<LI><A HREF="#HDRGET - INPUT HEADERS">HDRGET - INPUT HEADERS</A>
<LI><A HREF="#
HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS">
HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS</A>
<LI><A HREF="#HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.">
HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.</A>
<LI><A HREF="#HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.">
HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.</A>
<LI><A HREF="#HOR - SET HORIZONTAL SCALE FOR PLOTTING.">
HOR - SET HORIZONTAL SCALE FOR PLOTTING.</A>
<LI><A HREF="#IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE">
IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE</A>
<LI><A HREF="#IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.">
IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.</A>
<LI><A HREF="#IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.">
IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.</A>
<LI><A HREF="#IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD">
IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD</A>
<LI><A HREF="#IFLOHSTAT - DECODE STATUS WORDS FOR IFLO">
IFLOHSTAT - DECODE STATUS WORDS FOR IFLO</A>
<LI><A HREF="#IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.">
IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.</A>
<LI><A HREF="#IMGFLAT - FLATTEN AN IMAGE.">IMGFLAT - FLATTEN AN IMAGE.</A>
<LI><A HREF="#IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION">
IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION</A>
<LI><A HREF="#IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY">
IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY</A>
<LI><A HREF="#INVERF - COMPUTE INVERSE ERROR FUNCTION">
INVERF - COMPUTE INVERSE ERROR FUNCTION</A>
<LI><A HREF="#ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.">
ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.</A>
<LI><A HREF="#LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA">
LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA</A>
<LI><A HREF="#LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..">
LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..</A>
<LI><A HREF="#MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.">
MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.</A>
<LI><A HREF="#MAV - MULTIPLY AN ARRAY BY A VECTOR">
MAV - MULTIPLY AN ARRAY BY A VECTOR</A>
<LI><A HREF="#MCALINP - INPUT DATA FOR MEASCAL ROUTINE.">
MCALINP - INPUT DATA FOR MEASCAL ROUTINE.</A>
<LI><A HREF="#MEANROB - ROBUST MEAN FOR 1D ARRAY">
MEANROB - ROBUST MEAN FOR 1D ARRAY</A>
<LI><A HREF="#MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY">
MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY</A>
<LI><A HREF="#MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.">
MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.</A>
<LI><A HREF="#MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.">
MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.</A>
<LI><A HREF="#MKSIN - MAKE A SINE WAVE">MKSIN - MAKE A SINE WAVE</A>
<LI><A HREF="#MK_HTML_HELP_PH">MK_HTML_HELP_PH</A>
<LI><A HREF="#MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING">
MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING</A>
<LI><A HREF="#MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING">
MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING</A>
<LI><A HREF="#MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12">
MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12</A>
<LI><A HREF="#NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.">
NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.</A>
<LI><A HREF="#P8 - SET FRAME BUFFER TO PSEUDO COLOR.">
P8 - SET FRAME BUFFER TO PSEUDO COLOR.</A>
<LI><A HREF="#PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.">
PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.</A>
<LI><A HREF="#PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.">
PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.</A>
<LI><A HREF="#PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA">
PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA</A>
<LI><A HREF="#PLTBYCOL - PLOT VALUES BY COLOR">PLTBYCOL - PLOT VALUES BY COLOR
</A>
<LI><A HREF="#PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER">
PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER</A>
<LI><A HREF="#POSSCAN - POSITION TO A SCAN/RECORD ON DISC">
POSSCAN - POSITION TO A SCAN/RECORD ON DISC</A>
<LI><A HREF="#PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS">
PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS</A>
<LI><A HREF="#PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..">
PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..</A>
<LI><A HREF="#PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.">
PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.</A>
<LI><A HREF="#PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.">
PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.</A>
<LI><A HREF="#PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.">
PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.</A>
<LI><A HREF="#PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.">
PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.</A>
<LI><A HREF="#RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.">
RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.</A>
<LI><A HREF="#READASCIIFILE - READ AN ASCII FILE INTO STRARR">
READASCIIFILE - READ AN ASCII FILE INTO STRARR</A>
<LI><A HREF="#RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS">
RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS</A>
<LI><A HREF="#
RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.">
RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.</A>
<LI><A HREF="#RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME">
RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME</A>
<LI><A HREF="#RMS - COMPUTE THE MEAN AND STANDARD DEVIATION">
RMS - COMPUTE THE MEAN AND STANDARD DEVIATION</A>
<LI><A HREF="#RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.">
RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.</A>
<LI><A HREF="#RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.
">RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.</A>
<LI><A HREF="#SCANLIST - LIST CONTENTS OF  DATA FILE">
SCANLIST - LIST CONTENTS OF  DATA FILE</A>
<LI><A HREF="#SCANTYPE - RETURN THE TYPE OF SCAN">
SCANTYPE - RETURN THE TYPE OF SCAN</A>
<LI><A HREF="#SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.">
SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.</A>
<LI><A HREF="#SELECT - SELECT ELEMENTS FROM AN ARRAY">
SELECT - SELECT ELEMENTS FROM AN ARRAY</A>
<LI><A HREF="#SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS">
SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS</A>
<LI><A HREF="#
SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S">
SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S</A>
<LI><A HREF="#SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)">
SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)</A>
<LI><A HREF="#STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.">
STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.</A>
<LI><A HREF="#STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.">
STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.</A>
<LI><A HREF="#STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.">
STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.</A>
<LI><A HREF="#STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME">
STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME</A>
<LI><A HREF="#SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION">
SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION</A>
<LI><A HREF="#TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.
">TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.</A>
<LI><A HREF="#TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA">
TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA</A>
<LI><A HREF="#
TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.">
TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.</A>
<LI><A HREF="#TVFREQ - RETURN TV CHANNELS AND FREQUENCIES">
TVFREQ - RETURN TV CHANNELS AND FREQUENCIES</A>
<LI><A HREF="#VER - SET VERTICAL SCALE FOR PLOTTING.">
VER - SET VERTICAL SCALE FOR PLOTTING.</A>
<LI><A HREF="#
WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE">
WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE</A>
<LI><A HREF="#WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.">
WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.</A>
<LI><A HREF="#WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.">
WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.</A>
<LI><A HREF="#WINDOWFUNC - MAKE A WINDOW FUNCTION">
WINDOWFUNC - MAKE A WINDOW FUNCTION</A>
<LI><A HREF="#X - SET OUTPUT TO XWINDOWS DEVICE">
X - SET OUTPUT TO XWINDOWS DEVICE</A>
<LI><A HREF="#X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.">
X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.</A>
<LI><A HREF="#X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.">
X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.</A>
<LI><A HREF="#YYMMDDTOJULDAY - CONVERT YYMMDD TO JULIAN DAY">
YYMMDDTOJULDAY - CONVERT YYMMDD TO JULIAN DAY</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ADDPATH - ADD A DIRECTORY TO THE START OF THE PATH VARIABLE">
<H2>ADDPATH - ADD A DIRECTORY TO THE START OF THE PATH VARIABLE</H2></A>
<A HREF="#ALLMKDOC - CREATE ALL HTML DOCUMENTATION.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
addpath - add a directory to the start of the path variable

SYNTAX: addpath,pathname

ARGS:
   pathname : string variable with the path to add. If the pathname 
              does not begin with / or ~ then the path will be 
              relative to the path returned by aodefdir()

DESCRIPTION:
   Add a directory to the beginning of the !path variable. If the
first character does not begin with ~, or /, then make the path
relative to the directory returned by aodefdir(). If the pathname is already 
in the path, then move it to the front of the path.

EXAMPLE:
   addpath, '/home/aosun/u4/bozo/idl' .. 
   addpath, 'Cor2'                    .. adds /pkg/rsi/local/libao/phil/Cor2
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/addpath.pro)</STRONG><P>
<HR>
 
<A NAME="ALLMKDOC - CREATE ALL HTML DOCUMENTATION.">
<H2>ALLMKDOC - CREATE ALL HTML DOCUMENTATION.</H2></A>
<A HREF="#ADDPATH - ADD A DIRECTORY TO THE START OF THE PATH VARIABLE
">[Previous Routine]</A>
<A HREF="#AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
allmkdoc - create all html documentation.
SYNTAX: @allmkdoc

DESCRIPTION:
   Create all of the html documentation in the directory specified by
aodefdir(/doc). The routine will create a temporary file /tmp/idlmkall.pro
and then executes it. It deletes it when done.
 You need write access to the aodefdir(/doc) directory and to /tmp
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/allmkdoc.pro)</STRONG><P>
<HR>
 
<A NAME="AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.">
<H2>AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.</H2></A>
<A HREF="#ALLMKDOC - CREATE ALL HTML DOCUMENTATION.">[Previous Routine]</A>
<A HREF="#ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
aodefdir - AO base directory for idl routines.

SYNTAX: defdir=aodefdir(doc=doc,url=url)

ARGS:
   doc:    if the keyword is set then return the directory for the 
           html documentation.
   url:    if the keyword is set then return the url for the 
           html documentation.

DESCRIPTION:
   Return the directory where the ao idl routines are stored. At AO it 
returns '/pkg/rsi/local/libao/phil/'. The addpath() routine will use this
directory if no pathname is given. This routine makes it easier
to export the ao idl procedures to other sites.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/aodefdir.pro)</STRONG><P>
<HR>
 
<A NAME="ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA">
<H2>ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA</H2></A>
<A HREF="#AODEFDIR - AO BASE DIRECTORY FOR IDL ROUTINES.
">[Previous Routine]</A>
<A HREF="#AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
arrpltazzaerr -  arrow plot of azerr,zaerr vs az,za
SYNTAX: arrpltazzaerr,az,za,azerr,zaerr,tit,ticklen=tickLen,hard=hard
                   indlist=indlist,names=names,notab=notab,tabtit=tabtit,
                   colar=colar,ln=ln
ARGS:
   az[npts]: float   azimuth deg
   za[npts]: float   za deg
azerr[npts]: float   azerr asecs
zaerr[npts]: float   zaerr asecs
       tit:  string. title.. keg 'Gain K/Jy'

KEYWORDS:
ticklen      : float  ticklen in asecs. def: 5
hard         :        if set then use hardcopy settings
names[npts]  : string list of source names used. print left of image.
indlist[npts]: long   index into names array for each point in az,za
totab        :        if set then donot print avg/rms table by za
tabtit       :        title for table
colar[]      : long   color indices to use
ln           : long   line number (1..) to start the notes..

DESCRIPTION:
   make a 2d arrow plot of azimuth, za error versus az,za. This is 
normally used to plot the residual fits of the pointing model. The
length of each arrow will be proportional to the pointing error at 
that az,za. The direction of the arrow will be that of the error. 

   By default a table of the errors in 5 degrees steps is printed at
the bottom of the plot. (it may not show up on the screen version but
it will be there in the postscript file).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/arrpltazzaerr.pro)</STRONG><P>
<HR>
 
<A NAME="AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.">
<H2>AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.</H2></A>
<A HREF="#ARRPLTAZZAERR -  ARROW PLOT OF AZERR,ZAERR VS AZ,ZA
">[Previous Routine]</A>
<A HREF="#BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
avgrobbychan - compute the robust average by chan for 2d array.
SYNTAX:  result=avgrobbychan(d,nsig=nsig,ncnts=ncnts,rms=rms)
  ARGS:
     d[m,n]  : array to compute rms
KEYWORDS:
     nsig:float  any points nsig beyond mean are ignored in the average. 
   
 RETURNS:
     result[m]: result[i]= robustmean(d[i,*])
      ncnts[m]: number samples used for each mean
        rms[m]: rms of each channel (it is not divided by the mean)
 DESCTRIPTION:
    compute a robust mean by channel of a 2d array. For each channel
compute the rms. Throw out all points above nsig, continue doing
this until no points are thrown out. For each channel return the mean 
of the  remaining points.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/avgrobbychan.pro)</STRONG><P>
<HR>
 
<A NAME="BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT">
<H2>BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT</H2></A>
<A HREF="#AVGROBBYCHAN - COMPUTE THE ROBUST AVERAGE BY CHAN FOR 2D ARRAY.
">[Previous Routine]</A>
<A HREF="#BLUSER - INTERACTIVELY BASELINE A FUNCTION.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
blmask - interactively create a mask for baseline fit

SYNTAX: istat=blmask(x,y,maskArr,y2=y2)

ARGS:   
       x[npts]:    xaxis array 
       y[npts]:    yaxis array
KEYWORDS:
		y2[npts]:   overplot second array

RETURNS:
 maskArr[npts]:   returned mask array with valuse  0,1
         istat:   1: created mask, 0: no mask specified by user

DESCRIPTION:
   Let the user interactively define a mask to use for fitting. The
x,y data is plotted and then the user is prompted to interactively
build the mask using the mouse. The user is prompted to position the
the mouse to the start and end of each segment that is to be filled
with ones in the mask. The left mouse button is used to specify the
point. The right mouse button will get you out of this loop. The
returned mask will have the value 1 for all the specified segments.
All other values will be set to 0.

 	If the y2 keyword is provided, then the data in y2 will be over
plotted in red. You might use this when you are trying to create
1 mask for 2 polarizations of data.

EXAMPLE:
   istat=blmask(x,y,maskArr)
buttons used: left mark, right quit 
  1--P1?--     -47.2958
  1--P2?--      9.64367     first section of mask done
  2--P1?--      19.4657
  2--P2?--      22.8821     2nd section of mask done
  3--P1?--      25.1597     right button clicked so it returns.

NOTE:
   It is the users responsibility to set the horizontal and vertical scale
prior to calling this routine. The normal interface to this routine is 
from the bluser() routine.

SEE ALSO: bluser, cursorsubset.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/blmask.pro)</STRONG><P>
<HR>
 
<A NAME="BLUSER - INTERACTIVELY BASELINE A FUNCTION.">
<H2>BLUSER - INTERACTIVELY BASELINE A FUNCTION.</H2></A>
<A HREF="#BLMASK - INTERACTIVELY CREATE A MASK FOR BASELINE FIT
">[Previous Routine]</A>
<A HREF="#BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
bluser - interactively baseline a function.
 
SYNTAX: istat=bluser(x,y,coef,mask,yfit,maskst=maskst)

ARGS:   
       x[npts]:    xaxis array 
       y[npts]:    yaxis array

KEYWORDS:
   maskst[npts]:  if provided, then use this mask to start with.

RETURNS:
     coef[]   :   coefficients from fit
    mask[npts]:   mask used for fit that was defined by the user.
    yfit[npts]:   fit evaluatuted at the data points
         istat:   1: fit ok, 0 no fit

DESCRIPTION:
   bluser lets the user interactively baseline a function. The user passes
in the x,y arrays of data. The routine will pass back the coef's from the
fit, the mask used, and the fit evaluated at the data points. On entry
the main menu is displayed:

 KEY  ARGS     FUNCTION
 m             .. define mask
 f       n     .. fit polynomial of order n
 h       h1 h2 .. change horizontal scale for plot to h1,h2
 v       v1 v2 .. change vertical  scale for plot to v1,v2
 c             .. print coefficients
 p             .. plot data - fit
 q             .. quit

The user should first adjust the horizontal and vertical scale with
h h1 h2 and v v1 v2. Each time one of these is entered the plot will
be redisplayed with the new limits (do not use commas here..).

When the plot shows the correct limits, enter m to define the mask. The
leftmost mouse button is used to define the starting and ending portions 
of the data that will be used for the fit. You can have as many of these
sections as you want. When you are done with the mask, click the right
mouse button.

After defining the mask, you can fit any order polynomial you want.

 f 4 

would fit a fourth order polynomial and overplot the fit. 

 p  .. plots data - fit. (use v v1 v2 to reset the vertical scale). 

You can go back and redefine a new mask if you want and the redo the fits.

 q  is how you exit the routine.

SEE ALSO: blmask
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/bluser.pro)</STRONG><P>
<HR>
 
<A NAME="BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA">
<H2>BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA</H2></A>
<A HREF="#BLUSER - INTERACTIVELY BASELINE A FUNCTION.">[Previous Routine]</A>
<A HREF="#BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
bpcmpbychan  - compute a band pass from set of spectra
 
SYNTAX: bpc=bpcmpbychan(d,
                 deg=deg,nsig=nsig,nlsig=nlsig,chnNsig=chnNsig,$
		 	flatTsys=flatTsys,
				  maxFitloop=maxFitLoop,$
                 chanRms=chanRms,resAll=resAll,dfit=dfit,$
                 gdpntperchan=gdpntperchan,nloop=nloopbychan,$
                 indBadChan=indBadChan,indgdchan=indgdchan,zeromean=zeromean
ARGS:
d[nchn,npts]: float    input data to process

KEYWORDS:
   deg:    int   degree of polynomial fit along each channel. default=1
  nsig:    float The clipping level (in sigmas) to use for the fit 
				  residuals. Any value greater than this is not included 
				  in the fit. The default is 3 sigma.
  nlsig:   float if nlsig is provided, then channels that have large values 
                 of sigma/median will have there points to exclude recomputed
                 with nlsig rather then nsig. A good value would be 2.
			      By default this is not done.			
 chnNsig:  float : If indBadChan, or indGdChan is requested, use
				  chnNsig to determine which channels are good:
				  (rms/sigma le chnNsig), and which channels are bad:
				  (rms/sigma gt chnNsig). The default for chnNsig is 3 sigma.
 flatTsys:       if set, then divide each spectra by the median
				  value. This will allow continuum sources to be included
				  in drift scan mode.
 maxFitLoop:int  The maximum number of times to iterate on the fit for
                 a single channel. The default is 20.
 zeromean  :     if set, the the input data has zero mean, donot divide
				  byte the mean;

RETURNS:
   bpc[nchn]   :float  the bandpass to use for the bandpass correction.

chanRms[npts]     :float  the rms/mean computed for each channel.
resAll[nchn,npts] :float  the fit residuals for each point (y-yfit) in
                          units of sigma of that channel.
dfit[nchn,npts]:float  the 2d fit of the data to the polynomials by chan.

gdPntPerChan[nchn]:long the number of good points used in each channel.
indGdChan[]       :long The indices (0 based) for all channels who had
                        an rms/mean less than chnNSig
indBadChan[nchn]  :long The indices (0 based) for any channels who had
                        an rms/mean greater than chnNsig.
       nloop[nchn]:long The number of fitting iterations that where done 
                        on each channel.
DESCRIPTION:
   Compute a bandpass correction for a set of data.
It works with an array of npts spectra each having  nchn channels.
The algorithm is:

1. If tsysFlat is selected then 
   compute the median over freq for each spectra and call it Tsys[npts]
   Use this to flatten each time point so that continuum sources
   do not skew the data and can be included in the statistics. 
   If TsysFlat is not selected, then test Tsys[npts] to 1.

2. for each channel take all of the time points for that channel:
   y=d[ichn,*]
   a. Normalize this channel to the average tsys over time: 
     y[npts]=y[npts]/Tsys[npts]
   b. define all npts to be good points.
   c. fit a polynomial of order deg to the good points,
      coef=poly_fit(x[gdpnts],y[gdpnts],deg)
   d. compute the residuals over all points using the coef from c.
       res=y-coef(x,coef)
   e. find all points that are less than nsig times the fit sigma. 
   f. If there are fewer points than we started with in c, goto c, if
      not, then we are done with the channel
   g. store the following:
       - chanRms[ichn]= rms/mean(last fit)
       - dfit[ichn,*] = last fit along this channel
       - gdpntPerChan get number of points we were left with after the fit.
       - nloop[ichn] is the number of times we looped on the fitting.
3. When done with all channels, if indBadChan or indGdChan is provided,
   call meanrob( robust mean) with the chanrms[] array. It will
   find all of the channel sigmas that stick out less than chnNsig.
4. Compute the average bandpass correction by averaging the fit array
   over all time samples: bpc=total(dfit[nchn,npts],2)/npts
6. The function returns bpc[nchn]

Some Notes on the returned data:

1. The data is flattened in the time direction. The results:
   bpc, dfit,chanRms,resAll are relative to this dataset. With this
	processing, continuum sources will not have large residuals (since
   they were flattened by the mean power of that sample). If you overplot
   the bpc with the input data, they will differ by a scaling factor. This
   will be corrected for when the cal is applied.
2. resAll is in units of rms of the flattened channel: (y-yfit)/sigma. 
3. chanRms[nchn] has been divided by the mean of each channel. This
   flattens the bandpass edges. You should be able to predict what
   this value should be from the 1./sqrt(bw*tau)

EXAMPLE:
   Suppose you have spectra spc[1024,300] and a calOnOff[1024,2]
Processing would be:
   bpc=bpcmpbychan(spc,chanRms=chanRms,indgdChan=indgdchan)
;  
;  don't use 100 channels on each edge, plus all the chanRms gt 3 sigma
;  for scaling to kelvins.
;
   mask=lonarr(1024)
   mask[indgdchan]=1. 
   mask[0:99]=0    
   mask[1024-99:*]=0   
   ind=where(mask eq 1)
   ngood=n_elements(ind)
   bpc=bpc/(total(bpc[ind])/ngood) ; bp now normalized to unity
   for i=0,nsmp-1 do spc=spc[*,i]/bpc
;
; now scale to kelvins
;
   caldeflTP=total(calOnoff[ind,0]-calonOff[ind,1])/ngood ; use same good chan
   corToK=calKelvins/calDeflTp
   spc=spc*corToK                  spectra now in kelvins. 

; I've left the steps separate for illustration. You could combine the
; calscaling and bandpass corretion in one multiply.

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/bpcmpbychan.pro)</STRONG><P>
<HR>
 
<A NAME="BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE">
<H2>BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE</H2></A>
<A HREF="#BPCMPBYCHAN  - COMPUTE A BAND PASS FROM SET OF SPECTRA
">[Previous Routine]</A>
<A HREF="#CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
bytesleftfile - return the unread bytes left in a file
SYNTAX: bytesLeft=bytesleftfile(lun,bytereq=bytereq,chktime=chktime,$
                               maxloop=maxloop,cursize=cursize)
ARGS:
         lun: int  lun to already open file that we should check.
KEYOWRDS:
 bytereq: long Wait until at least this number of bytes is available.
               use the chktime keyword to determine how often to check
chktime : float number of seconds to delay between file size checks. This
                is used if bytereq is specified. The default is 1 second.
maxloop : long  max number of times to loop if bytereq option used.
                The default is 999999
RETURNS:
   bytesLeft: LONG returns the unread bytes in the file
   cursize  : LONG current number of bytes in file

DESCRIPTION:
   The routine will return the number of unread bytes in a file. 
It takes 5 to 10 milliseconds to check the file size. 
   The bytereq option will wait until at least bytereq bytes are available 
in the file. The chktime option specifies how often to check the file size.
The maxloop option tells how many times to check the file before quitting.
EXAMPLE:
   openr,lun,'/share/olcor/corfile.15jun02.x101.1',/get_lun
   nbytes=bytesleftfile(lun)
   Wait till there are at least 5k bytes. Check every 10 secs and loop
   a maximum of 60 times:
   nbytes=bytesleftfile(lun,bytereq=5000,chktime=10,maxloop=60)
   
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/bytesleftfile.pro)</STRONG><P>
<HR>
 
<A NAME="CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.">
<H2>CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.</H2></A>
<A HREF="#BYTESLEFTFILE - RETURN THE UNREAD BYTES LEFT IN A FILE
">[Previous Routine]</A>
<A HREF="#CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
calget - return the cal value given hdr,freq.

SYNTAX: stat=calget(hdr,freq,calval,date=date,swappol=swappol)

ARGS:
      hdr: {hdr}  header holding at least hdr.iflo
     freq: float  freq in Mhz for cal value.
KEYWORDS:
  date[2]: int    [year,daynumber] epoch for cal value. 
                  Default is the date in the header.
  swappol:        If set then swap the polA polB calvalues. This
				   can be used to correct the 1320 hipass polarization 
				   problem, or to compensate for a xfer switch being
				   used.

RETURNS:
calval[2]: float  cal values in deg K for polA,polB.
     stat: int     -1 error, 0 got the values ok.

DESCRIPTION:
   Return the cal values in degrees K for the requested freq. The hdr can be
a correlator or ri header (as long as it includes hdr.iflo). This 
routine always returns 2 values: pola, and polB.

   The calvalues for the receiver in use are looked up and then the
values are interpolated to the observing frequency.

NOTE:
   Some cals have measurements at a limited range of frequencies (in some
cases only 1 frequency). If the requested frequency is outside the range
of measured freqeuncies, then the closest measured calvalue is used 
(no extrapolation is done).
   hdr should be a single element rather than an array.
   This routine extracts info from the header and then calls calget1().

SEE ALSO:calget1, calval, calinpdata, corhcalval
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/calget.pro)</STRONG><P>
<HR>
 
<A NAME="CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.">
<H2>CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.</H2></A>
<A HREF="#CALGET - RETURN THE CAL VALUE GIVEN HDR,FREQ.
">[Previous Routine]</A>
<A HREF="#CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
calget1 - return the cal value given rcvr,frq,type.

SYNTAX: stat=calget1(rcvrNum,caltype,freq,calval,date=date,hybrid=hybrid, 
                     fname=fname,swappol=swappol) 

ARGS:
     rcvrNum: int receiver number 1..16 (see helpdt feeds).
     calType: int type of cal used 0 through 7.
                  0-lcorcal,1-hcorcal,2-lxcal,3-hxcal,
                  4-luncorcal,5-huncorcal,6-l90cal,7-h90cal 
     freq: float  freq in Mhz for cal value.
KEYWORDS:
    date[2]: int  [year,daynumber] data for calvalue. Default is the
                  current date.
     hybrid:      if set then a hybrid was in use and the cal values should
                  be averaged together.
   fname:string use an alternative filename for cal data.
 swappol:         if set then swap the polA, polB calvalues on return.
				   This can be used to correct for the 1320 hipass
				   polarization cable switch or a xfer switch.
RETURNS:
calval[2]: float .. calValues in deg K for polA,polB
					 Note if this is alfa, then [2,7] value are returned
					 for the 7 pixels..
     stat: int   .. -1 error, 0 got the values ok.

DESCRIPTION:
   Return the cal values in degrees K for the requested reciever, caltype,
and frequency. This routine always returns 2 (or 2x7) values: pola, and polB.

   The calvalues for the receiver in use are looked up and then the
values are interpolated to the observing frequency.

EXAMPLES:
   Get the cal values for lbw (rcvrNum=5) using the high correlated cal 
(caltype=1) at 1400. Mhz.
   stat=calget1(5,1,1400.,calval)

NOTE:
   Some cals have measurements at a limited range of frequencies (in some
cases only 1 frequency). If the requested frequency is outside the range
of measured freqeuncies, then the closest measured calvalue is used 
(no extrapolation is done).
   If you have a datatking header, you can use calget(). It will 
take the rcvrNum, and caltype,  from the header.

SEE ALSO:calget, calval, calinpdata, corhcalval
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/calget1.pro)</STRONG><P>
<HR>
 
<A NAME="CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.">
<H2>CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.</H2></A>
<A HREF="#CALGET1 - RETURN THE CAL VALUE GIVEN RCVR,FRQ,TYPE.
">[Previous Routine]</A>
<A HREF="#CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
calInpData - input cal data for rcvr/calType.

SYNTAX:
     istat=calInpData(rcvNum,calNum,calData,fname=fname,date=date)  

ARGS:
     rcvNum:  1 thru 16.  receiver to use (same as hdr.iflo.stat1.rfnum).
     calNum:  0 thru  7.  cal Type to use (same as hdr.iflo.stat2.calType). 
               the values are:0-lcorcal,1-hcorcal,2-lxcal,3-hxcal,
                              4-luncorcal,5-huncorcal,6-l90cal,7-h90cal
KEYWORDS:
      fname: to specify an alternate data file with cal values.
            The default file is aodefdir() + 'data/cal.dat{rcvNum}
      date : [year,daynum]  .. if specified the data when you want the
                              cals for..default is most recent.

RETURNS:
      istat: 1 ok, -1 bad file/rcvnum,data , -2 bad calnum
    calData: return data in structure:
            calData.calNum   - calNum 
            calData.numFreq  - number of freq entries
            calData.freq[numFreq] - for each cal value (in Mhz)
            calData.calA[numFreq] - polA cal value in Kelvins
            calData.calB[numFreq] - polB cal value in Kelvins
DESCRIPTION: 
  Input the cal data for all the frequncies of a particular receiver (rcvNum)
  and cal type (calNum). The calNum and rcvNum can be extracted from the
  headers with iflohrfnum() and iflohcaltype (). 

  The default datafile is aodefdir() + 'data/cal.dat{rcvNum} (aodefdir() is
  a function that returns the root of the aoroutines). The keyword
  fname allows you to specify an alternate file. The file format is:
  -  col 1 # is a column
  -  data is free format , column oriented
  -  nd1 is noise diode 1, nd2 is noise diode2, H-highcal,L-lowcal,
  -  A is polA, B id polB, ndxx-->A/B  implies that diode N feeds pol X 

    freq nd1H->A nd1L->A nd1H->B nd1L->B nd2H->A nd2L->A nd2H->B nd2L->B
  
  The mapping of cal type to diodes used is:
  corCal     diode 1-> polA, diode 1-> polB
  uncorCal   diode 1-> polA, diode 2-> polB
  xCal       diode 1-> polB, diode 2-> polA
  90cal      diode 2-> polA (with 90deg phase shift), diode 2-> polB

This routine is called automatically by corhcalval and calget().

How the different cal routines vary:
calinpdata() inputs the data from disc. You must specify the rcvrnum,calnum.
             It defaults to the current date. It loads a table in common
             but it does not interpolate or compute a calvalue.
calval()     Pass in the frequency and the caldata array input via
             calinpdata(). It will interpolate the frequency and compute the
             cal value.
calget()     You supply a header and a frequency. The routine figures out the
             caltype,rcvrNum, and date from the header and calls calinpdata()
             and calval(). It returns the cal values.
corhcalval() You specify the correlator sbc header (eg b.b1.h). It will
             compute the frequency and then call calget(). It returns the
             cal values.

NOTE:
  The following receivers will always return a single calNum independent
of what is requested (since they only have 1 single cal).
  rcvnum  nam    calnumreturned
   12     sbn     0  low cor cal
    3     610     0  low cor cal
    6     lbn     0  low cor cal

SEE ALSO: corhcalval, calget
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/calinpdata.pro)</STRONG><P>
<HR>
 
<A NAME="CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE">
<H2>CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE</H2></A>
<A HREF="#CALINPDATA - INPUT CAL DATA FOR RCVR/CALTYPE.
">[Previous Routine]</A>
<A HREF="#CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
calonofffind - find all of the cal on/offs in  file
SYNTAX: numfound=calonoffind(lun,sl,indon)
ARGS:
   lun:    int lun for file to search
   sl[]:   {getsl} scan list structure (returned from getsl(sl).
RETURNS:
   indon[numfound]: int  indices into sl for the start of each cal on of
                    a pair.
DESCRIPTION:
   Find all of the calonoff pairs in a file. Return the indices into sl
for the calon scans. For a pair to be included the calon scan must be
immediately followed by a cal off scan.

EXAMPLES:
   sl=getsl(lun)
   numfound=calonoffind(lun,sl,indon)
   for i=0,numfound-1 do begin
       print,posscan(lun,sl[ind[i]].scan,1,sl=sl) ; position to start calon
       istat=corcalonoff(lun,retdat)   ; process each onoff pair
   endfor
SEE ALSO:
   getsl,corcalonoff
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/calonofffind.pro)</STRONG><P>
<HR>
 
<A NAME="CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.">
<H2>CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.</H2></A>
<A HREF="#CALONOFFFIND - FIND ALL OF THE CAL ON/OFFS IN  FILE
">[Previous Routine]</A>
<A HREF="#CATALOGINP - INPUT A POINTING CATALOG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
calval - return the cal value for a given freq.

SYNTAX:
   istat=calval(freqReq,calData,calV,hybrid=hybrid,swappol=swappol)

ARGS:
    freqReq:  float     frequency in Mhz for cal
    calData:  {calData} already input via calInpData()
KEYWORDS:
     hybrid:    if keyword set, then average the polA,polb values 
               together (used when linear receivers are converted to circular
               by a hybrid after the dewar).
    swappol:   if set then swap the polA, polb calvalues in the calV array
			    on return. This can be used to correct for the 
				1320 hipass polarization cable switch or the use of 
			    one of the xfer switches.
 alfapixnum:   if this is alfa data, then the pixel number (0 thru 6) of
			    the alfa pixel to use. If the cal values are alfa data
               and this is not specified, use pixel 0.

RETURNS:
      istat:  1 ok within range, 0 outside range used edge,-1 all zeros
    calV[2]:  float array of [2] floats holding interpolated cal values for
                    polA and polB. If this is alfa then the calV is 
				     dimensioned 2,7  for the 7 pixels.

DESCRIPTION:
   Interpolate the cal value to the requested frequency. The calData 
should have already been read in with calInpData. If the requested
frequency is outside the data range, return the cal values at the
edge (no extrapolation is done). The data is returned in an array
of two values.

   The normal way to get cal values is via corhcalval() or calget().
They call this routine.

SEE ALSO:corhcalval, calget, calinpdata.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/calval.pro)</STRONG><P>
<HR>
 
<A NAME="CATALOGINP - INPUT A POINTING CATALOG">
<H2>CATALOGINP - INPUT A POINTING CATALOG</H2></A>
<A HREF="#CALVAL - RETURN THE CAL VALUE FOR A GIVEN FREQ.
">[Previous Routine]</A>
<A HREF="#CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
cataloginp - input a pointing catalog
SYNTAX: nsrc=cataloginp(file,format,retdata,comment=comment)
ARGS:
	file	 :string	filename of catatlog
	format   :int       format for catalog:
						1: srcname hh mm ss dd mm ss
						2: srcname hhmmss ddmmss
   retdata[]:{srccat}  return data here
                       in retdata.
KEYWORDS:
   comment  : string   comment characters for catatlog.def:#
DESCRIPTION:
   Read in all of the source names and positions catalog specified by
file
The returned srccat array will contain:
help,retdat,/st
** Structure CATENTRY, 6 tags, length=52:
   NAME            STRING 	   ''			source name
   RA              FLOAT     Array[3]      hh mm ss.ss 
   DEC             FLOAT     Array[3]      dd mm dd.dd	 (alway positive)
   DECSGN          INT              0      +/- 1 sign of declination
   RAH             DOUBLE           0.0	ra in hours (includes sign)
   DECD            DOUBLE           0.0    dec in hours (includes sign)
   EOL             STRING                  string dec to end of line
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/cataloginp.pro)</STRONG><P>
<HR>
 
<A NAME="CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL">
<H2>CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL</H2></A>
<A HREF="#CATALOGINP - INPUT A POINTING CATALOG">[Previous Routine]</A>
<A HREF="#CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
chebeval - evaluate chebyshev polynomial
SYNTAX: y=chebeval(a,b,coef,x)
ARGS:
     a : double    min value of xrange used for fit.
     b : double    max value of xrange used for fit.
coef[m]: double coefficients from fit.
   x[n: double xvalues where polynomial should be evaluated.

RETURNS:
   y[n]: fit evaluated at the requested x values.
DESCRIPTION:
   Evaluate a chebyshev polynomial at the requested x values. These
values should be within the x values used for the fit. The a,b
parameters are the min,max x values used in the fit.
SEE ALSO: chebfit()
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/chebeval.pro)</STRONG><P>
<HR>
 
<A NAME="CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA">
<H2>CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA</H2></A>
<A HREF="#CHEBEVAL - EVALUATE CHEBYSHEV POLYNOMIAL">[Previous Routine]</A>
<A HREF="#CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
chebfit - chebyshev polynomial fit to data
SYNTAX:coef=chebfit(x,y,deg,merr=merr,$
                   yfit=yfit,rangex=rangex,singular=singular,chisq=chisq,$
                   covar=covar)
ARGS:
   x[n]: float/double independent var.  
   y[n]: float/double measured dependent variable
    deg: int          deg of fit (ge 1)
KEYWORDS:
merr[n]: float/double  measurement errors for y.default is uniform

RETURNS:
   coef[deg+1]:  coefs from fit

KEYWORDS RETURNS:
   yfit[n]: float or double . fit evaluated at x locations.
 rangex[2]: float/double     min max values of x used for fit.
                          these were used to map the x axis 
                          into [-1,1] for the fit.
chisq   : float/double chisqr from svdfit
covar[] : float/double covariance matrix from svdfit().
singular: int          number of singular points found (see svdfit()).

DESCRIPTION:
   Do a chebyshev polynomial fit of order deg to the x,y data. Merr
are the measurement errors (see idl svdfit routine).
Return the coefs for the fit as well as the mapping of the xrange
into [-1,1].  
SEE ALSO:
   chebeval() to evaluate the coef.

NOTE:
The fitting function svdcheb() is contained in this file. If the
routine gives an error that it cannot find svdcheb() just compile
this routine explicitly (.compile chebfit). 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/chebfit.pro)</STRONG><P>
<HR>
 
<A NAME="CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED">
<H2>CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED</H2></A>
<A HREF="#CHEBFIT - CHEBYSHEV POLYNOMIAL FIT TO DATA">[Previous Routine]</A>
<A HREF="#CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
checkkey - check if any keys have been pressed 
SYNTAX:  key=checkkey(first=first,all=all,wait=wait,noflush=noflush)
ARGS  :  NONE
KEYWORDS:
	first:	if set then return the first character. default is the last char.
	all:	if set then return all characters. default is the last char.
	wait:	if set then wait for at least one character
	noflush: if set and first is set, then don't flush the other characters
			 in the buf.
RETURNS:
	key :	character or characters entered.
DESCRIPTION:
	checkkey will check to see if any keys have been pressed. It will return
with the last key waiting in the input buffer or '' if nothing was there.
The wait keyword will cause the routine to wait for at least 1 keypress.
The first keyword will return the first rather last key of any string.
The all keyword will return all keys entered. By default all characters
waiting in the input buffer are read. If the noflush and first keyword are
set then only the first char is returned. The other chars can be read at
a later time.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/checkkey.pro)</STRONG><P>
<HR>
 
<A NAME="CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED">
<H2>CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED
</H2></A>
<A HREF="#CHECKKEY - CHECK IF ANY KEYS HAVE BEEN PRESSED
">[Previous Routine]</A>
<A HREF="#COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
chkswaprec - check hdrlen to see if the record needs to be swapped
SYNTAX: swap=chkswaprec(stdhdr)
ARGS:
       stdhdr: {hdrStd} standard portion of data header
RETURNS:
      swap : int 1 --> need to swap,0 --> no need to swap
DESCRIPTION
   Check to see if the record needs its data swapped because of
big/little endian differences. The user passes in the standard header
and the routine checks that the abs(hdrstd.hdrlen) < 65535. If the
number i larger than this then the record needs to be swapped (headers
are never larger than 65535.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/chkswaprec.pro)</STRONG><P>
<HR>
 
<A NAME="COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.">
<H2>COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.</H2></A>
<A HREF="#CHKSWAPREC - CHECK HDRLEN TO SEE IF THE RECORD NEEDS TO BE SWAPPED
">[Previous Routine]</A>
<A HREF="#CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
colorinfo - return info on current color setup.
SYNTAX: colorinfo
ARGS:
DESCRIPTION:
   Queries idl on the current color setup. Output sent to stdout.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/colorinfo.pro)</STRONG><P>
<HR>
 
<A NAME="CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP">
<H2>CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP</H2></A>
<A HREF="#COLORINFO - RETURN INFO ON CURRENT COLOR SETUP.
">[Previous Routine]</A>
<A HREF="#CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
condblevels - compute db contouring levels for a map
SYNTAX: levels=condblevels(map,nlevels,dbstep,maxval)       
ARGS:
  map[m,n]: float  data to to compute levels for.
 nlevels  : int    number of levels requested
    dbstep; float  dbstep between levels
RETURNS: 
levels[nlevels]: float holding the values to use to mark the contours
maxval         : float the maximum value in map. The contours are relative
                 to this value.
DESCRIPTION:
   Compute nlevels space dbstep apart from the maximum value in map.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/condblevels.pro)</STRONG><P>
<HR>
 
<A NAME="CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.">
<H2>CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.</H2></A>
<A HREF="#CONDBLEVELS - COMPUTE DB CONTOURING LEVELS FOR A MAP
">[Previous Routine]</A>
<A HREF="#CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
contourph - phil's interface to idl contour routine.

SYNTAX: contourph,d,numcontours,dbstep,maxval,levels,axes=axes,$
        fill=fill,_extra=e
ARGS:
   d[nx,ny] : float    data to contour.    
 numcontours: int      number of contours to plot. 
      dbstep: float    db step between contour levels.
RETURNS:
      maxval: float    db scaling is relative to this value.
levels[numcontours]: float the contour levels in dbs relative to maxval.
         
KEYWORDS:
     axes[4]: float    axes label values: [minx,maxx,miny,maxy]. If not 
                       supplied then 0:nx-1,0:ny-1 are used.
        fill: int      if set then fill the contours with colors.
           e:          extra keywords sent to the contour routine.
DESCRIPTION:
   contourph interfaces to the idl contour routine. It will scale
a dataset to dbs relative to the maximum value. The number of levels and
db step size is input by the user. Annotation can be entered via the
_extra=e keyword.

EXAMPLE:
   let bmmap[120,50] be a baselined beammap dataset of 20 arcminutes in az and
15 arcminutes in za. To contour the data with 12;contours at 2db steps:

   axes=[-10.,10.,-7.5,7.5]
 contourph,bmmap,12,2,maxval,levels,axes=axes,xtitle='az [amins]',$
   ytitle='za [amins]'
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/contourph.pro)</STRONG><P>
<HR>
 
<A NAME="CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.">
<H2>CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.</H2></A>
<A HREF="#CONTOURPH - PHIL'S INTERFACE TO IDL CONTOUR ROUTINE.
">[Previous Routine]</A>
<A HREF="#CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corbychan - auto/xcorrelate dynamic spc by chan.
SYNTAX:  cormat=corbychan(spc1,spc2,avg1=avg1,avg2=avg2,rms1=rms1,rms2=rms2)
  ARGS:
     spc1[nchn,mtime] : float first dynamic spectra
     spc2[nchn,mtime] : float 2nd dynamic spectra (not needed if auto
                              correlation done
KEYWORDS:
   
 RETURNS:
     cormat[nchn,nchn]: float  correlation matrix returned
     avg1[nchn]       : float robust average over time of spc1
     avg2[nchn]       : float robust average over time of spc2
     rms1[nchn]       : float rms by channel of spc1
     rms2[nchn]       : float rms by channel of spc2

 DESCTRIPTION:
    Compute the correlation matrix for a set of dynamic spectra. It computes
 the correlation between every two pairs of channels in one set of
 dynamic spectra (if only spc1 entered) or between channels in two
 sets of dynamic spectra (if spc1,spc2 entered).

   The computation is:

   Let:
   nchn=the number of freq channels
   mtm =the number of time samples
   for spc 1 or 2 let:
       savg[nchn]= mean(spc[,]) averaging over the time samples
       srms[nchn]= rms(spc) computed along the time axis of each chan
   s[i,j]    = (spc[i,j] - sAvg[i]))/srms[i] .. remove mean normalize to sigma

   cormat[i,j]= sum_k(s1[i,k]*s2[j,k])/nsmp
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/corbychan.pro)</STRONG><P>
<HR>
 
<A NAME="CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.">
<H2>CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.</H2></A>
<A HREF="#CORBYCHAN - AUTO/XCORRELATE DYNAMIC SPC BY CHAN.
">[Previous Routine]</A>
<A HREF="#
CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corinit - initialize to use the idl correlator routines.
SYNTAX: @corinit   
DESCRIPTION:
   call this routine before using any of the correlator idl routines.
It sets up the path for the idl correlator directory and defines the
necessary structures.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/corinit.pro)</STRONG><P>
<HR>
 
<A NAME="
CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).">
<H2>CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).
</H2></A>
<A HREF="#CORINIT - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES.
">[Previous Routine]</A>
<A HREF="#COVARNORM - NORMALIZE THE COVARIANCE MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
corinit1 - initialize to use the idl correlator routines (no lut load).
SYNTAX: @corinit   
DESCRIPTION:
   call this routine before using any of the correlator idl routines.
It sets up the path for the idl correlator directory and defines the
necessary structures. It calls geninit1 instead of geninit. The color
table ldcolph call is not made. This speeds things up for remote observers.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/corinit1.pro)</STRONG><P>
<HR>
 
<A NAME="COVARNORM - NORMALIZE THE COVARIANCE MATRIX">
<H2>COVARNORM - NORMALIZE THE COVARIANCE MATRIX</H2></A>
<A HREF="#
CORINIT1 - INITIALIZE TO USE THE IDL CORRELATOR ROUTINES (NO LUT LOAD).
">[Previous Routine]</A>
<A HREF="#CP - READ CURSOR POSITION AFTER BUTTON PRESS.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
covarnorm - normalize the covariance matrix
SYNTAX: covar=corvarnorm(covar)
ARGS:
   covar[]: float covariance matrix.
DESCRIPTION:
   Normalize  a covariance matrix to have unit diagonols.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/covarnorm.pro)</STRONG><P>
<HR>
 
<A NAME="CP - READ CURSOR POSITION AFTER BUTTON PRESS.">
<H2>CP - READ CURSOR POSITION AFTER BUTTON PRESS.</H2></A>
<A HREF="#COVARNORM - NORMALIZE THE COVARIANCE MATRIX">[Previous Routine]</A>
<A HREF="#CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
cp - read cursor position after button press.

SYNTAX: cp,x=x,y=y
ARGS  : none
KEYWORDS:
	x  : float return x value here
	y  : float return y value here
EXAMPLE:
   plot,findgen(100)
   cp
   .. user clicks left button at desired position on plot.
   24.0208   23.2295   .. x,y positions printed out.

NOTE:
   If the window system is set so that the window focus follows the cursor, 
then you must make sure that the cursor is in the idl input window before
you enter the command cp. 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/cp.pro)</STRONG><P>
<HR>
 
<A NAME="CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.">
<H2>CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.</H2></A>
<A HREF="#CP - READ CURSOR POSITION AFTER BUTTON PRESS.
">[Previous Routine]</A>
<A HREF="#CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
cumfilter - cumfilter routine from carl heiles.
SYNTAX: cumfilter,data,range,limit,indxgood,indxbad,countbad,
                  median=median,correct=correct
ARGS:
   data[n]:        data to filter
   range  : long   number of channels in center of distribution to use
                   to compute limits.
   limit  : float  used to compute the min, max values to keep.see below
KEYWORDS:
   median :        if set then remove a median filtered version of data
                   before cumfiltering.
   correct:        if set then replace the bad data. If median not set then
                   replace bad data with the median of the entire dataset. If
                   median set then replace bad data with the median filtered 
                   version of the original data (filter len=16).
RETURNS:
indxgood[]: long  indices into data for ok data .
indxbad[] : long  indices into data for data that should be filtered out.
countbad  : long  number of elements in indxbad.          

DESCRIPTION:
   This is carl heiles' cumfilter routine. The basic idea is how to 
define reasonable limits for clipping bad data when there may be
large outliers and you don't know the distribution. The algorithm sorts
the data and then uses a range about the center to define the limits:

original data:
   data[n]
sorted data:
   sdata=sort(data)
find the hi , low value of the data set "range" elements about the
center.
   low =sdata[n/2-range/2]
   high=sdata[n/2+range/2]
set the limits of "ok" DATA to be "limit" times this low,high.
   min=limit*low 
   max=limit*high
all points with values  between min,max are ok..

If the median keyword is set, we median filter (filter length=16) the
data set and remove this filtered version from the original data before
cumfiltering ( eg: data=data - median(data,16)).

If the correct keyword is set, then the bad data points are replaced by
the median of the data set (no median keyword) or by the median filtered
value for that point (if median keyword is set).

EXAMPLE:
   Compute the total power of a spectrum using cumfiltering.
d[1024] are the spectral channels.
range=1024/4
limit=3
 cumfilter,d,range,limit,indxgood,indxbad,countbad
 tp=mean(d[indxgood])
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/cumfilter.pro)</STRONG><P>
<HR>
 
<A NAME="CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.">
<H2>CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.</H2></A>
<A HREF="#CUMFILTER - CUMFILTER ROUTINE FROM CARL HEILES.
">[Previous Routine]</A>
<A HREF="#DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       CURVEFITPP-phils version of curvefit with a few bug fixes.

 PURPOSE:
       Non-linear least squares fit to a function of an arbitrary 
       number of parameters.  The function may be any non-linear 
       function.  If available, partial derivatives can be calculated by 
       the user function, else this routine will estimate partial derivatives
       with a forward difference approximation.

 CATEGORY:
       E2 - Curve and Surface Fitting.

 CALLING SEQUENCE:
       Result = CURVEFIT(X, Y, Weights, A, SIGMA, FUNCTION_NAME = name, $
                         ITMAX=ITMAX, ITER=ITER, TOL=TOL, /NODERIVATIVE,$
                         CHISQ=CHISQ,FLAMBDASTEP=FLAMBDASTEP,covar=covar,
                         cfplot=cfplot,cfparms,trouble=trouble,halfass=halfass)

 INPUTS:
       X:  A row vector of independent variables.  This routine does
           not manipulate or use values in X, it simply passes X
           to the user-written function.

       Y:  A row vector containing the dependent variable.

  Weights:  A row vector of weights, the same length as Y.
            For no weighting,
                 Weights(i) = 1.0.
            For instrumental (Gaussian) weighting,
                 Weights(i)=1.0/sigma(i)^2
            For statistical (Poisson)  weighting,
                 Weights(i) = 1.0/y(i), etc.

       A:  A vector, with as many elements as the number of terms, that 
           contains the initial estimate for each parameter.  IF A is double-
           precision, calculations are performed in double precision, 
           otherwise they are performed in single precision. Fitted parameters
           are returned in A.

 KEYWORDS:
       FUNCTION_NAME:  The name of the function (actually, a procedure) to 
       fit.  IF omitted, "FUNCT" is used. The procedure must be written as
       described under RESTRICTIONS, below.

       ITMAX:  Maximum number of iterations. Default = 20.
       ITER:   The actual number of iterations which were performed
       TOL:    The convergence tolerance. The routine returns when the
               relative decrease in chi-squared is less than TOL in an 
               interation. Default = 1.e-3.
       CHI2:   The value of chi-squared on exit (obselete)
     
       CHISQ:   The value of reduced chi-squared on exit
       NODERIVATIVE:   IF this keyword is set THEN the user procedure will not
               be requested to provide partial derivatives. The partial
               derivatives will be estimated in CURVEFIT using forward
               differences. IF analytical derivatives are available they
               should always be used.
pjp  flambdastep: This method moves between a steepest descent and the
               inverse hessian method (using the curvature matrix to 
               compute the answer when we are close to the solution).
pjp  trouble   : 0 converged ok
                -1 chisq infinite
                -2 flambdacount > 30 * 10/flambdastep
                -3 iteration > itermax .default 20
                -4 alpha/c not finite
pjp  nostop    : if set then don't stop if alpha/c not finite, just return
				  with trouble set
pjp  halfass   : 0..1. multiply step by this amount to slow down motion
pjp  cfparms   : if set then print parameters input to fit
pjp  cfplot    : 0 no plot, 
                 1 plot no wait
                 2 plot  wait at last on fit
                 3 plot  wait each one

 OUTPUTS:
       Returns a vector of calculated values.
       A:  A vector of parameters containing fit.

 OPTIONAL OUTPUT PARAMETERS:
       Sigma:  A vector of standard deviations for the parameters in A.

 COMMON BLOCKS:
       NONE.

 SIDE EFFECTS:
       None.

 RESTRICTIONS:
       The function to be fit must be defined and called FUNCT,
       unless the FUNCTION_NAME keyword is supplied.  This function,
       (actually written as a procedure) must accept values of
       X (the independent variable), and A (the fitted function's
       parameter values), and return F (the function's value at
       X), and PDER (a 2D array of partial derivatives).
       For an example, see FUNCT in the IDL User's Libaray.
       A call to FUNCT is entered as:
       FUNCT, X, A, F, PDER
 where:
       X = Variable passed into CURVEFIT.  It is the job of the user-written
           function to interpret this variable.
       A = Vector of NTERMS function parameters, input.
       F = Vector of NPOINT values of function, y(i) = funct(x), output.
       PDER = Array, (NPOINT, NTERMS), of partial derivatives of funct.
               PDER(I,J) = DErivative of function at ith point with
               respect to jth parameter.  Optional output parameter.
               PDER should not be calculated IF the parameter is not
               supplied in call. IF the /NODERIVATIVE keyword is set in the
               call to CURVEFIT THEN the user routine will never need to
               calculate PDER.

 PROCEDURE:
       Copied from "CURFIT", least squares fit to a non-linear
       function, pages 237-239, Bevington, Data Reduction and Error
       Analysis for the Physical Sciences.  This is adapted from:
       Marquardt, "An Algorithm for Least-Squares Estimation of Nonlinear
       Parameters", J. Soc. Ind. Appl. Math., Vol 11, no. 2, pp. 431-441,
       June, 1963.

       "This method is the Gradient-expansion algorithm which
       combines the best features of the gradient search with
       the method of linearizing the fitting function."

       Iterations are performed until the chi square changes by
       only TOL or until ITMAX iterations have been performed.

       The initial guess of the parameter values should be
       as close to the actual values as possible or the solution
       may not converge.

pjp Notes: This method moves between a steepest descent (move in the
           direction of decreasing chisq using the gradient of chisq
           with respect to the ai) and the
               inverse hessian method (using the curvature matrix to 
               compute the answer when we are close to the solution).
           The value Lambda added to the diagonol elements of the
           hessian matrix moves you between these 2 modes. When 
           lambda is large then the diagonal elements become dominant
           and the motion matrix solution is just the gradient motion.
           When lambda becomes small then the of diagonal terms become
           important and you are solving the curvature matrix.
       flambdastep determines how fast you move between these two
       solution methods. When things get worse, lambda is increased by
       a factor of flambdastep and you move towards the linear descent.
       when things get better, then lambda decreases by flambdastep and
       you move towards solving the curvature matrix.
   
       note that in both instances the input data array is the
       difference between the input data and the current fit value.
   
   NOTATION;
       let i=0-npts-1
       let m=0-nparams
       delta:i = y(i) - yfit(i)   i=0,npts-1
       pder:i,m= dByda:m  at y(i)
       alpha = transpose(pder) # ((Weights # (fltarr(nterms)+1))*pder)
       alpha:m,n=  sum:i( pder:m,i * ( 1/sig^2:i * pder:i,n)
       so this is the hessian matrix with sig^2 included..
       beta:m  = sum:i(delta:i # pder:i,m) linear step for correction

                 sum deriv of each a:m over all y(i)i
       alpha is the hessian matrix
       b=beta is the current error in the fit.

 EXAMPLE:  Fit a function of the form f(x) = a * exp(b*x) + c to
           sample pairs contained in x and y.
           In this example, a=a(0), b=a(1) and c=a(2).
           The partials are easily computed symbolicaly:
           df/da = exp(b*x), df/db = a * x * exp(b*x), and df/dc = 1.0

           Here is the user-written procedure to return F(x) and
           the partials, given x:

       pro gfunct, x, a, f, pder      ; Function + partials
         bx = exp(a(1) * x)
         f= a(0) * bx + a(2)         ;Evaluate the function
         IF N_PARAMS() ge 4 THEN $   ;Return partials?
         pder= [[bx], [a(0) * x * bx], [replicate(1.0, N_ELEMENTS(f))]]
       end

         x=findgen(10)                  ;Define indep   dep variables.
         y=[12.0, 11.0,10.2,9.4,8.7,8.1,7.5,6.9,6.5,6.1]
         Weights=1.0/y            ;Weights
         a=[10.0,-0.1,2.0]        ;Initial guess
         yfit=curvefit(x,y,Weights,a,sigma,function_name='gfunct')
         print, 'Function parameters: ', a
         print, yfit
       end

 MODIFICATION HISTORY:
       Written, DMS, RSI, September, 1982.
       Does not iterate IF the first guess is good.  DMS, Oct, 1990.
       Added CALL_PROCEDURE to make the function's name a parameter.
              (Nov 1990)
       12/14/92 - modified to reflect the changes in the 1991
            edition of Bevington (eq. II-27) (jiy-suggested by CreaSo)
       Mark Rivers, U of Chicago, Feb. 12, 1995
           - Added following keywords: ITMAX, ITER, TOL, CHI2, NODERIVATIVE
             These make the routine much more generally useful.
           - Removed Oct. 1990 modification so the routine does one iteration
             even IF first guess is good. Required to get meaningful output
             for errors. 
           - Added forward difference derivative calculations required for 
             NODERIVATIVE keyword.
           - Fixed a bug: PDER was passed to user's procedure on first call, 
             but was not defined. Thus, user's procedure might not calculate
             it, but the result was THEN used.

      Steve Penton, RSI, June 1996.
            - Changed SIGMAA to SIGMA to be consistant with other fitting 
              routines.
            - Changed CHI2 to CHISQ to be consistant with other fitting 
              routines.
            - Changed W to Weights to be consistant with other fitting 
              routines.
            _ Updated docs regarding weighing.
           
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/curvefitpp.pro)</STRONG><P>
<HR>
 
<A NAME="DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH">
<H2>DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH</H2></A>
<A HREF="#CURVEFITPP-PHILS VERSION OF CURVEFIT WITH A FEW BUG FIXES.
">[Previous Routine]</A>
<A HREF="#DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
daynotodm - convert daynumber to day,month

SYNTAX: [day,month]=daynotodm(daynum,year)
ARGS:
       daynum: int/long daynumber of year 1..365or 366
      year : int/long  4 digit year
RETURNS:
      [day,month] as a vector. 
DESCRIPTION
   convert daynumber and year to day of month (1..31) and 
month of year (1.l12).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/daynotodm.pro)</STRONG><P>
<HR>
 
<A NAME="DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY">
<H2>DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY</H2></A>
<A HREF="#DAYNOTODM - CONVERT DAYNUMBER TO DAY,MONTH">[Previous Routine]</A>
<A HREF="#DBIT - CONVERT TO DB'S">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
daynotojul - convert daynumber,year to julday

SYNTAX: julday=daynotojul(dayno,year)
ARGS:
 dayno[n]: int/long/double daynumber of year 1..365or 366
  year[n]: int/long  4 digit year
KEYWORDS:
 gmtoffHr: double   offset from gmt for dayno,year. gmtOffHr/24. will
				     be added to the computed julian days. Probably best
				     used when dayno id double or float.
RETURNS:
      julday[n]:double julian day. This starts at noon
DESCRIPTION
   convert daynumber and year to julian daynumber with fraction of day.
Method:
 1. loop for each year.
	a. take the first day of the year (day1), convert it to long (iday).
	b. convert iday1 to julianday
   c. for all the data of the year juldayYr=julday1 + day-iday1
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/daynotojul.pro)</STRONG><P>
<HR>
 
<A NAME="DBIT - CONVERT TO DB'S">
<H2>DBIT - CONVERT TO DB'S</H2></A>
<A HREF="#DAYNOTOJUL - CONVERT DAYNUMBER,YEAR TO JULDAY
">[Previous Routine]</A>
<A HREF="#DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dbit - convert to db's
 
SYNTAX: a=dbit(b,minval=minval)

ARGS:        b[]:input value
KEYWORDS: minval: float.. all values < this set to minval before log
RETURNS:     a[]: b in db's
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dbit.pro)</STRONG><P>
<HR>
 
<A NAME="DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.">
<H2>DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.</H2></A>
<A HREF="#DBIT - CONVERT TO DB'S">[Previous Routine]</A>
<A HREF="#DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
delpath - remove pathname from the path variable.
SYNTAX: delpath, path
ARGS:  
   path : string complete pathname to delete from the !path variable.
                 It must match how it appears in the !path variable.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/delpath.pro)</STRONG><P>
<HR>
 
<A NAME="DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.">
<H2>DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.</H2></A>
<A HREF="#DELPATH - REMOVE PATHNAME FROM THE PATH VARIABLE.
">[Previous Routine]</A>
<A HREF="#
DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dms1_deg - convert ddmmss.sss as a double to degrees.
SYNTAX: angDeg=dms1_deg(ddmmss)
ARGS:
   ddmmss: double value to convert
RETURNS:
   angdeg: double the angle converted to degrees.
DESCRIPTION
 Convert packed degrees, minutes, seconds to degrees.
The input is a single double with ddmmss.ss with dd degrees, mm minutes,
ss.s seconds.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dms1_deg.pro)</STRONG><P>
<HR>
 
<A NAME="DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS
">
<H2>DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS
</H2></A>
<A HREF="#DMS1_DEG - CONVERT DDMMSS.SSS AS A DOUBLE TO DEGREES.
">[Previous Routine]</A>
<A HREF="#DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dms1_dms3 - convert deg,min,secs 1 word to deg,min,sec separate words
SYNTAX - ret=dms1_dms3(hhmmss)
ARGS: 
	ddmmss : double angle to convert
RETURNS:
	ret[4] : double deg,min,sec, and sign 

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dms1_dms3.pro)</STRONG><P>
<HR>
 
<A NAME="DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.">
<H2>DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.</H2></A>
<A HREF="#
DMS1_DMS3 - CONVERT DEG,MIN,SECS 1 WORD TO DEG,MIN,SEC SEPARATE WORDS
">[Previous Routine]</A>
<A HREF="#DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dms1_rad - convert ddmmss.sss as a double to radians.  
SYNTAX: angRad=dms1_rad(ddmmss)
ARGS:
	ddmmss: double value to convert
RETURNS:
	angRad: double the angle converted to radians.	
DESCRIPTION
 Convert packed deg, minutes, seconds to radians.
The input is a single double with ddmmss.ss with dd deg, mm minutes,
ss.s seconds.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dms1_rad.pro)</STRONG><P>
<HR>
 
<A NAME="DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER">
<H2>DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER</H2></A>
<A HREF="#DMS1_RAD - CONVERT DDMMSS.SSS AS A DOUBLE TO RADIANS.
">[Previous Routine]</A>
<A HREF="#DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dmtodayno - convert day,mon,year to daynumber

SYNTAX: daynum=dmtodayno(day,mon,year)
ARGS:
       day : int/long day of month
      mon  : int/long month of year 1..12
      year : int/long  4 digit year

RETURNS:
      daynum: int/long  daynumber of year. First day of year is 1.

DESCRIPTION:
   Convert from dayofmonth, month , and year to daynumber of year.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dmtodayno.pro)</STRONG><P>
<HR>
 
<A NAME="DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD">
<H2>DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD</H2></A>
<A HREF="#DMTODAYNO - CONVERT DAY,MON,YEAR TO DAYNUMBER
">[Previous Routine]</A>
<A HREF="#DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dmytoyymmdd - convert ddMonyy to yymmdd

SYNTAX: yymmdd=ddmytoyymmdd(ddMONyy)
ARGS:
       ddMONyy: string convert 10mar02 to 020210 etc..
RETURNS:
        yymmdd: long return 0 if bad format..
		  
DESCRIPTION
   The datataking files use ddMONyy in the name where dd is the day
of the month, MON is a 3 letter abbreviation for the name,
and yy is the last two digits of the year. This routine will
convert the value into a long yymmdd 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dmytoyymmdd.pro)</STRONG><P>
<HR>
 
<A NAME="DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS">
<H2>DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS</H2></A>
<A HREF="#DMYTOYYMMDD - CONVERT DDMONYY TO YYMMDD">[Previous Routine]</A>
<A HREF="#EXPLAIN - LIST DOCUMENTATION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
dotprod - compute the dot product of two vectors
SYNTAX: val=dotprod(v1,v2)
ARGS:
       v1[m] : vector
       v2[m] : vector
returns:
       val
DESCRIPTION:
 return val=total(v1*v2)

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/dotprod.pro)</STRONG><P>
<HR>
 
<A NAME="EXPLAIN - LIST DOCUMENTATION">
<H2>EXPLAIN - LIST DOCUMENTATION</H2></A>
<A HREF="#DOTPROD - COMPUTE THE DOT PRODUCT OF TWO VECTORS
">[Previous Routine]</A>
<A HREF="#FIGNUM - PUT FIGURE NUMBER ON THE PAGE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
explain - list documentation
SYNTAX: explain,{subject_document or routine_name}

ARGS:
 None   :         If no arguments, display the list of subject documents.
 namedoc:string   If namedoc is provided then display the documentation
                  for this subject. It will be a list of routine names
                  with 1 line descriptions (eg cordoc) or a just a list
                  of the routine names (cordocnames).
routine :string   If the name of a routine is entered, display the
                  complete documentation for the routine.
EXAMPLES:
   explain             - list the topics available
   explain,cordoc      - 1 line description of the correlator routines.
   explain,cordocnames - list the names of all of the correlator routines.
   explain,corplot     - list the documentation for corplot.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/explain.pro)</STRONG><P>
<HR>
 
<A NAME="FIGNUM - PUT FIGURE NUMBER ON THE PAGE">
<H2>FIGNUM - PUT FIGURE NUMBER ON THE PAGE</H2></A>
<A HREF="#EXPLAIN - LIST DOCUMENTATION">[Previous Routine]</A>
<A HREF="#FILE_EXISTS - CHECK IF A FILE NAME EXISTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fignum - put figure number on the page

SYNTAX: nextnum=fignum(fnum,xp=xp,ln=ln)
ARGS  : 
       fnum    : int   figure number to put on plot. 1..
KEYWORDS:
       xp      : float 0..1 xposition for start of FIG N
       ln      : int   3..33 linenumber for FIG N
RETURNS:
       nextnum : int   input value incremented by 1

DESCRIPTION:
   fignum() will place the string FIG fnum on the plot for you. The 
horizontal position defaults to .92 of the screen (where the screen goes
 0..1 horizontally). The vertical position is set  to 3 where the vertical
screen runs 0 through 33.

NOTE:  
   the vertical line numbers are for the entire screen. If you use !p.multi
then you will have to decrease ln= by the corresponding amount.

SEE ALSO: note
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fignum.pro)</STRONG><P>
<HR>
 
<A NAME="FILE_EXISTS - CHECK IF A FILE NAME EXISTS">
<H2>FILE_EXISTS - CHECK IF A FILE NAME EXISTS</H2></A>
<A HREF="#FIGNUM - PUT FIGURE NUMBER ON THE PAGE">[Previous Routine]</A>
<A HREF="#FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
file_exists - check if a file name exists
SYNTAX:  stat=file_exists(filename,fullname,dir=dir,size=size)
ARGS  :  
   filename: string filename to search for
KEYWORDS:
   dir[]:  string  if supplied then search through these directories
  size  :          if supplied then return the file size in bytes
                   if it exists.

RETURNS:
   stat  : 1 file found, 0 not found
 fullname: full directory/filename where file was found
     size: if keyword size supplied then return the number of bytes in the
           file

DESCRIPTION:
   Check if a file exists. Return 1 if it does, 0 if it doesn't. Also return
the fully qualified name where the file was found.

   If keyword dir is supplied then search through all of the directories
in the string array dir. In this case filename should not contain a 
directory path.
   
   This routine is handy to search for the location of an online datafile.
They start in /share/olcor/ but get moved to /proj/projid/ directories
at some later point.

EXAMPLE:
   
   istat=file_exists('/share/olcor/corfile.13aug02.x101.1',fullname)

   dir=['/share/olcor/','/proj/x101cor/']
   istat=file_exists('corfile.13aug02.x101.1',fullname,dir=dir)

NOTE: this routine will only find regular files, a
      directory name will return a non-existant file.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/file_exists.pro)</STRONG><P>
<HR>
 
<A NAME="FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS">
<H2>FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS</H2></A>
<A HREF="#FILE_EXISTS - CHECK IF A FILE NAME EXISTS">[Previous Routine]</A>
<A HREF="#FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fisecmidhms3 - secs from midnite to hh:mm:ss
SYNTAX: label=fisecmidhms3(secsMidnite,hour,min,sec,float=float)
ARGS:
   secsMidnite:    long  seconds from midnite to format.
KEYWORD:
	float:			if set then return secs at float

RETURNS:
   hour:   long    hour of day.
    min:   long    minute of hour.
    sec:   long    sec of hour.
    lab:  string   formatted string: hh:mm:ss

DESCRIPTION:
   Convert seconds from midnight to hours, minutes, seconds and then
return a formatted string hh:mm:ss. The 2 digit numbers are 0 filled to the
left. If the input data is float/double, it is first converted to long.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fisecmidhms3.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE">
<H2>FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE</H2></A>
<A HREF="#FISECMIDHMS3 - SECS FROM MIDNITE TO HH:MM:SS">[Previous Routine]</A>
<A HREF="#FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazza - fit function to azimuth and zenith angle
SYNTAX: fitazza,az,za,y,fitI,weights=weights,fittype=fittype,
                yfit=yfit,covar=covar,variance=variance,sigmaA=sigmaA,
                singular=singular,chisq=chisq
ARGS:
       az[npts]    : float  azimuth in deg
       za[npts]    : float  za in deg
        y[npts]    : float  data to fit
KEYWORDS:
     weights[npts] : weights to use with fit. default = 1.
       fittype     : int. 1..4 see below
RETURNS:
         fitI      : {azzafit} structure. return fitinfo here.
       yfit[npts]  : fit values evaluated at input az,za returne here
       covar[m,m]  : normalized covariance matrix. m=# of coef.
    variance[m]    : of the diagnonal elements (not normalized)
      sigmaA[m]    : sigmas of the coef (not normalized)
       singular    : int, number of singular coef found.
         chisq     : float. chisq
DESCRIPTION:
   There are 4 or 10 coefficients in the fit. The functional form depends
 on the value of fittype.
 fittype: coef: 0-3
 1:  c0 + c1*za + c2(za-14)^2 + c3(za-14)^3 + azterms.. use za-14 when za gt 14
 2:  c0 + c1*(za-10) + c2(za-10)^2+c3(za-10)^3 + azterms. for all za
 3:  y=(za-10)/10 then
     c0 +c1*(y)+ c2*(2*y*y-1.) + c3*(4*y^3-3*y) + azterms. for all za
 4:  c0 +c1*za +c2*(za-14)^2 +c3*(za-14)^3 no azterms.. use za-14 when za gt 14
 5:  c0 + c1*(za-10) + c2(za-10)^2+c3*(za-10)^3+
       costerm have 1az,3az and sinza*3az.. no 2az term	
 6:  c0 + c1*(za-10) + c2(za-10)^2+c3(za-10)^3  no az terms

 coef: 4-9
 az terms:
  c4*cos(az)  +c5*sin(az) + c6*cos(2az) + c7*sin(2az) 
  c8*cos(3az) +c9*sin(3az)

 The fit info is returned in the fit structure {azzafit}. It contains:

            numCoef:        10L    , for fit
            fittype:         1     , 1-def,2-about za10,3-chebyshev 3rd order
            freq   :         0.    , Mhz
             coef  :     dblarr(10),coef.
         sigmaCoef :     dblarr(10), sigmas on each coef.
             covar :  dblarr(10,10), covariance matrix
            chisq  :         0.D   , of fit
           sigma   :         0.D   , of fit - data
           zaSet   :        14.    , za cutoff for higher order,or pivot
            rfNum  :         0     , rcv num
             pol   :         ' '   ,  a ,  b , i  stokes I
            type   :         ' '   ,gain,sefd,tsys,etc..
           title   :         ' '   , for any plots top
           ytitle  :         ' '   , for any plots left
           date    :         ' '     fit run

Since the fittype is returned in the structure, later routines (fitazzaeval
etc..) know which functional form to use.
You must call @geninit once before calling this routine to define the
{azzafit} structure.
SEE ALSO:
fitazzaeval, fitazzapr, fitazzaplres, fitazzaprcov
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazza.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.">
<H2>FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.</H2></A>
<A HREF="#FITAZZA - FIT FUNCTION TO AZIMUTH AND ZENITH ANGLE
">[Previous Routine]</A>
<A HREF="#FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazzaeval - evaluate the fitazza fit at az,za positions.
SYNTAX: val=fitazzaeval(az,za,fitI,azonly=azonly,zaonly=zaonly)
ARGS:
   az[n]   : float azimuth positions to evaluate fit.
   za[n]   : float zenith angle positions to evaluate fit.
  fitI     :{fitazza} fit info returned from fitazza.
KEYWORDS:
   azonly:   if set then only evaluate the az terms of the fit.
   zaonly:   if set then only evaluate the za terms of the fit.
DESCRIPTION:
   fitazza() will do a fit to data points as a function of azimuth and
 zenith angle. This routine will allow you to evaluate that fit at
 any az,za you want. The azonly, zaonly keywords limit the evaluation
 to only the az or za terms of the fit.
SEE ALSO:
 fitazza
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazzaeval.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE">
<H2>FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE</H2></A>
<A HREF="#FITAZZAEVAL - EVALUATE THE FITAZZA FIT AT AZ,ZA POSITIONS.
">[Previous Routine]</A>
<A HREF="#FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazzalog - write fitazza info in tabular form to a file
SYNTAX: fitazzalog,fitI,lun,calval,calval2,title=title
ARGS  :
       fitI:   {azzafit} structure holding info returned from fitazza.
        lun:  int    the lun open to the file for output.
     calval:  float  the cal value that was used in the fit.
     calval2: float  2nd cal value if fit was to stokes I
KEYWORDS:
        title:   string, title to write in file.
DESCRIPTION
   Print out the fit values returned from fitazza in tabular form to a file.
You should open the file for write access (maybe append if you don't 
want to overwrite the file).
SEE ALSO:
fitazza, fitazzapr, fitazzaeval
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazzalog.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT">
<H2>FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT</H2></A>
<A HREF="#FITAZZALOG - WRITE FITAZZA INFO IN TABULAR FORM TO A FILE
">[Previous Routine]</A>
<A HREF="#FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazzaplres - plot residuals from az,za fit
SYNTAX: fitazzaplres,az,za,y,fitI,tit=tit,key=key,sbc=sbc,sym=sym
ARGS:
       az[npts] : float azimuth positions used for fit
       za[npts] : float za positions used for fit
  y[2,nsbc,npts]: float raw data used for fit pola,polB 
       fitI[2,nsbc] : {azzafit} returned from fitazza
KEYWORDS:
       key      : int  key=1 residuals by sample
                           2 residuals by  za
                           default both
       tit     : string title of plot
       sbc     : int   sbc to plot 0-3. default all
       sym[2]  : int   symbols for pola, b def.. none 
DESCRIPTION:
   Plot the residuals from the az,za fit. The routine assumes that
you have fit the polA and polB data for a number of subcorrelators.
It is the callers responsibility to move the fitI single structure into
the array of structures passed into this routine.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazzaplres.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT">
<H2>FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT</H2></A>
<A HREF="#FITAZZAPLRES - PLOT RESIDUALS FROM AZ,ZA FIT">[Previous Routine]</A>
<A HREF="#FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazzapr - print/plot info on the az,za fit 
SYNTAX: fitazzapr,fitI,over=over,ln=ln,sclln=sclln,nocoef=nocoef,tit=tit,$
                  nosigma=nosigma,noplot=noplot,plterms=plterms,$
                  plcomb=plcomb,xoff=xoff,_extra=e,azreq=azreq,zareq=zareq,
				   xp=xp
ARGS  :
       fitI:   {azzafit} structure holding info returned from fitazza.
KEYWORDS:
       over:   int, if set then overplot
         ln:   int, line # to start printing fit values . def= 3
      sclln:   float scale spacing between lines. default=1.
     nocoef:   int, if set, then don't bother to print fit coef.
     nosigma:       if set then don't output sigma For coeff.
                    they aren't meaningfull unless you specified weights
     noplot :       if set then don't do the line plot, just print the values.
        tit:   string, title for plot
     plterms:  0 - plot az terms
               1 - plot za terms
               2 - plot all terms versus az
               3 - plot all terms versus za
     plcomb:  if set then plot the combined fit rather than overplotting
              each term (only makes a difference for az terms).
     xoff  :  float offset to add to default az or za before evaluating
                    the fit (overplot does not lay on top of previous plot).
     _extra:   keyword=value. passed to plot,oplot routines.
                   (eg.. psym=2 to just plot symbols)
     azreq[] : float azimuth values (deg) to compute fit at.
     zareq[] : float za values (deg) to compute fit at.
          xp : float xposition (0 to 1) for text (def .05)
DESCRIPTION
   Print out the fit values returned from fitazza. Output to the terminal
and plot to a plotfile. 
   The default output is to plot the individual azimuth terms versus
az. The program will by default evaluate the fit at fixed azimuth and
za values. You can use azreq zareq to evaluate it at different values
(if you specify plterms=2,3 and you want to use azreq,zareq then you
must provide both values).
EXAMPLE:
f(za):  9.16089 +( 0.77126)*za +(-0.06284)*(za-14)^2 +( 0.06741)(za-14)^3
f(1az):  0.54982*cos(1az) + (-1.85612)*sin(1az)
f(2az):  1.30097*cos(2az) + ( 0.69671)*sin(2az)
f(3az):  0.86003*cos(3az) + ( 1.33455)*sin(3az)
SigCof: za  0.25757 0.02781 0.08049 0.01504
        az  0.18664 0.14984 0.17228 0.17435 0.16076 0.14014
 
 f(za): ffffffff +(ffffffff)*za +(ffffffff)*(za-14)^2 +(ffffffff)(za-14)^3
f(1az): ffffffff*cos(1az) + (ffffffff)*sin(1az)
f(2az): ffffffff*cos(2az) + (ffffffff)*sin(2az)
f(3az): ffffffff*cos(3az) + (ffffffff)*sin(3az)
SigCof:az f8.5 f8.5 f8.5 f8.5   
       za f8.5 f8.5 f8.5 f8.5 f8.5 f8.5
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazzapr.pro)</STRONG><P>
<HR>
 
<A NAME="FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX">
<H2>FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX</H2></A>
<A HREF="#FITAZZAPR - PRINT/PLOT INFO ON THE AZ,ZA FIT">[Previous Routine]</A>
<A HREF="#FITNGAUSS - FIT N GAUSSIANS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitazzaprcov - print out the covariance matrix
SYNTAX, fitazzaprcov,fiti,fd
ARGS:
   fitI:   {fitazza} returned from fitazza
     fd:   int write the data to this file descriptor. Default is stdout.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitazzaprcov.pro)</STRONG><P>
<HR>
 
<A NAME="FITNGAUSS - FIT N GAUSSIANS">
<H2>FITNGAUSS - FIT N GAUSSIANS</H2></A>
<A HREF="#FITAZZAPRCOV - PRINT OUT THE COVARIANCE MATRIX
">[Previous Routine]</A>
<A HREF="#FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitngauss - fit n gaussians
SYNTAX: coef=fitngauss(x,y,ngauss,coefInit,chisq=chisq,sigmaCoef=sigmaCoef,
                       weights=weights,yfit=yfit,covar=covar,trouble=trouble)
ARGS:
   x[npts]:    inpependent data
   y[npts]:    dependent data
   ngauss :    int the number of gaussians to fit for 1 to 3
   coefInit[m] initial values for coef.
KEYWORDS:
   weights[npts] : for data. default is unity
   trouble       : int    0 converged ok
                         -1 chisq infinite
                         -2 flambdacount > max=30 *10/flambdaste
                         -3 iterdone >itmax(def 20)
                         -4 divide by zero on partials
 _extra=e
       cfplot    : if set, then curveFit will plot each strip
       cfparms   : if set, then curveFit will print input parms
   flambdastep   : float. how much we decrease step curvature matrix when
   tol           : float. when chisq decreases by this amount, done..def:.001
   itmax         : int..  iterations max. default:40

RETURNS   :
       coef[m]     fit coef..
keywords:
       yfit[npts]: fit evaluated at input values
       chisq     : double (y-yfit)^2/(npts-mcoef)
       sigmaCoef[m]:formal errors in coef. sqrt(diag of matrix*chisq)
       covar[m,m]  : covariance matrix
DESCRIPTION:
   fit the function:
   y= a0 +a1*x + a3*exp[(x-a4)^2/a5*(1+alpha*x) +
                 a6*exp((x-a7)^2/a8 +
                 a9*exp((x-a10)^2/a11
 a0= constant
 a1= linear in x
 a2= alpha  skew first gaussian
 a3=Ampl
 a4=Mean (offset error)
 a5=sigma   input as fwhm in units of x

 a6=Ampl
 a7=Mean
 a8=sigma     input as fwhm

 a9=Ampl
 a10=Mean
 a11=sigma input as fwhm
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitngauss.pro)</STRONG><P>
<HR>
 
<A NAME="FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS">
<H2>FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS</H2></A>
<A HREF="#FITNGAUSS - FIT N GAUSSIANS">[Previous Routine]</A>
<A HREF="#FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 fitngaussfunc - function for fitting n gaussians
 SYNTAX:
   fitngaussfunc,x,a,f,pder

 ARGS:
    x[npts]          : independant variable
    a[2+4*ngauss]    : parameters to fit for
    f[npts] : return value of function here
    pder[2+4*ngauss] :return partial derivatives with respect to each param

 DESCRIPTION:
  evaluate the function and optionally it's partial derivatives
  for the curvefit routine of idl:

  f(x)= a0 + a1*x + a3*exp[ (x-a4)**2 * (1+a2*(x-a4))]
                             -------------------- + n more gaussians
                               a5^2
 a0= constant
 a1= linear in x
 a2=skew first gaussian
 a3=Ampl
 a4=Mean
 a5=sigma

 a6=Ampl
 a7=Mean
 a8=sigma

 a9=Ampl
 a10=Mean
 a11=sigma

 note that we are fitting for sigx  not sigx^2
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitngauss.pro)</STRONG><P>
<HR>
 
<A NAME="FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)">
<H2>FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)</H2></A>
<A HREF="#FITNGAUSSFUNC - FUNCTION FOR FITTING N GAUSSIANS
">[Previous Routine]</A>
<A HREF="#FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitngaussnc - fit n gaussians (no coma)
SYNTAX: coef=fitngaussnc(x,y,ngauss,coefInit,chisq=chisq,sigmaCoef=sigmaCoef,
                       weights=weights,yfit=yfit,covar=covar,trouble=trouble,
                       
ARGS:
   x[npts]:    inpependent data
   y[npts]:    dependent data
   ngauss :    int the number of gaussians to fit for 1 to 3
   coefInit[m] initial values for coef.
KEYWORDS:
   weights[npts] : for data. default is unity
   trouble       : int    0 converged ok
                         -1 chisq infinite
                         -2 flambdacount > max=30 *10/flambdaste
                         -3 iterdone >itmax(def 20)
                         -4 divide by zero on partials
 _extra=e
       cfplot    : if set, then curveFit will plot each strip
       cfparms   : if set, then curveFit will print input parms
   flambdastep   : float. how much we decrease step curvature matrix when
   tol           : float. when chisq decreases by this amount, done..def:.001
   itmax         : int..  iterations max. default:40
   iter          : int..  iterations done.
   noderiv       : if set then have let the routine compute the derivatives
                   from differences rather than from the analytic formula.

RETURNS   :
       coef[m]     fit coef..
keywords:
       yfit[npts]: fit evaluated at input values
       chisq     : double (y-yfit)^2/(npts-mcoef)
       sigmaCoef[m]:formal errors in coef. sqrt(diag of matrix*chisq)
       covar[m,m]  : covariance matrix
DESCRIPTION:
   fit the function:
   y= a0 +a1*x + a3*exp[(x-a4)^2/a5 +
                 a6*exp((x-a7)^2/a8 +
                 a9*exp((x-a10)^2/a11
 where:
 a0= constant
 a1= linear in x
 a2=Ampl      1st gaussian
 a3=Mean (offset error)
 a4=sigma   input as fwhm in units of x

 a5=Ampl      2nd guassian 
 a6=Mean
 a7=sigma     input as fwhm

 a8 =Ampl     3rd gaussian
 a9 =Mean
 a10=sigma input as fwhm

   The variable ngauss determines how many gaussians to fit for. This
routine is similar to fitngauss but it does not have the coma
 parameter (which tends to diverge).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitngaussnc.pro)</STRONG><P>
<HR>
 
<A NAME="FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS">
<H2>FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS</H2></A>
<A HREF="#FITNGAUSSNC - FIT N GAUSSIANS (NO COMA)">[Previous Routine]</A>
<A HREF="#FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 fitngaussncfunc - function for fitting n gaussians
 SYNTAX:
   fitngaussncfunc,x,a,f,pder

 ARGS:
    x[npts]          : independant variable
    a[2+3*ngauss]    : parameters to fit for
    f[npts] : return value of function here
    pder[2+3*ngauss] :return partial derivatives with respect to each param

 DESCRIPTION:
  evaluate the function and optionally it's partial derivatives
  for the curvefit routine of idl:

  f(x)= a0 + a1*x + a2*exp[ (x-a3)**2 )]
                             -------------------- + n more gaussians
                               a4^2
 a0= constant
 a1= linear in x
 a2=Ampl
 a3=Mean
 a4=sigma

 a5=Ampl
 a6=Mean
 a7=sigma

 a8=Ampl
 a9=Mean
 a10=sigma

 note that we are fitting for sigx  not sigx^2
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitngaussnc.pro)</STRONG><P>
<HR>
 
<A NAME="FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.">
<H2>FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.</H2></A>
<A HREF="#FITNGAUSSNCFUNC - FUNCTION FOR FITTING N GAUSSIANS
">[Previous Routine]</A>
<A HREF="#FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitsin - fit to Asin(Nx-phi) where N=1 to 6.
SYNTAX:result=fitsin(x,y,N)
ARGS:
       x  - independent var. (x values for fit). should already be in radians
       y  - measured dependent variable.
       N  - 1..6 .. integral  period to fit . 1 to 6.
RETURN:
   result[]: float
            [0] constant coefficient
            [1] amplitude
            [2] phase in radians
DESCRIPTION:
   Do a linear least squares fit (svdfit) to a sin wave with integral
values of the frequency (1 through 6 are allowable values). Return
the coefficients of the fit.

NOTES:   
 Asin(Nt-phi)= Asin(Nt)cos(phi) - Acos(Nt)sin(phi) =  Bsin(Nt) + Ccos(Nt)
      B=Acos(phi)
      C=-Asin(phi)
    phi      = atan(sin(phi)/cos(phi))/ = atan(-c,b)
    amplitude=sqrt(B^2+C^2)
 so the fit for B,C is linear.

 result from svd:
  a[0] - constant
  a[1] - sin coef
  a[2] - cos coef
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitsin.pro)</STRONG><P>
<HR>
 
<A NAME="FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN">
<H2>FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN</H2></A>
<A HREF="#FITSIN - FIT TO ASIN(NX-PHI) WHERE N=1 TO 6.">[Previous Routine]</A>
<A HREF="#FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fitsinnl - nonlinear least squares fit to a sin
SYNTAX:   fitsinnl,x,y,weights,a,yfit,chisq,iter,sigma,tol=tol,itmax=itmax
ARGS:
    x[npts]: float  x values. The unit will determine the frequency 
                     unit (eg. sec--> cycle/sec, min--> cycle/min).
    y[npts]: float  measured data values
    a[4]   : float  initial values for fit:
                    a[0] constant,
                    a[1] amplitude
                    a[2] frequency cycles/(xunit)
                    a[3] phase (fraction of a cycle)
weights[npts]:float weights for each data point
KEYWORDS:
   tol  : float    tolerance for conversion. default 1e-3
   itmax: int      max number of step iterations before non-convergence.
   
RETURNS:
        a     - fitted coefficients
        yfit  - fit value evalutated at x
        chisq - chisq for fit 
        iter  - number of iterations that were made
        sigma[4] - sigmas for each coef.
DESCRIPTION:
   Do a non-linear least squares fit to a sin wave fitting for offset,
amplitude, frequency, and phase. Use the idl routine curvefit().
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fitsinnl.pro)</STRONG><P>
<HR>
 
<A NAME="FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA">
<H2>FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA</H2></A>
<A HREF="#FITSINNL - NONLINEAR LEAST SQUARES FIT TO A SIN
">[Previous Routine]</A>
<A HREF="#FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fluxfitvla - return source flux using vla formula
SYNTAX: flux=fluxfitvla(coef,freq)
ARGS:
   coef[3 or 4]:    float   coefficients for fit.
      freq:    float   Frequency in Mhz.
RETURNS:
      flux:    float  flux in Janskies.

DESCRIPTION:
   Evaluate the function
 
log(s)= coef[0]+coef[1]*log(freq)+coef[2]*(log(freq)^2)

This can be used for the standard calibrators: 3C286,3C48, and 3C147.
You must input the coefficients for each source.
It is taken from the vla calibration manual (chris salters copy
or the web). 
There are no corrections to baars et scale done here.
If number of coef > 3 then the newer fit (circa 1999) will be used
that includes freq^3 term).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fluxfitvla.pro)</STRONG><P>
<HR>
 
<A NAME="FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS">
<H2>FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS</H2></A>
<A HREF="#FLUXFITVLA - RETURN SOURCE FLUX USING VLA FORMULA
">[Previous Routine]</A>
<A HREF="#FLUXSRC - RETURN SOURCE FLUX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fluxkuehr - compute flux given kuehr et al. coefficients
SYNTAX: flux=fluxkuehr(coef,freqMhz)
ARGS:
       coef[4]: float kuehr coefficients .. see below
       freqM  : frequency in Mhz
RETURNS:
       flux   : in janskies
DESCRIPTION:
   Return the flux computed from the kuehr coef..
 (Kuehr et al., A+AS, 45, 367, (1981))
 log10(flux)= coef[0] + coef[1]*x + coef[2]*exp(-coef[3]*x)
 and x=log10(freqMhz)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fluxkuehr.pro)</STRONG><P>
<HR>
 
<A NAME="FLUXSRC - RETURN SOURCE FLUX">
<H2>FLUXSRC - RETURN SOURCE FLUX</H2></A>
<A HREF="#FLUXKUEHR - COMPUTE FLUX GIVEN KUEHR ET AL. COEFFICIENTS
">[Previous Routine]</A>
<A HREF="#FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fluxsrc - return source flux
SYNTAX: flux=(srcname,freq)
ARGS:
   srcname: string source to search for in files.
      freq: float  the frequecy of interest in Mhz.
RETURNS:
   flux:    float The flux in janskies.
DESCRIPTION:
   The file aodefdir()/data/fluxsrc.dat has fits of flux versus frequency
for a number of sources. This routine will return the flux given a
frequency if the source name is in the file.
SEE ALSO:
fluxsrclist, fluxsrcload.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fluxsrc.pro)</STRONG><P>
<HR>
 
<A NAME="FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE">
<H2>FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE</H2></A>
<A HREF="#FLUXSRC - RETURN SOURCE FLUX">[Previous Routine]</A>
<A HREF="#FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fluxsrclist - return list of source names in flux file
SYNTAX: fluxnames=fluxsrclist(print=print,freq=freq,size=size,bnames=bnames,$
                              srclist=srclist,all=all)
ARGS:   none
KEYWORDS:
   print:       if set then print to stdout the source info for the sources
                selected. This inclues the name, coefficients, fit rms, 
                code and comments.
   freq : float frequency in Mhz. If provided then evaluate the flux at
                this frequency for every source returned. Return the
                source names and flux in Janskies.
   all  :       if set then return all available info on each source.
                name (flux if Freq specified) CodeForSrc size/comments
   size :       if set then include any size/comments for the sources
  bnames:       if set only include sources that start with B.
  srclist[]: string If supplied, then only supply info on the sources in
                    this list that also meet the other criteria (bnames..).
RETURNS:
   A string array containing an entry for each source.
   the first entry of every source is the name:
       ret[0,*]= srcname
   if freq keyword is present, the flux at this frequency will
       follow the srcname
       ret[1,*]= flux
   if size keyword is set then any comments will follow the freq (or name
   if no freq requested)
       ret[2,*]= comments  or
       ret[1,*]= comments  (if no freq keyword)

DESCRPTION:
   Return a list of the sources in the flux file (created by chris salter).
If the /print keyword is supplied then the routine will also write the 
source info to stdout.

   By default the source name for all sources is returned. You can modify
what is returned with the following keywords:

   freq:  Evaluates and adds the flux for each source at freq(Mhz).
   size:  adds the size/comments field in the returned data
   all :  returns srcName (flux if frq supplied) code size/comments
 bnames:  Only return sources that start with B. The file has multiple
          names for the same source (J,B, and 3C).
srclist:  instead of searching the entire file, only look at the sources
          in this list.

EXAMPLES:
1.   dat=fluxsrclist()       .. dat[] is a string array of all the sources
     print,dat[0:3]

     B0010+005 3C5 B0017+154 3C9

2.   dat=fluxsrclist(/print) .. the file is also listed to std out:

     prints:
codes:1-good calibrator,2-lousy,3-flux.cat ??
B0010+005 coef: 2.77 -0.82 0.00 rms: 9.00 code:1 ;3C5; Size~27"; Sp(80-5000)

3.   dat=fluxsrclist(freq=1420).. dat[2,*] string array
                                  dat[0,*] holds the source names.
                                  dat[1,*] holds the flux (in Jy) for each src 
                                           at 1420Mhz
     print,dat[*,0:1]
     3C132    3.21
     3C138    9.14

4.   dat=fluxsrclist(freq=1420,/size).. dat is a 2-d string array.
                                dat[0,*] holds the source names.
                                dat[1,*] holds the flux for each source
                                dat[2,*] holds comments for this source
     print,dat[*,0:1]
     3C132    3.21 3C132 C27.6(756)
     3C138    9.14 3C138 Fit to all S's

5.   srclist=['B2223+21','3C138']
     dat=fluxsrclist(freq=1420,/all,srclist=srclist).. dat[4,3] stringarray
     print,dat
     B1607+268    4.47   1 cut-off below 1 GHz
     B1615+212    1.80   1  
     B1622+238    2.63   1 3C336

NOTE:
   1. There are multiple names for the same source in the flux file (eg
      B2314+038,3C459,J2316+040).
   2. The code field is: 1 - good flux calibrator, 2-bad flux calibrator,
                         3 - source from kuehr et al.Chris has not yet
                             tried to fit this source.

The flux file is located at aodefdir()/data/fluxsrc.dat. At AO, aodefdir() is
/pkg/rsi/local/libao/phil/.
SEE ALSO:
   fluxsrc, fluxsrcload.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fluxsrclist.pro)</STRONG><P>
<HR>
 
<A NAME="FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK">
<H2>FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK</H2></A>
<A HREF="#FLUXSRCLIST - RETURN LIST OF SOURCE NAMES IN FLUX FILE
">[Previous Routine]</A>
<A HREF="#FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fluxsrcload - load source flux into common block
SYNTAX: fluxsrcload,retdata,file=file,salter=salter
ARGS:
   retdata[]:{fluxsrc} if supplied, then return all the flux structures
                       in retdata.
KEYWORDS:
   file     : string   filename that holds the source fluxes. Default
                       is aodefdir() + 'data/fluxsrc.dat
   salter   : if set then input file from chris salter's file. This 
              file is used to generate the fluxsrc.dat file. The option
              is used when checking that the files are in sync (see chkflux 
              below).
DESCRIPTION:
   Read in all of the source fluxes from the fluxsrc.dat file into 
the common block fluxcom. The user can optionally specify
another file to use for the source fluxes. 
   The routine fluxsrc() computes fluxes from data in this common block. 
It will automatically call  fluxsrcload() if the common block is not
initialized.

   The routine aodefdir()/data/chkflux.pro is used to keep the two files
in sync (chris's file and fluxsrc.dat).
SEE ALSO:
   fluxsrc(), fluxsrclist()
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fluxsrcload.pro)</STRONG><P>
<HR>
 
<A NAME="FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.">
<H2>FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.</H2></A>
<A HREF="#FLUXSRCLOAD - LOAD SOURCE FLUX INTO COMMON BLOCK
">[Previous Routine]</A>
<A HREF="#FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fwhm2tosig2f - FWHM^2 to sigma^2 factor.
SYNTAX: fac=fwhm2tosig2f()
ARGS:   none
RETURNS:
   fac:    float conversion factor.
DESCRIPTION:
   for a gaussian defined as:
   y=A0*exp( -[(x-x0)/sig]^2) 
   convert full width half max squared to sigma squared.
 If the gaussian is defined as:
  
   y=A0*exp( -.5*[(x-x0)/sig]^2) 
  you need to multiply the returned value by .5
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fwhm2tosig2f.pro)</STRONG><P>
<HR>
 
<A NAME="FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA">
<H2>FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA</H2></A>
<A HREF="#FWHM2TOSIG2F - FWHM^2 TO SIGMA^2 FACTOR.">[Previous Routine]</A>
<A HREF="#GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
fwhmtosigf - convert factor fwhm to sigma 
 this uses y=a0*exp(x^2/sig^2)  .. no factor of 2 in exponent
 If factor of 1/2 in exponent then 
 1.d/(sqrt(8*alog(2.))
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/fwhmtosigf.pro)</STRONG><P>
<HR>
 
<A NAME="GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.">
<H2>GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.</H2></A>
<A HREF="#FWHMTOSIGF - CONVERT FACTOR FWHM TO SIGMA">[Previous Routine]</A>
<A HREF="#GAININPDATA - INPUT GAIN DATA FOR RCVR.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
gainget - return telescope gain(az,za,freq) for rcvr.

SYNTAX: stat=gainget(az,za,freq,rcvrNum,gainVal,date=date,zaonly=zaonly)

ARGS:
      az[n]: float azimuth in degrees
      za[n]: float zenith angle in degrees
    freq: float freq in Mhz.
 rcvrNum: int   receiver number 1..16 (see helpdt feeds)) 
KEYWORDS:
 date[2]: int   [year,daynumber] to use for gain computation. The default
                is to use the current day. If they gain curves change
                with time, this allows you to access the gain curve that
                was in use when the data was taken.
 zaonly:        if set then only return the zenith angle dependence (averages
				 over azimuth)
RETURNS:
 gainval[n]: float gain in Kelvins/Jy
    stat: int   -1 --> error, not data returned
                 0 --> requested outside freq range of fits. Return gain
                       of the closed frequency value.
                       the closest value.
                 1 --> frequency interpolated gain value returned.

DESCRIPTION:
   Return the gain (K/Jy) for the requested receiver at the specified 
frequency and az,za. The default is to use the current gain values. The
date keyword allows you to access a gain curve that was valid at some 
other epoch.

   Fits have been done for g(az,za) at different frequencies for various
receivers. This routine will input the fit information and compute the
gain for the two closest frequencies and then interpolate to the
requested freqeuncy. The input fit data is stored in a common block so
the data does not have to be input from disc a second time unless you
pick a different receiver.

NOTE:
   Some receivers have no gain fits. They will return -1 in the status.
If a requested frequency is outside the fitted values, then the value
at the closest frequency is returned (no extrapolation is done).
   If you have correlator data, you can use corhgainget() to get the
gain value. It will figure out the receiver number and date from the
header and then call gainget. 
   For a description of the gain calibration see:
http://www.naic.edu/~phil. Look under calibration for the receiver
of interest. The lines with the remark (gain curves) were used to compute
the gain curves.

EXAMPLES:
   lbw=5
       get gain at 1400Mhz az=120,za=10 for lbw
   stat=gainget(120.,10.,1400.,lbw,gainval)
   az=fltarr(20)               ; az = 0 degrees.
   za=findgen(20)+1            ; za=1..20
   date=[2001,200]             ; for 2001, daynumber:200
   stat=gainget(az,za,1321,lbw,gainval,date=date)
   gainval will be an array of 20 values for za 1 to 20 degrees and azimuth
   of 0 degrees.
   
   to convert from daynumber to day,month,year
   daynum=dmtodayno(d,mon,year)
   dm    =daynotodm(daynum,year)
   where dm=[day,month]

SEE ALSO:gaininpdata, calinpdata, corhcalval
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gainget.pro)</STRONG><P>
<HR>
 
<A NAME="GAININPDATA - INPUT GAIN DATA FOR RCVR.">
<H2>GAININPDATA - INPUT GAIN DATA FOR RCVR.</H2></A>
<A HREF="#GAINGET - RETURN TELESCOPE GAIN(AZ,ZA,FREQ) FOR RCVR.
">[Previous Routine]</A>
<A HREF="#GETSCANIND - GET INDICES FOR START OF EACH SCAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
gainInpData - input gain data for rcvr.

SYNTAX:
     istat=gainInpData(rcvNum,gainData,fname=fname,date=date)  

ARGS:
     rcvNum:  1 thru 16.  receiver to use (same as hdr.iflo.stat1.rfnum).
KEYWORDS:
      fname: to specify an alternate data file with gain values.
            The default file is aodefdir() + 'data/gain.datR{rcvNum}
      date : [year,daynum]  .. if specified the data when you want the
                              gain for..default is most recent.

RETURNS:
      istat: 1 ok, -1 bad file/rcvnum,data probably no fit data available.
    gainData[n]:{gainData} return fit info. 1 structure for each frequency
DESCRIPTION: 
  Input the gain fit data for all the frequncies of a particular receiver
 (rcvNum). The rcvNum can be extracted from the headers with iflohrfnum().

  The default datafile is aodefdir() + 'data/gain.datR{rcvNum} (aodefdir() is
  a function that returns the root of the aoroutines). The keyword
  fname allows you to specify an alternate file. The file format is:
  -  col 1 ; is a column
  -  data is free format , column oriented
  -  nd1 is noise diode 1, nd2 is noise diode2, H-highcal,L-lowcal,
  -  A is polA, B id polB, ndxx-->A/B  implies that diode N feeds pol X 

The structure format for {gaindata} is:
 gainData.rcvNum       receiver number
 gainData.numFreq      number of frequencies found
 gainData.startYr      for the fit
 gainData.startDaynum  for the fit
 gainData.endYr        for the fit
 gainData.endDaynum    for the fit
 gainData.fitI[numFreq] {azzafit} structure holding the coef and other
                          info for each fit
 gainData.calVal[2,numFreq] cal values used when each fit was made.
 See azzafit for a description of the {azzafit} structure.

This routine is called automatically by corhgainval and gainget().

How the different cal routines vary:
gaininpdata() inputs the data from disc. You must specify the rcvrnum.
             It defaults to the current date. It loads a table in common
             holding the fit info for all of the frequencies measured.
gainval()    Pass in the frequency and the rcvrnum. It will input the
             data using gaininpdata if necessary, do the interpolation
             and return the gain.
corhgainval() You specify the correlator sbc header (eg b.b1.h). It will
             compute the frequency and then call gainval(). It returns the
             gain value.
You can call the azzafitpr,eval routines fit the gainData.fitI[] 
to plot out the fit fitvalues.

SEE ALSO: corhgainval, gainget ,azzafit, azzafiteval,azzafitpr
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gaininpdata.pro)</STRONG><P>
<HR>
 
<A NAME="GETSCANIND - GET INDICES FOR START OF EACH SCAN">
<H2>GETSCANIND - GET INDICES FOR START OF EACH SCAN</H2></A>
<A HREF="#GAININPDATA - INPUT GAIN DATA FOR RCVR.">[Previous Routine]</A>
<A HREF="#GETSCANINDX - EXTRACT SCAN FROM ARRAY.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
getscanind - get indices for start of each scan
SYNTAX: getscanind,scanlist,scanind,scanlen
ARGS  :
       scanlist[len]: long array of scan numbers
RETURNS:
       scanind[len] : long indices into scanlist for start
                           of each scan.
       scanlen[len] : long number of entries in each scan.
DESCRIPTION:
   The routine corpwr() returns power information for each record in
a file. This includes the scan number of each record. Typically there
will be many records in a scan. This routine will search the array of
scan numbers and return the starting index for the start of each scan
and the number of records in the scan. It does this by scanning the array
and looking for where the scan number changes.

EXAMPLE:
   print,corpwr(lun,9999,p)        ... up to 9999 recs
   getscanind,p.scan,scanind,scanlen
;  now loop thru each scan returned
   nscans=(size(scanind))[1]
   for i=0,nscans-1 do begin
;      grab those belonging to 1 scan 
       p1=p[scanind[i]:scanind[i]+scanlen[i]-1]
       ...process
   endfor
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/getscanind.pro)</STRONG><P>
<HR>
 
<A NAME="GETSCANINDX - EXTRACT SCAN FROM ARRAY.">
<H2>GETSCANINDX - EXTRACT SCAN FROM ARRAY.</H2></A>
<A HREF="#GETSCANIND - GET INDICES FOR START OF EACH SCAN
">[Previous Routine]</A>
<A HREF="#GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
getscanindx - extract scan from array.
SYNTAX: subarr=getscanindx(datarr,scanind,scanlen)
ARGS  :
       datarr[]: any type extract subarray from here
       index   :     long .. index to extract 
       scanind[len]: long .. index array from getscanind
       scanlen[len]: long .. len each scan from getscanind
RETURNS:
       datsubarr[] : anytype.. ith scans data
                           of each scan.
DESCRIPTION:
   Some routines return multiple scans data as one large array with
one of the elements in the array being the scan number. getscanind()
will find the start and length of each scan in this array.
getscanindx will extract the i'th scans data from the array.
EXAMPLE:
   print,corpwr(lun,9999,p)        ... up to 9999 recs
   getscanind,p.scan,scanind,scanlen
;  now loop thru extracting each scans data
   nscans=(size(scanind))[1]
   for i=0,nscans-1 do begin
;      grab those belonging to the ith scan 
       p1=getscanindx(p,i,scanind,scanlen)
       ...process
   endfor
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/getscanindx.pro)</STRONG><P>
<HR>
 
<A NAME="GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.">
<H2>GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.</H2></A>
<A HREF="#GETSCANINDX - EXTRACT SCAN FROM ARRAY.">[Previous Routine]</A>
<A HREF="#GS - GENERATE A GAUSSIAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
getsl  - scan a corfile and return the scan list.
SYNTAX: sl=getsl(lun,scan=scan,maxscans=maxscans)
ARGS:
       lun:    int assigned to open file
KEYWORDS:
      scan: long if supplied then start scanning from this scan number.
                   default is the beginning of the file
  maxscans: long if supplied then quit after this many scans are found
                   default: 5000L
RETURNS:
      sl[nscans]:{sl} holds scan list info
DESCRIPTION
   This routine reads a corfile and returns an array of scanlist structures.
This array contains summary information for each scan of the file:

   sl.scan       - long   scan number for this scan
   sl.bytepos    - unsigned long for start of this scan
   sl.stat       - .. not used yet..
   sl.rcvnum     - byte receiver number 1-16
			        note: ch is rcvnum 100
   sl.numfrq     - byte  .. number of freq,cor boards used this scan
   sl.rectype    - byte 1 -calon
                        2 -caloff
                        3 -onoff on  pos
                        4 -onoff off pos
                        5 -coron (track just on position)
                        6 -cormap1
                        7 -cormapdec
                        8 -cordrift
                        9 -corcrossch
                       10 -x111auto (rfi monitoring)
                       11 -one      murrays on with calon/off at the null
                       12 -onoffbml murrays on, off and cal at null
   sl.numrecs    - long  .. number of groups(records in scan)
   sl.freq[4] float- topocentric frequency center each subband
   sl.julday  double- julian date start of scan
   sl.srcname  string  - source name (max 12 long)
   sl.procname string  - procedure name used.

   Some routines can use the sl structure to perform random access to
files (bypassing the need to search for a scan). The sl[] array can
also be used with the where() command to rapidly extract subsets of a
file.

EXAMPLE:
   openr,lun,'/share/olcor/corfile.02nov00.x101.1',/get_lun
   sl=getsl(lun)
   1. process all of the lband wide data in a file:
       ind=where(sl.rcvnum eq 5,count)
       for i=0,n_elements(ind)-1
           print,corinpscan(lun,b,scan=sl[ind[i]].scan,sl=sl)
           .. process
       endfor
   2. Find all of the on/off patterns in a file. Make sure that the
      number of records in the on equals the number in the off.
      indon=where(sl.rectype eq 3 ,count)
      if count le 0 then goto,nopairs
;   make sure an off follows the on and has the same number of records..
;   (actually this will fail if the last rec of the file is an on since
;   indon+1 will go beyond the end of the sl array..)
      ind=  where((sl[indon+1].rectype eq 4) and $
            (sl[indon].numrecs eq sl[indon+1].numrecs),count)
      if count le 0 then goto,nopairs
      indon=indon[ind]
   3. plot all of the cal on/off records in a file with cormon().
       ind=where(sl.rectype le 2)
       cormon,lun,sl=sl[ind]

Note this will not work with files > 2gigabytes since it is
using a 32 bit integer.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/getsl.pro)</STRONG><P>
<HR>
 
<A NAME="GS - GENERATE A GAUSSIAN">
<H2>GS - GENERATE A GAUSSIAN</H2></A>
<A HREF="#GETSL  - SCAN A CORFILE AND RETURN THE SCAN LIST.
">[Previous Routine]</A>
<A HREF="#GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
gs - generate a gaussian
SYNTAX: f=gs(len,height,fwhm,position)
ARGS:
        len:   int  .. length to make f. x values will be 0 thru len-1
     height:   float.. height of the gaussian.
     fwhm  :   float.. full width at half maximum. full range 0 to len-1
   position:   float.. position for the peak (0..len-1)
 RETURNS:
     computed gaussian as a double.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gs.pro)</STRONG><P>
<HR>
 
<A NAME="GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.">
<H2>GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.</H2></A>
<A HREF="#GS - GENERATE A GAUSSIAN">[Previous Routine]</A>
<A HREF="#GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 gseval - evaluate a gausian at the requested positions. 
 SYNTAX: val=gseval(fwhm,position)
 ARGS:
     fwhm  :   float.. full width at half maximum of gaussian.
     position:  float. to evaluate (same units as fwhm
 RETURNS:
     vals  :  evaluated at position.
Assume gaussian is unit height
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gseval.pro)</STRONG><P>
<HR>
 
<A NAME="GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI">
<H2>GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI</H2></A>
<A HREF="#GSEVAL - EVALUATE A GAUSIAN AT THE REQUESTED POSITIONS.
">[Previous Routine]</A>
<A HREF="#GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
gsfit2d - cross pattern 2d fit to total power az,za stripsI
SYNTAX: fitCoef=gsfit2d,az,za,z,initCoef,linearza=linearza,zfit=zfit,$
				 covar=covar,sigCoef=sigCoef,chisq=chisq,sigma=sigma,$
		         trouble=trouble,weights=weights
ARGS:
       az[npts]: az pos (offsets from center) in gcdeg all pnts in pat
       za[npts]: za pos (offsets from center) in gcdeg all pnts in pat
        z[npts]: measured data points
    initCoef[m]: float. coef to fit for. first guess
    fitCoef[m]:  float coef from fit
KEYWORDS:
		linearza  : if true then include a linear term in za (a7)
       zfit[npts]: float return fit evaluated at input points
       sigma=sigma : sigma for fit  
       covar[10,10]: covariance matrix
       sigCoef[10] : sigmas for coef.
       chisq       : float ..
       weights[npts]: float weights 
       trouble     : 0 converged,
                    -1 chisq infinite,
                    -2 flamdacount>30*10/flstep
                    -3 iteration > iterationmax def. 20
                    -4 alpha/c not finite.. probably 0 in partial deriv
       nostop      : if set then if trouble=-4 then don't stop, just return
				      with trouble=-4
DESCRIPTION:
 Fit to the function:

z(x,y)= a0 + a1*exp[-xp^2/sigxp^2 - yp^2/sigyp^2] 
If linearza is set then fit to:
z(x,y)= a0 + a1*exp[-xp^2/sigxp^2 - yp^2/sigyp^2] + a7*za

You need to give the coef initial values when the routine is called.
The units are:
a0 - constant
a1 : amplitude
a2 : xoffset ,az coord direction units:amin
a3 : yoffset ,za coord direction      :amin
a4 : sigx^2  ,in prime coordinate system: fwhm amin
a5 : sigy^2  ,in prime coordinate system: fwhm amin
a6 : theta   ,rotate unprimed to primed aligned along ellipsoid of beam,Deg
a7 : zaslope ,The za slope in amplitude units per deg za

xm=(x-x0)
ym=(y-y0)
xp = xm*cos(th)  + ym*sin(th)
yp =-xm*sin(th)  + ym*cos(th)

 angle theta rotates from az,za to axes aligned with the major axis
 of the beam elipse
 
The x,y values are passed via a common block. The call passes in 
an index to this common block.

 we convert postions to arcminutes and angles to radians before calling
 fit, we then back convert when done
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gsfit2d.pro)</STRONG><P>
<HR>
 
<A NAME="GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA">
<H2>GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA</H2></A>
<A HREF="#GSFIT2D - CROSS PATTERN 2D FIT TO TOTAL POWER AZ,ZA STRIPSI
">[Previous Routine]</A>
<A HREF="#HANSMO - HANNING SMOOTH A DATASET">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
gsfit2dc - cross pattern 2d fit to az,za stripsI with coma
SYNTAX: gsfit2dc,az,za,z,a,zfit=zfit,covar=covar,sigCoef=sigCoef,$
                chisq=chisq,sigma=sigma,trouble=trouble
ARGS:
       az[npts]: az pos (offsets from center) in gcdeg all pnts in pat
       za[npts]: za pos (offsets from center) in gcdeg all pnts in pat
        z[npts]: measured data points
        a[m]     : float. coef to fit for. first guess
KEYWORDS:
       zfit[npts]: float return fit evaluated at input points
       sigma=sigma : sigma for fit  
       covar[10,10]: covariance matrix
       sigCoef[10] : sigmas for coef.
       chisq       : float ..
       trouble     : 0 converged,
                    -1 chisq infinite,
                    -2 flamdacount>30*10/flstep
                    -3 iteration > iterationmax def. 20
DESCRIPTION:
 Fit to the function:

z(x,y)= a0 + a1*exp[-xp^2/sigxp^2*(1.+alphax*xpp) -
                     yp^2/sigyp^2*(1.+alphay*ypp)]
You need to give the coef initial values when the routine is called.
The units are:
a0 - constant
a1 : amplitude
a2 : xoffset ,az coord direction units:amin
a3 : yoffset ,za coord direction      :amin
a4 : sigx^2  ,in prime coordinate system: fwhm amin
a5 : sigy^2  ,in prime coordinate system: fwhm amin
a6 : alphax  ,comma in pp system aligned along coma direction
a7 : alphay  ,comma in pp system aligned along coma direction
a8 : theta   ,rotate unprimed to primed aligned along ellipsoid of beam,Deg
a9 : thetap  ,rotate primed to coma aligned, Deg

z(x,y)= a0 + a1*exp[-xp^2/sigxp^2*(1.+alphax*xpp) -
                     yp^2/sigyp^2*(1.+alphay*ypp)]
xm=(x-x0)
ym=(y-y0)
xp = xm*cos(th)  + ym*sin(th)
yp =-xm*sin(th)  + ym*cos(th)
xpp= xp*cos(thp) + xp*sin(thp)
ypp=-xp*sin(thp) + yp*cos(thp)

 angle theta rotates from az,za to axes aligned with the major axis
 of the beam elipse
 
 angle thetap rotates from xp,yp axes to xpp,ypp which are aligned with the
 coma direction of the fit.

The x,y values are passed via a common block. The call passes in 
an index to this common block.

 we convert postions to arcminutes and angles to radians before calling
 fit, we then back convert when done
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/gsfit2dc.pro)</STRONG><P>
<HR>
 
<A NAME="HANSMO - HANNING SMOOTH A DATASET">
<H2>HANSMO - HANNING SMOOTH A DATASET</H2></A>
<A HREF="#GSFIT2DC - CROSS PATTERN 2D FIT TO AZ,ZA STRIPSI WITH COMA
">[Previous Routine]</A>
<A HREF="#HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hansmo - hanning smooth a dataset
SYNTAX: dsmo=hansmo(d)
ARGS: 
    d[m,n]:  float/double data to smooth
RETURNS:
 dsmo[m,n]: the smoothed data.

DESCRIPTION:
   hansmo will hanning smooth the data in the array d. d can be 1 or
more dimensions. It will smooth m points at a time.
	The smoothing is done by convolution in the input domain.

EXAMPLE:
	d=fltarr(1024,4)
   ...
   dsmo=hansmo(d)

	In this example the smoothing would be:
	for i=0,3 do dsmo[*,i]=hanningSmooth(d[*,i])
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hansmo.pro)</STRONG><P>
<HR>
 
<A NAME="HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.">
<H2>HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.</H2></A>
<A HREF="#HANSMO - HANNING SMOOTH A DATASET">[Previous Routine]</A>
<A HREF="#HDRGET - INPUT HEADERS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hardcopy - flush the postscript data to disc.
SYNTAX: hardcopy
ARGS:   none
DESCRIPTION:
   Flush the postscript buffers to disc. Call this routine before
swithing back to x windows display.
SEE ALSO:
ps,pscol,psimage, x
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hardcopy.pro)</STRONG><P>
<HR>
 
<A NAME="HDRGET - INPUT HEADERS">
<H2>HDRGET - INPUT HEADERS</H2></A>
<A HREF="#HARDCOPY - FLUSH THE POSTSCRIPT DATA TO DISC.
">[Previous Routine]</A>
<A HREF="#
HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hdrget - input headers
SYNTAX: nhdrs=hdrget(lun,numhdrs,hdrs,scan=scan,std=std)
ARGS:
       lun: int  assigned to open file
   numhdrs: long number of headers to read
KEYWORDS:
      scan: long position to scan before listing. 
       std: if set then just return the standard header
RETURNS:
   hdrsd[]:{hdr} return headers here (or hdrStd)
   nhdrs  :long  number of headers found

DESCRPIPTION:
   Input numhdrs headers from the current position in the file.
If the scan keyword is used, then position to start of scan before inputting.
If an integration requires more than 1 record (eg 4 correlator boards) then
each record will count as a header.
SEE ALSO:
   posscan,scanlist
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hdrget.pro)</STRONG><P>
<HR>
 
<A NAME="
HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS">
<H2>HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS
</H2></A>
<A HREF="#HDRGET - INPUT HEADERS">[Previous Routine]</A>
<A HREF="#HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
hms1_hms3 - convert hour,min,secs 1 word to hour,min,sec separate words
SYNTAX - ret=hms1_hms3(hhmmss)
ARGS: 
	hhmmss : double angle to convert
RETURNS:
	ret[4] : double hour,min,sec, and sign 

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hms1_hms3.pro)</STRONG><P>
<HR>
 
<A NAME="HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.">
<H2>HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.</H2></A>
<A HREF="#
HMS1_HMS3 - CONVERT HOUR,MIN,SECS 1 WORD TO HOUR,MIN,SEC SEPARATE WORDS
">[Previous Routine]</A>
<A HREF="#HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hms1_hr - convert hhmmss.sss as a double to hours.
SYNTAX: angHr=hms1_hr(hhmmss)
ARGS:
   hhmmss: double value to convert
RETURNS:
   angHr: double the angle converted to hours
DESCRIPTION
 Convert packed hours, minutes, seconds to hours.
The input is a single double with hhmmss.ss with hh hours, mm minutes,
ss.s seconds.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hms1_hr.pro)</STRONG><P>
<HR>
 
<A NAME="HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.">
<H2>HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.</H2></A>
<A HREF="#HMS1_HR - CONVERT HHMMSS.SSS AS A DOUBLE TO HOURS.
">[Previous Routine]</A>
<A HREF="#HOR - SET HORIZONTAL SCALE FOR PLOTTING.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hms1_rad - convert hhmmss.sss as a double to radians.  
SYNTAX: angRad=hms1_rad(hhmmss)
ARGS:
	hhmmss: double value to convert
RETURNS:
	angRad: double the angle converted to radians.	
DESCRIPTION
 Convert packed hours, minutes, seconds to radians.
The input is a single double with hhmmss.ss with hh hours, mm minutes,
ss.s seconds.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hms1_rad.pro)</STRONG><P>
<HR>
 
<A NAME="HOR - SET HORIZONTAL SCALE FOR PLOTTING.">
<H2>HOR - SET HORIZONTAL SCALE FOR PLOTTING.</H2></A>
<A HREF="#HMS1_RAD - CONVERT HHMMSS.SSS AS A DOUBLE TO RADIANS.
">[Previous Routine]</A>
<A HREF="#IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hor - set horizontal scale for plotting.
SYNTAX: hor,hor1,hor2
ARGS:
   hor1: float min horizontal value
   hor2: float max horizontal value.
DESCRIPTION:
   Load the !x.range system value with the min,max xrange to plot.
To reset to auto scaling call hor with no args.
SEE ALSO:
   ver
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/hor.pro)</STRONG><P>
<HR>
 
<A NAME="IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE">
<H2>IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE</H2></A>
<A HREF="#HOR - SET HORIZONTAL SCALE FOR PLOTTING.">[Previous Routine]</A>
<A HREF="#IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ifloh10gchybrid - return true if 10 ghz hybrid in use
SYNTAX: istat=ifloh10gchybrid(iflohdr)  
ARGS:
       iflohdr:{hdriflo}   .. iflo portion of header.
RETURNS:
       istat: int 0 hybrid out, 1 hybrid in use
DESCRIPTION:
   Return 1 if the hybrid in the 10 ghz upconverter is in use.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/iflohquery.pro)</STRONG><P>
<HR>
 
<A NAME="IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.">
<H2>IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.</H2></A>
<A HREF="#IFLOH10GCHYBRID - RETURN TRUE IF 10 GHZ HYBRID IN USE
">[Previous Routine]</A>
<A HREF="#IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
iflohcaltype - return the type of cal used.
SYNTAX: istat=iflohcaltype(iflohdr)    
ARGS:
       iflohdr[]:{hdriflo}   .. iflo portion of header.
RETURNS:
       istat: int 0-7 setting for caltype.
DESCRIPTION:
   Return the setting of the caltype when this record was written.
the values are:
 0  - low correlated    cal (1 diode)
 1  - high correlated   cal (1 diode)
 2  - low crossed over  cal (2 diodes)
 3  - high crossed over cal (2 diodes)
 4  - low uncorrelated  cal (2 diodes)
 5  - high uncorrelated cal (2 diodes)
 6  - low  correlated 90 deg phase shift cal (1 diode)
 7  - high correlated 90 deg phase shift cal (1 diode)
   This is the setting of the cal switch. It does not mean that
this is a cal record.
EXAMPLE:
   If you have read in a correlator record:
   print,corget(lun,b) 
   istat=iflohcaltype(b.b1.h.iflo)
   will return the caltype in istat.
   If iflohdr is an array then an array of ints will be returned each with a
   cal type.
SEE ALSO:
chkcalonoff
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/iflohquery.pro)</STRONG><P>
<HR>
 
<A NAME="IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.">
<H2>IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.</H2></A>
<A HREF="#IFLOHCALTYPE - RETURN THE TYPE OF CAL USED.">[Previous Routine]</A>
<A HREF="#IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
iflohlbwpol - check if hybrid used on lband wide.
SYNTAX: istat=iflohlbwpol(iflohdr) 
ARGS:
       iflohdr[]:{hdriflo}
RETURNS:
       istat: int 1 circular pol hybrid in, 0 linear pol hybrid out.
DESCRIPTION:
   The lband wide receiver has an OMT that provides linear
polarization. After the dewar there is a switchable hybrid that
converts from linear to circular. You need to know this setting for
lbw when you are using the cal values since the cals are injected as 
linear and are averaged if the hybrid is inserted.
EXAMPLE:
   istat=corget(lun,b)
   istat=iflohlbwpol(b.b1.h.iflo)

NOTE: If iflohdr is an array, then an array of ints either 1 or 0.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/iflohquery.pro)</STRONG><P>
<HR>
 
<A NAME="IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD">
<H2>IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD</H2></A>
<A HREF="#IFLOHLBWPOL - CHECK IF HYBRID USED ON LBAND WIDE.
">[Previous Routine]</A>
<A HREF="#IFLOHSTAT - DECODE STATUS WORDS FOR IFLO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
iflohrfnum - return the receiver # for this record
SYNTAX: istat=iflohrfnum(iflohdr)  
ARGS:
       iflohdr[]:{hdriflo}   .. iflo portion of header.
RETURNS:
       istat: int 1-16 receiver number.
DESCRIPTION:
   Return the receiver number used for this record. see 
helpdt feeds (in sunos) for a list of receiver numbers.
if iflohdr is an array than an array of rfnums will be returned.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/iflohquery.pro)</STRONG><P>
<HR>
 
<A NAME="IFLOHSTAT - DECODE STATUS WORDS FOR IFLO">
<H2>IFLOHSTAT - DECODE STATUS WORDS FOR IFLO</H2></A>
<A HREF="#IFLOHRFNUM - RETURN THE RECEIVER # FOR THIS RECORD
">[Previous Routine]</A>
<A HREF="#IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
iflohstat - decode status words for iflo
SYNTAX: statInfo=iflohstat(iflohdr)
ARGS:
       iflohdr[]:{hdriflo}
RETURNS:
       statInfo[]{ifstat} decoded status structure
DESCRIPTION:
   The iflo header contains various info that is encoded in bitmaps 
(if1.st1,if1.st2,if2.st1,if2.st4). This routine decodes these 
bitmaps and returns them in a structure. The input can be 1 or more
iflo headers.
 
Example:
   print,corget(lun,b)
   ifstat=iflohstat(b.b1.h.iflo)

The definition of the structure is:
            rfnum:  0 ,$;   rcvnum 1 to 16
           if1num:  0 ,$;   1-300,2-750,3-1500 (2-12)Ghz,4-10000,5strthru
    hybridIn10Ghz:  0 ,$;   for 10ghz upconverter
         lo1HiSid:  0 ,$;   1 yes
        lbwLinPol:  0 ,$;   1 lin, 0 circular
         syn1rfOn:  0 ,$;   1st lo ,1 yes
         syn2rfOn:  0 ,$;   sbtx synth,1 yes
         lbFbA   :  0 ,$;   lbw filters (bit map) 1.. 9
         lbFbB   :  0 ,$;   lbw filters (bit map) 1.. 9
         useFiber:  0 ,$;   1 yes
        calRcvMux:  0 ,$;   rcvNUmber for upstairs cal mux
        calType  :  0 ,$;   0 Lcorcal,1 Hcorcal,2 Lxcal,3 Hxcal,4lcal,
;                           5 Hcal,6 L90cal,7 H90cal
        ac1Pwrsw :  0 ,$;   ac1 strip bits on /off
        ac2Pwrsw :  0 ,$;   ac2 strip bits on /off
        xfer1Sw  :  0 ,$;   1 normal, 0 switched
      sbnShClosed:  0 ,$;   1 closed
      lo2Hiside  :  0 ,$;   1--> high side. 4 bits
;
;   from if2
;
      if2inpFreq :  0 ,$;    0 spare,1 300, 2 750, 3 1500
      vlbafrq2ghz:  0 ,$;    1 2000, 0 750
          xfer2Sw:  0 ,$;    1 normal, 0 switched
        sbnDopTrk:  0 ,$;    1 doppler tracking,0 no
       noiseSrcOn:  0 ,$;    1 yes, 0 no
      dualPol30If:  0 ,$;    1 2 pol, 0 bands polA
      vis30MhzGr :  0 ,$;    1 greg, 0 ch
      calTTlSrc  :  0 ,$;    1 to 8. cal ttl pulse source
      pwrMetToIF :  0 ,$;    1 yes, 0 to front panel
      if2Stat4[4]: 
             synDest:   0 ,$;    0-frontpanel,1-260to30conv,2-vlba/sb,3-mixers
            mixerCfr:   0 ,$;    0-750,1-1250,2-1500,3-1750
           ampInpSrc:   0 ,$;    0, 1-mixers,2-heliax,3=300Mhz IF
          ampExtMask:   0        bit mask 7 outputs. 1->extinp, 0 from
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/iflohquery.pro)</STRONG><P>
<HR>
 
<A NAME="IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.">
<H2>IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.</H2></A>
<A HREF="#IFLOHSTAT - DECODE STATUS WORDS FOR IFLO">[Previous Routine]</A>
<A HREF="#IMGFLAT - FLATTEN AN IMAGE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
imgdisp - display a 2-d array as an image.
SYNTAX : imgdisp,d,ret,zx=zx,zy=zy,/histeq,/rdpix,win=win,border=border,
          xrange=xval,yrange=yval,/axes,sort=sort,_extra=e,nomodlut=nomodlut,$
	       usecongrid=usecongrid		
 ARGS   : 
        d[m,n] : data to display
 KEYWORDS: 
       zx: int x zoom factor
       zy: int y zoom factor
  usecongrid:     if set and zx or zy, then use congrid rather than
				rebin for the new image.
   histeq: set for histogram equalization of image disp
     sort: if set then use sort for histogram equalization.
    rdpix: set to turn on read pixel function.
  profile: set to turn on profiles command
      win:  int window number to use. default:1 
   border: int  number of pixels around image to allow for labels.
                (ignored if ps, or !p.multi in use).
xrange[2]:float xrange for labeling the x axis (min,max)
yrange[2]:float yrange for labeling the y axis (min,max)
     axes:      if set then draw the axis and labels
   invert:      if set then invert the colors white and black
_extra=e        passed to plot routine when drawing the axes.
                can include, xtitle,ytitle,title, etc..

RETURNS:
       ret[]   : array actually displayed after scaling.(optional)

DESCRIPTION:
   Display an m by n array as an image. The data is passed in 
via the array d. It will normally create the image in window 1. This can
be overridden with the win= keyword.

   zx,zy allow you to zoom the image in the x or y dimension before display. 
They must be integral values (rebin is used). gt 1  make the dimension
larger while lt -1  make the dimension smaller by this amount. If the
zoom is lt 0 then it must divide evenly into the dimension of the array.

   The normal scaling of the data values is:
   (d-minVal)/(maxVal-minVal) * number of ofColors in lookup table.
You can switch to histogram equalization by setting /histeq. If your data
has outliers then the /sort option will make the histogram equalization 
work better (but it takes a little longer).

   If the keyword axes is set, then tickmarks and labels will be drawn
around the image. xrange,yrange hold the min,max values for each
axis. If you do not specify xrange or yrange then the values 0..ndim-1
is used. You can also pass in xtitle=,ytitle=,title=  to label the 
axis and the plot.

   Setting /rdpix will allow you to readback the position and 
pixel values interactively.
   You can change or load the lookup table with xloadct.

Multiple plots per page.
   The routine can also be used to place multiple images per page. In
this case you must set !p.multi=[plotsLeft,ncols,nrows] outside of
this routine. You must also define the size of the window you want
to use before the first call. The border keyword is ignored.
Each image will be scaled (congrid) to fit into the plot window.

Postscript output.
   You can also generate postscript files. To do this you call 
 psimage,args before calling imgdisp. imgdisp will check
!d.flags for scalable pixels to determine if it is writing to a postscipt
file. When postscript output is enabled the border keyword is ignored. 
If !p.multi is not set then the image will fill the drawing area 
(set in the call to psimage...default 7x9in) while keeping the aspect 
ratio of x to y . If !p.multi is set then each image is scaled to the 
plot window with congrid. When done with the postscript output you must 
call hardcopy to flush the buffer.

   The postscript output will look at the current lookup table. If it
is not 0-255 then it will scale the data to 0-255 and then do 
an indirect lookup through the lookup table. This allows you to display
the image on the screen, change the lookup table with xloadct and then
have the changes appear on the hardcopy output. On exit the 
original lookup table is restored.

Examples:
   assume the images are d[1024,180]

1. display image on the screen, label with a border of 50 pixels:
   imgdisp,d,border=50,/axes,xra=[1400.,1500.],xtitle='freq [Mhz]',$
   title='22jan01 spectra pol A'

2. above, but display in landscape mode to a postscipt file:
   imgdisp,d,border=50,/axes,xra=[1400.,1500.],xtitle='freq [Mhz]',$
   title='22jan01 spectra pol A'
   the border keyword is ignored.

3. place  6 images per page. assume d is [1024,180,6]. 
   window,1,xsize=1000,ysize=600       ; plot will fit in here
   for i=0,5 do begin
       !p.multi=[(6-i mod 6),2,3]
       title=string(format='("image looking at distomat ",i2)',i+1)
       imgdisp,d[*,*,i],/axes,xra=[1400.,1500.],xtitle='freq [Mhz]',$
       title=title
   endfor
   
   For the same thing with postscript output:
   psimage
   for i=0,5 do begin
       !p.multi=[(6-i mod 6),2,3]
       title=string(format='("image looking at distomat ",i2)',i+1)
       imgdisp,d[*,*,i],/axes,xra=[1400.,1500.],xtitle='freq [Mhz]',$
       title=title
   endfor
   hardcopy
   x           ; to get back to x windows.

GOTCHAS:
1. When making images it is important to get all 256 colors for your
  lookup table. The only way to guarantee this in idl is:
  idl
   p8      .. set to pseudo color mode
  window,colors=256
  Then proceed with normal processing.
2. When scaling down a plot or when putting multiple plots per page
   it is easy to loose information. If you have placed horizontal or
   vertical lines in the plot for reference (and they are only 1 line
   wide) they may not appear on the final image.
3. landscape ps output does not always appear where you think it should. Any
  page offsets are first applied and then the image is rotated by 270
  degrees so that the xoffset points up and the yoffset points to the left.
  psimage,/lanscape will fudge the offsets  so that
  x'=yoff,y'=maxLen-xoff. so the origin is at the upper left. 
  rotation by 270. this leaves:
  y''=x, x''=(maxlen-1) so the image is inverted. It would have been nice
  if idl did a rotate by 90 and then flip about the vertical axis...
  For those that don't want psimage doing this magic, set xoff=0,yoff=0
  with /landscape and this extra addition won't happen (but your plot 
  won't be visible unless you play some games..).
  To get a good plot out in landscape mode try using the pstops command
  outside of idl to straighten things..

  psimage,/landscape
  plot the image
  hardcopy
  x

  cmd=strarr(4)
  cmd[0]='/pkg/image/bin/pstops'
  cmd[1]='1:0u(8.5in,11in)'
  cmd[2]='/dir.../idl.ps'
  cmd[3]='/dir.../idlfixed.ps'
  spawn,cmd,reply,/noshell

  This should put the image in the correct location on the page.
  You need to replace dir... with your directory..
SEE ALSO:
   imgflat,imgflaty,imghisteq,corimgdisp,corimgonoff
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/imgdisp.pro)</STRONG><P>
<HR>
 
<A NAME="IMGFLAT - FLATTEN AN IMAGE.">
<H2>IMGFLAT - FLATTEN AN IMAGE.</H2></A>
<A HREF="#IMGDISP - DISPLAY A 2-D ARRAY AS AN IMAGE.">[Previous Routine]</A>
<A HREF="#IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
imgflat - flatten an image.
SYNTAX: result=imgflat(data,code,ravg=ravg,col=[x1,x2],sig=sig,median=median,
                       bptouse=bptouse,nobpc=nobpc)
ARGS:   
    data[x,y]   data to operate on
    code     : int how to flatten image:
               0  bandpass correct using the average of all strips.
                  if /med set then use the median rather than the average.
               n  bandpass correct n strips at a time, averaging n strips
                  if /ravg is set then this is a running avg. If not,then
                  break image into y/n sections and do 1 avg for each section.
              -n  bandpass correct using bandpasses +/- n strips from the
                  current line. 
KEYWORDS:
    ravg     :  if set and n> 0 then use a running average of n
                  strips about the current line.
    col[2]   :  after bandpass correction average columns x1 thru x2
                and divide this into every column (to remove things
                like continuum sources. Note that x1,x2 are zero based..
    sig      : if set, return map in units of sigma
   median    : if set then use the median rather than the average for code
   bptouse[x] : if provided, use this for band pass correction. ignore code
   nobpc      : if set then do not do a bandpass correction.
RESTRICTIONS:
             if n > 0 then y must be divisible by n
             if chn provided then x1 le x2 le x
DESCRIPTION:
    The data array d[x,y] has  x xpoints by y ypoints.
The processing steps are:
1. bandpass correct using the code provided.
2. if chn[] is specified then average columns x1 through x2 and divide this
into every column. 
3. subtract 1 from the map.
4. if sig is set, compute and then divide the map by the maps sigma.
EXAMPLE:
1. assume we have correlator data of 1024 lags by 300 records. Display
   sbc 1 pol A and use columns 800-900 for leveling. On display, scale
   the data to 2% of Tsys:
   img=imgflat(b.b1.d[*,0],0,col=[800,900]) 
   imgdisp,(img > (-.02))<.02,zy=2
	Note: corimgdisp() does all this for you in 1 routine.
2. Assume position switch correlator data of 300 recs/scan. Display
   all 600 records using the 300 off records for the bandpass correction.
   scale to 5% of Tsys:
   print,corgetm(lun,600,b,scan=scan) ; read in 600 recs starting at on.
   sbc=0
   pol=0
   bpc=coravg(b[300:599].(sbc).d[*,pol]) ; average the off data
   img=imgflat(b.(sbc).d[*,pol],0,bptouse=bpc)
   imgdisp,(img > (-.05))<.05 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/imgflat.pro)</STRONG><P>
<HR>
 
<A NAME="IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION">
<H2>IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION</H2></A>
<A HREF="#IMGFLAT - FLATTEN AN IMAGE.">[Previous Routine]</A>
<A HREF="#IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
imgflaty - flatten an image in the y direction
SYNTAX: result=imgflaty(data,x1,x2)
ARGS:   
    data [m,n]   data to operate on
    x1   int     index col average start (count from 0)
    x2   int     index col average end   (count from 0)
DESCRIPTION:
    The data array d[m,n] has  m xpoints by n ypoints.
 average columns located at x1 thru x2 to give  a[n].
 expand a to be a[m,n] by duplicating the columns
 retun data/a
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/imgflaty.pro)</STRONG><P>
<HR>
 
<A NAME="IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY">
<H2>IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY</H2></A>
<A HREF="#IMGFLATY - FLATTEN AN IMAGE IN THE Y DIRECTION
">[Previous Routine]</A>
<A HREF="#INVERF - COMPUTE INVERSE ERROR FUNCTION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
imghisteq - histogram equalize an image. return byte array

 SYNTAX: bytarr=imghisteq(data,stretch=stretch,invert=invert,minv=minv,
                          maxv=maxv,sort=sort)
 ARGS:
      data[m,n] : data array to equalize
 KEYWORDS:
      stretch[4]: after histogram equalization,
                  map data range s[0]-s[1] (0 to 255)
                  to  data range s[2]-s[3] (0 to 255)
      minv      : float .. minv to use for histeq_no stretchclipping
      maxv      : float .. maxv to use for histeq_no stretchclipping
      sort      : if set then histeq via sort
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/imghisteq.pro)</STRONG><P>
<HR>
 
<A NAME="INVERF - COMPUTE INVERSE ERROR FUNCTION">
<H2>INVERF - COMPUTE INVERSE ERROR FUNCTION</H2></A>
<A HREF="#IMGHISTEQ - HISTOGRAM EQUALIZE AN IMAGE. RETURN BYTE ARRAY
">[Previous Routine]</A>
<A HREF="#ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
inverf - compute inverse error function
SYNTAX: val=inverf(x)
ARGS:
     x[n] : float/double   evalute the function at x.
RETURNS:
	val[n] :  double the inverse error function value.

DESCRIPTION:
	Compute the inverse error function. 
  The following approximations to the inverse of the error function are
  taken from J. M. Blair, C. A. Edwards, and J. H. Johnson, "Rational
  Chebyshev Approximations for the Inverse of the Error Function",
  Mathematics of Computation, 30 (1976) 827-830 + microfiche appendix.

 via fred schwab
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/inverf.pro)</STRONG><P>
<HR>
 
<A NAME="ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.">
<H2>ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.</H2></A>
<A HREF="#INVERF - COMPUTE INVERSE ERROR FUNCTION">[Previous Routine]</A>
<A HREF="#LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
isleapyear - check if year is a leap year.
SYNTAX: istat=isleapyear(year)
 ARGS:   year: int/long 4 digit year
 Returns:
         istat: int  0 if not a leap year.
                     1 if  a leap year.
DESCRIPTION:
 Determine whether a year is a leap year in the gregorian calendar.
 Leap years are those years 
  divisible by 4 and (!(divisible by 100) or (divisible by 400)).
 eg. (1900 is not a leap year, 2000 is).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/isleapyear.pro)</STRONG><P>
<HR>
 
<A NAME="LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA">
<H2>LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA</H2></A>
<A HREF="#ISLEAPYEAR - CHECK IF YEAR IS A LEAP YEAR.">[Previous Routine]</A>
<A HREF="#LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
lbgain - compute lband gain as a function of az,za
SYNTAX: gain=lbgain(az,za)
ARGS  : az[n]   - float azimuth in degrees.
        za[n]   - float zenith angle in degrees.
RETURNS:
       gain[n]  - float kelvins/Jy.
DESCRIPTION
   Compute the gain of the lband system in Kelvins per Jansky. Data
was taken from jul00,aug00 lbn and lbwide on/off position switching
data using the correlator (see http://www.naic.edu/~phil). 1405 Mhz
was used and polA polB were averaged together.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/lbgain.pro)</STRONG><P>
<HR>
 
<A NAME="LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..">
<H2>LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..</H2></A>
<A HREF="#LBGAIN - COMPUTE LBAND GAIN AS A FUNCTION OF AZ,ZA
">[Previous Routine]</A>
<A HREF="#MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
lutcycle - cycle through all the idl luts..
SYNTAX: lutcycle,delay
ARGS:
   delay:  int/float. secs to wait between each step.
DESCRIPTION:
   Cycle through all of the lookup tables supplied by idl.
EXAMPLE:
   display an image.
   imgdisp,dat
   lutcycle,5      ; cycle through 40 luts waiting 5 seconds at each 1.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/lutcycle.pro)</STRONG><P>
<HR>
 
<A NAME="MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.">
<H2>MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.</H2></A>
<A HREF="#LUTCYCLE - CYCLE THROUGH ALL THE IDL LUTS..">[Previous Routine]</A>
<A HREF="#MAV - MULTIPLY AN ARRAY BY A VECTOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
maskbyrms - create mask using rms of fit residuals.
SYNTAX:  mask=maskbyrms(x,y,deg=deg,maxloop=maxloop,nsig=nsig,$
                        indxgood=indxgood,indxbad=indxbad,$
                        nbad=nbad,ngood=ngood,verb=verb,coef=coef) 
ARGS:
     x[n]  : float x data
     y[n]  : float y data

 RETURNS:
  mask[n]:long holds the mask. 1 for good points, 0 for bad points
 indxgood:long indices of y whose mask value is 1
  indxbad:long indices of y whose mask value is 0
    ngood:long the number of good (mask=1) points.
     nbad:long the number of bad  (mask=0) points.
coef[deg+1]: float the coef from poly_fit

 KEYWORDS:
      deg: int  degree for polynomial fit (def:1)
  maxloop: int  max time to loop on fit before quitting. (def:20)
     nsig: float keep points within nsig of fit (def: 3. sigma)
     verb:     if set then plot out the residuals and mask after the
               fitting.

 DESCTRIPTION:
   This routine will fit a polynomial of order deg to the data x,y.
It will then remove all points whose fit residuals are greater then
nsig sigmas and iterate the fitting process. When all residuals are within
nsig, a mask is created where the remaining points have a 1 and the points
that were excluded have a mask value of 0.

NOTE: this routine uses the value of x that is provided. For large values
      of deg you should scale x so that x**deg  does not overflow (say -1,1).
SEE ALSO:
   blmask, cormask, corblauto
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/maskbyrms.pro)</STRONG><P>
<HR>
 
<A NAME="MAV - MULTIPLY AN ARRAY BY A VECTOR">
<H2>MAV - MULTIPLY AN ARRAY BY A VECTOR</H2></A>
<A HREF="#MASKBYRMS - CREATE MASK USING RMS OF FIT RESIDUALS.
">[Previous Routine]</A>
<A HREF="#MCALINP - INPUT DATA FOR MEASCAL ROUTINE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mav - multiply an array by a vector 
SYNTAX: val=mav(a,v,sec=sec)
ARGS:
       a[n,m] : array 
       v[n]   : vector 
KEYWORDS:
	  sec: if set then v should match the 2nd dimension of a

returns:
       val[n,m]
DESCRIPTION: 
 return val[i,j]= a[i,j]*v[j].. i=0,n-1,j=0,m-1

 the routine will make v'[n,m] where v[i,*] is the same value
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mav.pro)</STRONG><P>
<HR>
 
<A NAME="MCALINP - INPUT DATA FOR MEASCAL ROUTINE.">
<H2>MCALINP - INPUT DATA FOR MEASCAL ROUTINE.</H2></A>
<A HREF="#MAV - MULTIPLY AN ARRAY BY A VECTOR">[Previous Routine]</A>
<A HREF="#MEANROB - ROBUST MEAN FOR 1D ARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mcalinp - input data for meascal routine.
SYNTAX: d=mcalinp(lun,type,numsteps,numloops,scan=scan)
ARGS  :
		lun	: int	of correlator file to read
		type: int	1- on absorber, 2 on sky
	numsteps: int	number of steps to cover the frequency range
					these are usually the 100 Mhz junks.
   numloops: int   the number of types you swept the entire frequency
				    range. The scans must be contiguous on disc.
KEYWORDS:
	scan	:long	scan number to position to before reading. If 
					not provided then read from the current position.
					not provided then read from the current position.
	maskSig :float  sigmas to use for rms by record masking
RETURNS:
	d[numsteps*numloops*4]: {meascal} return the data here (see below).
DESCRPTION:
	The meascal	data acquisition routine steps through a frequency range
turning the cal off then on. It is normally run on absorber and then
on the sky. The setup is 4 sbc by 256 lags spanning 4*25 Mhz in a chunk.
An option of the routine is to loop multiple times through the frequency
range.
	This routine reads the data and separates each sbc into a separate
element in the {meascal} array. The user provides the lun, type (
1 for absorber, 2 for sky) and the number of 100 Mhz steps and times
the entire frequency range was repeated. 
	The returned data array contains and entry for each sbc of each step:

 d.frq    - center freq of sbc in Mhz
 d.type   - 1 for absorber, 2 for sky (user supplies this value).
 d.scan   - scan number for the cal off scan
 d.brd    - board number in correlator 0..3
 d.spOn[256,2]  -holds the calon  spectra for polA and polB
 d.spOff[256,2] -holds the caloff spectra for polA and polB
 d.spCal[256,2] -holds the caloff spectra for polA and polB
 d.tpOn[2]  - total power cal on (pola,polb)
 d.tpOff[2] - total power cal off (pola,polb)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mcalinp.pro)</STRONG><P>
<HR>
 
<A NAME="MEANROB - ROBUST MEAN FOR 1D ARRAY">
<H2>MEANROB - ROBUST MEAN FOR 1D ARRAY</H2></A>
<A HREF="#MCALINP - INPUT DATA FOR MEASCAL ROUTINE.">[Previous Routine]</A>
<A HREF="#MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
meanrob - robust mean for 1d array
SYNTAX:  mean=meanrob(y,nsig=nsig,double=double,sig=sig,$
                      gindx=gindx,ngood=ngood,bindx=bindx,nbad=nbad,$
                      fpnts=fpnts,iter=iter)
  ARGS:
     y[n]  : array to compute robust mean
KEYWORDS:
     nsig  : float use nsig*sigma as the threshold for the points to
					keep on each iteration. The default is 3.
     double:       if set then force computation to be done in double
                   precision.
 RETURNS:
     mean:   float/double the computed mean
   sig       float/double the last computed rms
   fpnts :   float        the fraction of points used for the final
                          computation
    gindx:   long[]       indices into d for the points that were used
                          for the computation.
    ngood    long         number of points in gindx.
    bindx:   long[]       indices into d for the points that were not used
    nbad     long         number of points in bindx.
    iter     long         number of iterations performed.

 DESCTRIPTION:
    compute the robust mean for the input data array. The program loops
 doing:
   0. create a mask that includes all the points.
   1. compute the mean, rms over the current mask
   2. Find all points in the original array that are within nsig*sig of 
      the mean. This becomes the new mask. If the new mask has fewer 
      points than the old mask, go to 1.
   4. Return the last mean computed. If the keywords are present, return
      the sig, index for good points, index for bad points, and the fraction
	   of points used in the final computation.
.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/meanrob.pro)</STRONG><P>
<HR>
 
<A NAME="MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY">
<H2>MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY</H2></A>
<A HREF="#MEANROB - ROBUST MEAN FOR 1D ARRAY">[Previous Routine]</A>
<A HREF="#MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
meanrun - compute the running mean of a 1 or 2d array
SYNTAX: result=meanrun(data,len)
ARGS:   
    data[x,y]   data to operate on
    len      : int length of running mean. If even , round up to next
                   odd number
DESCRIPTION:
   Compute a running mean along  the last dimension of the array data.
data can be a 1 or 2d array; The output will be float (unless data is
a double array in which case it will be double). For each point
   data[j,i] the routine will average:
   data[j,(i-len/2):(i+len/2)] points.
The edges will only average the above points which fall within
the index bounds of the array. 
(eg data[j,0:len/2]) 

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/meanrun.pro)</STRONG><P>
<HR>
 
<A NAME="MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.">
<H2>MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.</H2></A>
<A HREF="#MEANRUN - COMPUTE THE RUNNING MEAN OF A 1 OR 2D ARRAY
">[Previous Routine]</A>
<A HREF="#MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
medianbychan -  median 2d array by chan.
SYNTAX:  result=medianbychan(d)
   ARGS:
 d[m,n]: input array to compute median over 2nd dimension (n).
   
RETURNS:
result[m]: result[i]= median(d[i,*])

DESCTRIPTION:
    Compute the median by channel for a 2d array. If the array
is dimensioned d[m,n] then result[i]=median(d[i,*]).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/medianbychan.pro)</STRONG><P>
<HR>
 
<A NAME="MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.">
<H2>MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.</H2></A>
<A HREF="#MEDIANBYCHAN -  MEDIAN 2D ARRAY BY CHAN.">[Previous Routine]</A>
<A HREF="#MKSIN - MAKE A SINE WAVE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mkazzagrid - make a grid of az,za values.
SYNTAX: mkazzagrid,az,za,azstart=azstart,azend=azend,azstep=azstep
                         zastart=zastart,zaend=zaend,zastep=zastep
RETURNS:
   az[nptsaz,nptsza]: float return azimuth values here
   za[nptsaz,nptsza]: float return za values here
KEYWORDS:
   azstart          : float. starting azimuth . default 0.
   azend            : float. ending   azimuth . default 359.
   azstep           : float. step size for azimuth points. def:1
   zastart          : float. starting za.     . default 0.
   zaend            : float. ending   za.     . default 20.
   zastep           : float. step size for za points. def:.5
DESCRIPTION:
   Return the 2d arrays az,za filled in with the requested az,za.
These values can than be used to evaluate 2d functions of (az,za)
or for plotting 2d fields.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mkazzagrid.pro)</STRONG><P>
<HR>
 
<A NAME="MKSIN - MAKE A SINE WAVE">
<H2>MKSIN - MAKE A SINE WAVE</H2></A>
<A HREF="#MKAZZAGRID - MAKE A GRID OF AZ,ZA VALUES.">[Previous Routine]</A>
<A HREF="#MK_HTML_HELP_PH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mksin - make a sine wave
SYNTAX: d=mksin(len,numcycles,phase=phase)
ARGS  : 
  len : long.. number of points
numcycles:float.. number of cycles in len
KEYWORDS:
phase : float  .. starting phase in fraction of a cycle
RETURNS:
      d[len] :float .. the  sinwave
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mksin.pro)</STRONG><P>
<HR>
 
<A NAME="MK_HTML_HELP_PH">
<H2>MK_HTML_HELP_PH</H2></A>
<A HREF="#MKSIN - MAKE A SINE WAVE">[Previous Routine]</A>
<A HREF="#MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	MK_HTML_HELP_PH

 PURPOSE:
	Given a list of IDL procedure files (.PRO), VMS text library 
       files (.TLB), or directories that contain such files, this procedure 
       generates a file in the HTML format that contains the documentation 
       for those routines that contain a DOC_LIBRARY style documentation 
       template.  The output file is compatible with World Wide Web browsers.
       This is a hack to mk_html_help for phil's documentation.

 CATEGORY:
	Help, documentation.

 CALLING SEQUENCE:
	MK_HTML_HELP_PH, Sources, Outfile

 INPUTS:
     Sources:  A string or string array containing the name(s) of the
		.pro or .tlb files (or the names of directories containing 
               such files) for which help is desired.  If a source file is 
               a VMS text library, it must include the .TLB file extension.  
               If a source file is an IDL procedure, it must include the .PRO
               file extension.  All other source files are assumed to be
               directories.
     Outfile:	The name of the output file which will be generated.

 KEYWORDS:
     TITLE:	If present, a string which supplies the name that
		should appear as the Document Title for the help.
     VERBOSE:	Normally, MK_HTML_HELP does its work silently.
		Setting this keyword to a non-zero value causes the procedure
		to issue informational messages that indicate what it
		is currently doing. !QUIET must be 0 for these messages
               to appear.
     STRICT:   If this keyword is set to a non-zero value, MK_HTML_HELP will 
               adhere strictly to the HTML format by scanning the 
               the document headers for characters that are reserved in 
               HTML (<,>,&,").  These are then converted to the appropriate 
               HTML syntax in the output file. By default, this keyword
               is set to zero (to allow for faster processing).
	 BGCOLOR:   background color. format is "#RRGGbb" (hex numbs) or "xlibcol"
				<pjp mod>

 COMMON BLOCKS:
	None.

 SIDE EFFECTS:
	A help file with the name given by the Outfile argument is
	created.

 RESTRICTIONS:
	The following rules must be followed in formatting the .pro
	files that are to be searched.
		(a) The first line of the documentation block contains
		    only the characters ";+", starting in column 1.
               (b) There must be a line which contains the string "NAME:",
                   which is immediately followed by a line containing the
                   name of the procedure or function being described in
                   that documentation block.  If this NAME field is not
                   present, the name of the source file will be used.
		(c) The last line of the documentation block contains
		    only the characters ";-", starting in column 1.
		(d) Every other line in the documentation block contains
		    a ";" in column 1.

       Note that a single .pro file can contain multiple procedures and/or
       functions, each with their own documentation blocks. If it is desired
       to have "invisible" routines in a file, i.e. routines which are only
       for internal use and should not appear in the help file, simply leave
       out the ";+" and ";-" lines in the documentation block for those
       routines.

	No reformatting of the documentation is done.

 MODIFICATION HISTORY:
       July 5, 1995, DD, RSI. Original version.
       July 13, 1995, Mark Rivers, University of Chicago. Added support for
               multiple source directories and multiple documentation
               headers per .pro file.
       July 17, 1995, DD, RSI. Added code to alphabetize the subjects;
               At the end of each description block in the HTML file,
               added a reference to the source .pro file.
       July 18, 1995, DD, RSI. Added STRICT keyword to handle angle brackets.
       July 19, 1995, DD, RSI. Updated STRICT to handle & and ".
               Changed calling sequence to accept .pro filenames, .tlb
               text librarie names, and/or directory names.
               Added code to set default subject to name of file if NAME
               field is not present in the doc header.
       sep  19, 2002, pjp . got rid of mk_html_help at the beginning, 
                added bgcolor keyword

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mk_html_help_ph.pro)</STRONG><P>
<HR>
 
<A NAME="MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING">
<H2>MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING</H2></A>
<A HREF="#MK_HTML_HELP_PH">[Previous Routine]</A>
<A HREF="#MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mm0ninit -  initialize for the new mueller 0 processing
SYNTAX: @corinit   
DESCRIPTION:
   call this routine before doing the new mueller 0 processing
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mm0init.pro)</STRONG><P>
<HR>
 
<A NAME="MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING">
<H2>MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING</H2></A>
<A HREF="#MM0NINIT -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING
">[Previous Routine]</A>
<A HREF="#MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
mm0ninitwas -  initialize for the new mueller 0 processing
SYNTAX: @corinit   
DESCRIPTION:
   call this routine before doing the new mueller 0 processing
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/mm0initwas.pro)</STRONG><P>
<HR>
 
<A NAME="MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12">
<H2>MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12</H2></A>
<A HREF="#MM0NINITWAS -  INITIALIZE FOR THE NEW MUELLER 0 PROCESSING
">[Previous Routine]</A>
<A HREF="#NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
montonum - convert ascii month to number 1-12
SYNTAX:  num=montonum(month)
ARGS  :
        month   string holding 3 character month
DESCRIPTION:
   Given a 3 character month abreviation return the month of year (1..12).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/montonum.pro)</STRONG><P>
<HR>
 
<A NAME="NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.">
<H2>NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.</H2></A>
<A HREF="#MONTONUM - CONVERT ASCII MONTH TO NUMBER 1-12
">[Previous Routine]</A>
<A HREF="#P8 - SET FRAME BUFFER TO PSEUDO COLOR.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
note - write a string at the requested line on the plot.
SYNTAX: note,line,lab,xp=xp,sym=sym,lnstyle=lnstyle,dyscale=dyscale,_extra=e
ARGS:
   line: float linenumber to start on. 1-33 covers the plot.
   lab : string to write on plot.
   xp  : float  xposition to start at. 0 to 1 covers the plot. default is
                center each line on page.
   sym : int    sym number. If present then plot the symbol at the start
                of the line (leave some blanks in lab at the start).
 lnstyle: int   if provided then draw a short line of type lnstyle at the 
                beginning of the line (leave blanks at start of lab).
 dyscale:float  if set then scale the y spacing this amount.
DESCRIPTION:
   Write a line of text on a plot. The default line position runs 1 through
33. Use the xp  keyword to align the text horizonally. The sym and linestyle
keywords let you put lines, symbols at the start of your text so you can
define what they are. 
   If !p.multi is used for multiple pages then you must recompute where
the lines go. The line number is relative to the entire page, not the 
current window of !p.multi.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/note.pro)</STRONG><P>
<HR>
 
<A NAME="P8 - SET FRAME BUFFER TO PSEUDO COLOR.">
<H2>P8 - SET FRAME BUFFER TO PSEUDO COLOR.</H2></A>
<A HREF="#NOTE - WRITE A STRING AT THE REQUESTED LINE ON THE PLOT.
">[Previous Routine]</A>
<A HREF="#PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
p8 - set frame buffer to pseudo color.
SYNTAX: p8
ARGS:   none
DESCRIPTION:
   Set the terminals frame buffer to pseudo color. This
should be done before any plotting is done.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/p8.pro)</STRONG><P>
<HR>
 
<A NAME="PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.">
<H2>PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.</H2></A>
<A HREF="#P8 - SET FRAME BUFFER TO PSEUDO COLOR.">[Previous Routine]</A>
<A HREF="#PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pagesize - set the postscript page size.
SYNTAX:  pagesize,fullpage=fullpage,yoff=yoff
KEYWORDS: 
   fullpage: if set then set the pagesize to 7 by 10 inches.
             default is 7 by 5 inches.
   yoff    : if supplied then move the plot from the default 
			  position this many inches on the page.
DESCRIPTION:
   Set the postscript output page size. This should only be called
when you are plotting to the postscript device (ps,psimage,pscol).
SEE ALSO:
ps, pscol, psimage
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pagesize.pro)</STRONG><P>
<HR>
 
<A NAME="PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.">
<H2>PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.</H2></A>
<A HREF="#PAGESIZE - SET THE POSTSCRIPT PAGE SIZE.">[Previous Routine]</A>
<A HREF="#PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pltazzausage - plot the 2D az,za coverage.

SYNTAX: pltazzausage,az,za,title=title,sym=sym,over=over,dx=dx,_extra=e

ARGS:
   az[npts]    : float azimuth positions (degrees).
   za[npts]    : float zenith angle positions (degrees).

KEYWORDS:
    title: string label for top of plot
      sym: int symbol to plot at each position.Default is *.
     over:     if set then overplot this data with what is there.
       dx:     The step size in feet along the x,y axis. default is 10 feet.
    _extra:    extra keyword values to pass to plot and oplot routine.
               eg (color=n).
RETURNS:

DESCRIPTION:
   Plot the azimuth, za positions as a cartesian x,y plot. The axes are
feet from the center of the dish (projected onto z=0). This routine can
give an idea of how well a set of sources has covered the dish.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pltazzausage.pro)</STRONG><P>
<HR>
 
<A NAME="PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA">
<H2>PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA</H2></A>
<A HREF="#PLTAZZAUSAGE - PLOT THE 2D AZ,ZA COVERAGE.">[Previous Routine]</A>
<A HREF="#PLTBYCOL - PLOT VALUES BY COLOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pltbits  - plot a timing diagram of the input data
SYNTAX: pltbits,x,y,bitmask,col=col,maxbits=maxbits,over=over,$
                 off=off,lab=lab,inc=inc,_extra=e  
ARGS:
   x[] :   x values for the data
   y[] :   array holding the bits to plot
bitmask:  long  bits to extract and plot

KEYWORDS:
   col[]: long colors for each bit to plot
maxbits : long max number of bits you want to plot. This is used to
               compute the vertical positioning of the y axis. Use
               this with off, if you want override the default
               positioning of the traces.
   over : if set then overplot from previous call
   off  : float . add to vertical position of each bit.Default is
                  .06
lab[]   : string. labels for each bit.
DESCRIPTION:
   Suppose an int or long array holds status information that is
packed bit by bit. An example would be the vertex data that has
motor status bits encoded into a single int. This routine will
plot 1 or more of the bits versus the x axis..
EXAMPLE:
   Suppose dat[100] has status info in bit0 and bit5. To plot them
versus input use:
 x=finggen(100)
 pltbits,x,dat,'21'x 
Bit 0 will be plotted versus x with bit 5 plotted above it versus x.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pltbits.pro)</STRONG><P>
<HR>
 
<A NAME="PLTBYCOL - PLOT VALUES BY COLOR">
<H2>PLTBYCOL - PLOT VALUES BY COLOR</H2></A>
<A HREF="#PLTBITS  - PLOT A TIMING DIAGRAM OF THE INPUT DATA
">[Previous Routine]</A>
<A HREF="#PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pltbycol - plot values by color
SYNTAX: pltbycol,x,y,grpid,col=colar,xtitle=xtitle,ytitle=ytitle,
                 title=title,sym=sym,_extra=e,over=over
ARGS:
       x[npts]: float  xdata to plot
       y[npts]: float  ydata to plot
   grpid[npts]: long   unique number identifying a particular group. It 
                       should run 0 through maxgrp-1. It is used to 
                       generate the color.
KEYWORDS: 
   colar[ncol]: long lut values to use.
        xtitle: string xlabel for plot
        ytitle: string ylabel for plot
         title: string title for plot
          sym : int    symbol to use for ploting.
        over  : int    if set, then overplot this dataset on previous
     _extra=e :        will be passed to plot and oplot routine

DESCRIPTION:
   Plot x,y points. Group points by color. grpind[npts] is used to identify
the points that have a common color. colar[ncol] is used for the color.
If there are more groups than colors, then the colors get reused modulo
ncolors. 

EXAMPLE:

   An example would be ploting the za Error for a given set of sources 
by za. Suppose the array of structures src[npts] has the following elements:

 src[i].name  - source name
 src[i].za    - za for a measurement
 src[i].zaErr - za error for the measurement

 The unique srcnames are:
   names=src[uniq(src[sort(src.name)].name)].name

 You could generate the grpind[npts] array by:

   nsrc=n_elements(names)      ; number of unique names
   grpind=lonarr(npnts)        ; will hold srcid 0..nsrc-1
   for i=0,nsrc-1 do begin 
       ind=where(src.name eq names[i],count)  
        if count gt 0 then grpind[ind]=i
   endfor
 You could then call pltbysrc with:

   pltbysrc,src.za,src.zaErr,grpind,sym=1

 The default color array is:
   colar=findgen(10)+1

 This has 10 unique colors (usually setup by ldcolph). Colors get reused 
every 10 sources 
 The default symbol is *.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pltbycol.pro)</STRONG><P>
<HR>
 
<A NAME="PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER">
<H2>PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER</H2></A>
<A HREF="#PLTBYCOL - PLOT VALUES BY COLOR">[Previous Routine]</A>
<A HREF="#POSSCAN - POSITION TO A SCAN/RECORD ON DISC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pnthgrmaster - return 1 if greg is master, 0 if ch master
SYNTAX: istat=pnthgrmaster(pnthdr)  
ARGS:
       pnthdr:{hdrpnt}   .. pnt portion of header.
RETURNS:
       istat: int 1 if greg master, 0 if ch master
EXAMPLE:
   suppose we have a correlator data:
   print,corget(lun,b)
   istat=pnthgrmaster(b.b1.h.pnt)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnthquery.pro)</STRONG><P>
<HR>
 
<A NAME="POSSCAN - POSITION TO A SCAN/RECORD ON DISC">
<H2>POSSCAN - POSITION TO A SCAN/RECORD ON DISC</H2></A>
<A HREF="#PNTHGRMASTER - RETURN 1 IF GREG IS MASTER, 0 IF CH MASTER
">[Previous Routine]</A>
<A HREF="#PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
posscan - position to a scan/record on disc
 SYNTAX: istat=posscan(lun,scan,rec,retstdhdr=retstdhdr,sl=sl)
 ARGS:
       lun:    int .. logical unit assigned to open file
      scan:    long.. scan number 0--> whatever scan fits .. current or next
                      full scan number --> position to scan, 
                      no rewinding allowed
       rec:    long  grp number within scan.
                     0 or not included--> next record available
                               number --> record of current scan
 keywords
   retstdhdr:  if valid variable, return standard header here..
                (only if we positioned successfully)
   skip     :  int .. skip this many scans forward. should use with 
                      scan=0. 
        sl[]:  {sl} returned from getsl routine. If provided
               then routine will position directly to the scan requested.

 The routine will not backup from the current position. If it finds
 an increasing scan/rec number then it returns -1
       
 returns: 1 positioned ok
          0 not found 
         -1 found increasing scan number
         -2 scan not in scanloc array
 
 iook - 1 ok, 0 i/oerror, -1 bad headerid
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/posscan.pro)</STRONG><P>
<HR>
 
<A NAME="PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS">
<H2>PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS</H2></A>
<A HREF="#POSSCAN - POSITION TO A SCAN/RECORD ON DISC">[Previous Routine]</A>
<A HREF="#PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
prfgainall- compute fractional gain do to pitch,roll,focus
SYNTAX: fracgain=prfgainall(az,za,rcvr,pitch,roll,focus,freq=freq,
					foctouse=foctouse,rolltouse=rolltouse,pitchtouse=pitchtouse)
ARGS:   az[npts] - float  azimuth degrees
        za[npts] - float  za degrees
        rcvr     : string: lb,sb,cb,xb 1400,2380,5000,10000
        pitch    : optional arg. return pitch here deg.    
        roll     : optional arg. return roll  here  deg
        focus    : optional arg. return focus here  inches
KEYWORDS:
			 freq : Mhz. if provided, then use the specified rcvr function
                        and add on the relative difference from  this
					     and the rcvr default freq.
	foctouse[npts]: float use this as the focus instead of the model
	rolltouse[npts]: float use this as the roll instead of the model
	pitchtouse[npts]: float use this as the pitch instead of the model
DESCRIPTION:
   Compute the fractional gain do to the pitch roll and focus. We use:
1. the pitch,roll,focus fits from feb00 
2. aoant for pitch,roll
3. focus curve sband for the loss do to focus
4. asssume pitch roll error adds in quadrature
5. assume we multiply the focus loss by pitch,roll loss

 before calling this routine do @prfinit
EXAMPLE:
   make a plot of gain versus az,za
   keep za above 2 degrees since za=0 not measured.
   mkazzagrid,az,za,azstep=10,zastep=1,zastart=2
   gain=prfgainall(az,za,'sb')
   stripsxy,az,gain,0,0,/stepcol
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/prfgainall.pro)</STRONG><P>
<HR>
 
<A NAME="PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..">
<H2>PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..</H2></A>
<A HREF="#PRFGAINALL- COMPUTE FRACTIONAL GAIN DO TO PITCH,ROLL,FOCUS
">[Previous Routine]</A>
<A HREF="#PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
prwspc - compute the power spectrum of the input signal..
SYNTAX: dfrq=pwrspc(dtm)
ARGS:      
     dtm[npts]: real or complex input time series
RETURNS:
    dfrq[npts]: real .. power spectrum squared magnitude of xform
DESCRIPTION:
   Return abs(fft(dtm))^2
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pwrspc.pro)</STRONG><P>
<HR>
 
<A NAME="PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.">
<H2>PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.</H2></A>
<A HREF="#PRWSPC - COMPUTE THE POWER SPECTRUM OF THE INPUT SIGNAL..
">[Previous Routine]</A>
<A HREF="#PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ps - send plot output to postscipt file.
SYNTAX ps,filename,_extra=e,fullpage=fullpage
ARGS:
   filename: string filename for outputfile. default is idl.ps
KEYWORDS:
   fullpage: if set then set the pagesize 5 by 10 inches.
             the default is 5 by 7.
  _extra   : e  pass to device  command.
DESCRIPTION:
   Set plot output destination to a postscript file. 
When done plotting use:
 hardcopy
 x 
to return to terminal output.
SEE ALSO:
 pagesize, pscol, hardcopy, x
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/ps.pro)</STRONG><P>
<HR>
 
<A NAME="PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.">
<H2>PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.</H2></A>
<A HREF="#PS - SEND PLOT OUTPUT TO POSTSCIPT FILE.">[Previous Routine]</A>
<A HREF="#PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pscol - send plot output to color postscipt file.
SYNTAX pscol,filename,_extra=e,fullpage=fullpage
ARGS:
   filename: string filename for outputfile. default is idl.ps
KEYWORDS:
   fullpage: if set then set the pagesize 5 by 10 inches.
             the default is 5 by 7.
  _extra   : e  pass to device  command.
DESCRIPTION:
   Set plot output destination to a color postscript file.
When done plotting use:
 hardcopy
 x
to return to terminal output.
SEE ALSO:
 pagesize, ps, hardcopy, x
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pscol.pro)</STRONG><P>
<HR>
 
<A NAME="PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.">
<H2>PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.</H2></A>
<A HREF="#PSCOL - SEND PLOT OUTPUT TO COLOR POSTSCIPT FILE.
">[Previous Routine]</A>
<A HREF="#PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
psimage - prepare to send image output to a postscript file.
SYNTAX: psimage,filename,xlen=xlen,ylen=ylen,xoff=xoff,yoff=yoff,$
                landscape=landscape,xroff=xroff,yroff=yroff
ARGS: 
   filename: string filename to write to. default is idl.ps
   xlen    : float  number of inches for xdimension. default
                  is 7 inches.
   ylen    : float  number of inches for ydimension. default
                  is 9 inches.
   xoff    : float offset in inches for the left edge of image.
                   the default is to center the plot.
   yoff    : float offset in inches for the bottom edge of image.
                   the default is to center the plot.
   xroff   : float relative offset x direction in inches. add to xoff.
   yroff   : float relative offset y direction in inches. add to yoff.
                   the default is to center the plot.
  landscape: if set then plot in landscape mode.
DESCRIPTION:
   Set the output plot device to a postscript file. Add keywords for
image display (8 bits per pixel). Try and center the imageon the 
page. Landscape mode causes problems when offsets are used. See
imgdisp for how to get around it.
SEE ALSO:
ps,hardcopy,x,imgdisp
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/psimage.pro)</STRONG><P>
<HR>
 
<A NAME="PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.">
<H2>PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.</H2></A>
<A HREF="#PSIMAGE - PREPARE TO SEND IMAGE OUTPUT TO A POSTSCRIPT FILE.
">[Previous Routine]</A>
<A HREF="#RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
pwrlawdist - generate a power law distribution.
SYNTAX: y=pwrlawdist(alpha,npts,minVal=minVal,maxVal=maxVal,
                    dohist=dohist,nbins=nbins,h=h,xh=xh)
ARGS:
    alpha: float exponent for power law.
     npts: long  number of points to return

KEYWORDS:
   minVal: float minimum value for the distribution. If alpha is less
                 than 0., then minval should be gt 0 to keep it from
                 blowing up. default:.01
   maxVal: float maximum value for the distribution. It should be 
                 greater tham minVal.Default:1.
   dohist:       if set, then compute histogram, make log,log plot
                 of histogram, and then do a linear fit to non zero values.
    nbins: long  number of bins if histogram requested. default is
                 npts*.005
RETURNS:
   y[npts]: double the power law distributed data.

 h[nbins]: long  return histogram of y. (linear)
xh[nbins]: float return center of each bin.(linear)

DESCRIPTION:
   Generate a random variable with a power law distribution:
 y=r**(alpha). The data range will be: (minVal ge y le maxVal).
   The routine will optionally compute the histogram of the data,
fit a line to a log,log version of the histogram, and then 
plot the histogram and the fit. This lets you see how close to the
ideal power law you got. The fit can have trouble if the data range
does not make a good match to the binsize,number of bins.

   The method blows up for alpha=-1. If alpha is within 
 1e-4 of -1, the routine uses -1+/-1e-4 and gives a warning..

See numerical recipes in C, section: 7.2 transformation methods, page 287.
for an description of how it's done.

EXAMPLE:

  1. create a power law distribution r^1.5 ranging from 0 to 1. 
     Return,10000L points. Make the histogram with 100 points.

   y=pwrlawdist(1.2,20000L,minval=.0,maxval=1.,/dohist,h=h,xh=xh,$
                  nbins=100)

   ..create a power law dist r^-2.2 with 10000L points.

plot out the histogram. have the values go 1 to 500.
return the histogram with it's binvalues.
kick up the number of bins to 1000 so the histogram fit works.

   y=pwrlawdist(-2.2,10000L,minval=1.,maxval=500.,/dohist,h=h,xh=xh,$
                   nbins=1000)

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pwrlawdist.pro)</STRONG><P>
<HR>
 
<A NAME="RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.">
<H2>RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.</H2></A>
<A HREF="#PWRLAWDIST - GENERATE A POWER LAW DISTRIBUTION.
">[Previous Routine]</A>
<A HREF="#READASCIIFILE - READ AN ASCII FILE INTO STRARR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rcvnumtonam - convert receiver number to receiver name.
SYNTAX: stat=rcvnumtonam(rcvnum,rcvnam,/num)
ARGS:
	rcvnum : int	receiver number 1..16
KEYWORDS:
	num    : if set then user inputs the rcvnam and we return the rcvnum
RETURNS:
	rcvnam: string	receiver name
   stat  :  int    1 value receiver num, 0 invalid receivernumber
DESCRIPTION
	Convert a receiver number to receiver name. Return the receiver name
in the string rcvnam. Return the status :1 ok, 0 no receiver with this
num in stat.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/rcvnumtonam.pro)</STRONG><P>
<HR>
 
<A NAME="READASCIIFILE - READ AN ASCII FILE INTO STRARR">
<H2>READASCIIFILE - READ AN ASCII FILE INTO STRARR</H2></A>
<A HREF="#RCVNUMTONAM - CONVERT RECEIVER NUMBER TO RECEIVER NAME.
">[Previous Routine]</A>
<A HREF="#RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
readasciifile - read an ascii file into strarr
SYNTAX: nlines=readasciifile(filename,inpLines,comment=comment)
ARGS:
   filename: string the filename to read
KEYWORDS:
    comment: string single character that is a comment
                    lines that start with this will be skipped
RETURNS:
     nlines: long number of lines read
                  -1 if file does not exist.
inpLines[nlines]: strarr lines read

DESCRIPTION
   Read an entire file into a string array. 1 line per string index.
Skip any lines that start with the comment character.
Return the string array and the number of lines read.

EXAMPLES:
   filename='savfiles.dat'
   nlines=readasciifile(filename,inplines,comment=';')
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/readasciifile.pro)</STRONG><P>
<HR>
 
<A NAME="RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS">
<H2>RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS</H2></A>
<A HREF="#READASCIIFILE - READ AN ASCII FILE INTO STRARR
">[Previous Routine]</A>
<A HREF="#RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
recombfreq - compute recombination line freq for atoms
SYNTAX: freq=recombfreq(atom,linenum,linestep,alfa=alpha,beta=beta,gamma=gamma,
                       delta=delta,eps=eps,pertbl=pertbl)
ARGS:
   atom     : string  H,he,C,N,O atom to compute. (case insensitive).
  linenum[n]: long   transition number (lower level)
 linestep[n]: long   1=alpha,2=beta...etc
                     if linenum is an array and linestep is a single value
                     then use this value for all of linenum. If any keyword
                     alpha,beta.. is entered, then ignor linestep.
KEYWORDS:
   alpha   :  if set then return alpha series (deltan=1) (ignore linestep)
   beta    :  if set then return beta  series (deltan=2) (ignore linestep)
   gamma   :  if set then return gamma series (deltan=3) (ignore linestep)
   delta   :  if set then return delta series (deltan=4) (ignore linestep)
   eps     :  if set then return eps   series (deltan=5) (ignore linestep)
   pertbl[]:{pertbl} return period table (name,isotope%, amu for all 
                     elements we support)
RETURNS:
  freq[n]  : double in Mhz.

DESCRIPTION:
   compute the recombination line frequencies for an atom. Supported
atoms are: H,He4,C12,N14,O16. You can supply 1 or more linenumbers to do
at once as well as the step (1,2,3). Using any of the series keywords:
 alpha,beta,gamma,... will override the linestep parameter.

   Taken from "Tools of Radio Astronomy", Rohlfs&Wilson,2000. pg 334.
 looks like value are good to about 1 khz for H89a at 9Ghz.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/recombfreq.pro)</STRONG><P>
<HR>
 
<A NAME="RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.">
<H2>RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.
</H2></A>
<A HREF="#RECOMBFREQ - COMPUTE RECOMBINATION LINE FREQ FOR ATOMS
">[Previous Routine]</A>
<A HREF="#RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
recombsearch - search  for recombination lines within a freq range.
SYNTAX: n=recombsearch(freqMin,freqMax,match,lineStepR=lineStepR,$
                        lineNumR=lineNumR,atoms=atoms
ARGS:
     freqMin: float  min frequency in Mhz to use.
     freqMax: float  max frequency in Mhz to use.
KEYWORDS:
lineStepR[2]: int    min,max step for line transitions to use. The
                     Default is 1 (alfa) to  10 (??)
 lineNumR[2]: int    min,max  line numbers to use. The default is 75 to
                     500.
     atoms[]: string An array of atoms to search. The default is:
                     'H','He','C'. See recombfreq keyword pertbl for
                     a list of the names.
RETURNS:
          n : long   number of transitions found.
    match[n]: {}     an array of structures holding the recomb lines that
                     were found.

DESCRIPTION:
   Look for all of the atomic transitions between frequencies freqMin and
freqmax. Return the number of transitions found and an array (match) holding
the information of each transform. The match structure contains:

** Structure <82c1a1c>, 4 tags, length=24, data length=24, refs=1:
   ATOM            STRING    'H'            .. name of the atom
   LINENUM         LONG               157   .. line number
   LINESTEP        LONG                 1   .. transition 1=alpha,2=beta..
   FREQ            FLOAT           1683.20  .. rest frequency of transition.

   By default the routine searches the atoms H, He,C for line steps of 1..10,
and linenumbers 75 through 500.

EXAMPLES:
   Suppose you have data between 1664 and 1686Mhz and you want to find 
all transitions that satify: step size 1 thru 5  in atoms H,He, and C. 
   n=recombsearch(1664,1685,match,lineStepR=[1,5],atoms=['H','He','C'])

   plot your data flagging these transitions
   corplotrl,b,match 

SEE ALSO: recombfreq,corplotrl
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/recombsearch.pro)</STRONG><P>
<HR>
 
<A NAME="RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME">
<H2>RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME</H2></A>
<A HREF="#RECOMBSEARCH - SEARCH  FOR RECOMBINATION LINES WITHIN A FREQ RANGE.
">[Previous Routine]</A>
<A HREF="#RMS - COMPUTE THE MEAN AND STANDARD DEVIATION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rfname - given the rfnumber, return the standard receiver name
SYNTAX : name=rfname(rfnum)
ARGS   : 
        rfnum: int 1-16..
RETURNS:
       name: string.. rfname.. sbn,sbw,lbn,lbw..etc..
 illegal or unimplented rfnumber will be return as the string
  -number.. eg  rfnum 1 is not implented yet so it would return '-1'
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/rfname.pro)</STRONG><P>
<HR>
 
<A NAME="RMS - COMPUTE THE MEAN AND STANDARD DEVIATION">
<H2>RMS - COMPUTE THE MEAN AND STANDARD DEVIATION</H2></A>
<A HREF="#RFNAME - GIVEN THE RFNUMBER, RETURN THE STANDARD RECEIVER NAME
">[Previous Routine]</A>
<A HREF="#RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rms - compute the mean and standard deviation
SYNTAX:  result=rms(x,quiet=quiet)
  ARGS:
     x[]  : array to compute rms
KEYWORDS:
     quiet: if set then don't print the rms,mean to stdout.    
   
 RETURNS:
     result[2]: result[0]=mean, result[1]= std deviation
 DESCTRIPTION:
    compute the mean and standard deviation. Print the results to
 stdio, and return in result[2]
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/rms.pro)</STRONG><P>
<HR>
 
<A NAME="RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.">
<H2>RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.</H2></A>
<A HREF="#RMS - COMPUTE THE MEAN AND STANDARD DEVIATION
">[Previous Routine]</A>
<A HREF="#RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
rmsbychan - compute the rms/mean  by chan for 2d array.
SYNTAX:  result=rmsbychan(d,median=median,nodiv=nodiv)
  ARGS:
     d[m,n]  : array to compute rms
KEYWORDS:
     median: if set then use median rather than mean
     nodiv : if set then don't divide by the mean
   
 RETURNS:
     result[m]: result[i]= rms(d[i,*])/mean(d[i,*])
 DESCTRIPTION:
    compute the standard deviation/mean  by channel.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/rmsbychan.pro)</STRONG><P>
<HR>
 
<A NAME="RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.">
<H2>RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.</H2></A>
<A HREF="#RMSBYCHAN - COMPUTE THE RMS/MEAN  BY CHAN FOR 2D ARRAY.
">[Previous Routine]</A>
<A HREF="#SCANLIST - LIST CONTENTS OF  DATA FILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ruze - evaluate the ruze formula for losses from surface errors.
SYNTAX: loss=ruze(freq,surfaceErr,errlambda=errlambda,db=db)
ARGS:
    freq[]     : freq in Mhz
    surfaceErr : rms surface error in mm
KEYWORDS:
    errlambda:   if set then surfaceErr is fractions of a wavelength
    db       :   if set then return loss as db
DESCRPIPTION:
   Return loss do to surface irregularities. Use the ruze formula to
evaluate it. loss=exp((-4pi*delta/2)**2 where delta is the rms surface
error. The units are milimeters unles /errlambda is set, then the 
error is fractions of a wavelength (and freq is immaterial but must be
entered).
   The loss is returned as a linear value unless keyword db is set. In
that case the return value is db.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/ruze.pro)</STRONG><P>
<HR>
 
<A NAME="SCANLIST - LIST CONTENTS OF  DATA FILE">
<H2>SCANLIST - LIST CONTENTS OF  DATA FILE</H2></A>
<A HREF="#RUZE - EVALUATE THE RUZE FORMULA FOR LOSSES FROM SURFACE ERRORS.
">[Previous Routine]</A>
<A HREF="#SCANTYPE - RETURN THE TYPE OF SCAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
scanlist - list contents of  data file
SYNTAX: scanlist,lun,recperpage,scan=scan,search=search,std=std,verb=verb
ARGS:
       lun:    int assigned to open file
recperpage:    lines per page before wait for response. def:30
KEYWORDS:
    scan:  long position to scan before listing. def:rewind then list
  search:       if set, then search for header rec if not found at current
                position
  std   :      if set then assume std data
  verb  :      if set then print info each record read
DESCRPIPTION:
   list a summary of all of the scans in a file to  stdout. This works for
correlator or ri datafiles.
   The output data is:

    SOURCE       SCAN   GRPS    PROCEDURE     car0   lst

 Where grps is the number of recs in the file, procedure is the procedure
name that was used to take the data, car0 is the first entry in the
carr[] of the header (typically it has the step in the pattern like
 on or off), and lst is the local sidereal time.
SEE ALSO:
   corlist
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/scanlist.pro)</STRONG><P>
<HR>
 
<A NAME="SCANTYPE - RETURN THE TYPE OF SCAN">
<H2>SCANTYPE - RETURN THE TYPE OF SCAN</H2></A>
<A HREF="#SCANLIST - LIST CONTENTS OF  DATA FILE">[Previous Routine]</A>
<A HREF="#SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
scantype - return the type of scan
SYNTAX: type=scantype(hdr)
  ARGS:  
        hdr: {hdr} 
RETURNS:
       type:  0 unknown
              1 calon of calonoff pattern
              2 caloff of calonoff pattern
              3 position on  of onoff pattern
              4 position off of onoff pattern
DESCRIPTION:
   Return the type of scan from the header info. 
EXAMPLE: 
	print,corget(lun,b)
	type=scantype(b.b1.h)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/scantype.pro)</STRONG><P>
<HR>
 
<A NAME="SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.">
<H2>SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.</H2></A>
<A HREF="#SCANTYPE - RETURN THE TYPE OF SCAN">[Previous Routine]</A>
<A HREF="#SELECT - SELECT ELEMENTS FROM AN ARRAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
searchhdr - position to the next available hdr in the file.
SYNTAX: istat=searchhdr(lun,maxlen=maxlen)
ARGS:
       lun: int   lun of file to search
KEYWORDS:
   maxlen: long    maximum number of bytes to read. default is
                   1megabyte
RETURNS:
      istat: int 1 --> positioned to header, 0 no header found
DESCRIPTION
   Position to the next available hdr in an AO data file. Search up to
maxlen bytes before quitting. If the header is not found, return positioned
at the input position.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/searchhdr.pro)</STRONG><P>
<HR>
 
<A NAME="SELECT - SELECT ELEMENTS FROM AN ARRAY">
<H2>SELECT - SELECT ELEMENTS FROM AN ARRAY</H2></A>
<A HREF="#SEARCHHDR - POSITION TO THE NEXT AVAILABLE HDR IN THE FILE.
">[Previous Routine]</A>
<A HREF="#SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
select - select elements from an array
SYNTAX: anew=select(a,startInd,stepIndex)
ARGS:
     a[]:       array to select elements from
startInd:  long starting index in a to start selecting (0 based).
 stepInd:  long spacing between indices to select
KEYWORDS:
RETURNS:
 aNew[]:        subarray extacted from a.

DESCRIPTION:
   Starting at index startInd select points spaced stepInd from the array
a. Return the subarray in anew.

EXAMPLE:
   a1=select(a,0,2)    .. select every other sample from a starting at first
   a2=select(a,1,3)    .. select every third sample from a start as the 2nd
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/select.pro)</STRONG><P>
<HR>
 
<A NAME="SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS">
<H2>SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS</H2></A>
<A HREF="#SELECT - SELECT ELEMENTS FROM AN ARRAY">[Previous Routine]</A>
<A HREF="#SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
shcolsym - show the default colors and symbols
SYNTAX: shcolsym
ARGS:
DESCRIPTION:
   plot the default colors and symbols.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/shcolsym.pro)</STRONG><P>
<HR>
 
<A NAME="SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S">
<H2>SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S
</H2></A>
<A HREF="#SHCOLSYM - SHOW THE DEFAULT COLORS AND SYMBOLS
">[Previous Routine]</A>
<A HREF="#SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
sixtyunp - unpack hhmmss.s or ddmmss.s to hh mm ss.s or dd mm ss.s
SYNTAX: sixtyunp(xxyyzz,sgn,result)
ARGS:
   xxyyzz: float,long,double either hhmmss.s or ddmmss.s

RETURNS:
   sgn      : int   sign either +1 or -1
   result[3]: float  [hh,mm,ss.s]  or [dd,mm,ss.s]

DESCRIPTION:
   split hhmmss.s or ddmmss.s to h,m,s or d,m,s. Return the positive
values in the array result. The sign of the value is returned in sgn.

EXAMPLES:
 sixtyunp,112233.3 ,sgn,result.. sgn=1., result=[11.,22.,33.3]
 sixtyunp,-000033.3,sgn,result.. sgn=-1., result=[0.,0.,33.3]
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/sixtyunp.pro)</STRONG><P>
<HR>
 
<A NAME="SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)">
<H2>SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)</H2></A>
<A HREF="#SIXTYUNP - UNPACK HHMMSS.S OR DDMMSS.S TO HH MM SS.S OR DD MM SS.S
">[Previous Routine]</A>
<A HREF="#STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
smofrqdm_1d - freq domain smoothing (1d)
SYNTAX: yNew=smofrqdm_1d(y,fracSmo=fracSmo,ftype=ftype,filtertouse=filtertouse)
ARGS:
  y[n]: float  data to smooth
KEYWORDS:
   fracSmo:float   (0 to 1.) fraction of spatial frequency to keep.
   filterType: int 1 - apply fracSmo boxcar 
                   2 - apply fracSmo boxCar*hanning window
                   3 - apply fracSmo boxCar*winCos4
filterToUse[n]:float if Supplied, then ignore fracSmo,filtertype. Use this
                     array as the multiplier in the freq domain.
                    (note. Dc should be at index n/2 (count from 0)

DESCRPIPTION:
   Smooth a 1 d function by multiplying the fft of the function by
a smoothing function. By default this is a boxcar window of length
fracSmo*n. You can specify a tapering of the boxcar window using
fitlertype 2 or 3. You can also specify your own smoothing function
via filterToUse. 
   In the frequency domain, the data is rotated so that dc is at
 n/2 (count from 0) before the multiply is done.

EXAMPLES:
   .. let y contain a 53 cycle and 200 cycle sine wave.
   .. Then try and remove the 200 cycle cosine by using 
      a boxcar smoothed with a cos^4 window. The nyquist rate is
	   511 so 200/511. = .3914. Try a filter of .38 to see how much of the
      200 cycle sin wave is left (not much). 

   y=mksin(1024,53) + mksin(1024,200)
   
	fract=.38  
   ynew=smofrqdm_1d(y,fracSmo=fract,ftype=2)
   plot,abs(fft(ynew))

WARNING: The routine computes the filter size using fix(n*fract). 
		  The smallest measurable change is fract is 1./n

SEE ALSO:
	smofrqdm_2d
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/smofrqdm_1d.pro)</STRONG><P>
<HR>
 
<A NAME="STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.">
<H2>STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.</H2></A>
<A HREF="#SMOFRQDM_1D - FREQ DOMAIN SMOOTHING (1D)">[Previous Routine]</A>
<A HREF="#STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
stripmask - interactively make masks for strips in a map.
SYNTAX: maskAr=stripmask(d,remavg=remavg)
ARGS:
   d[m,n]: float map of m samples per strips and n strips
KEYWORDS:
   remavg: if set then remove the median from each strip before 
           displaying a strip. In this case you may not have to fiddle 
           with the vertical scale on each strip.
RETURNS:
   maskAr[m,n]: int holds n masks of 0,1's

DESCRIPTION:
   Let the user interactively define masks for a number of strips of a
map. For each of n strips, call bluser() and allow the user to define
a mask array using the cursor. When all n strips have been done,
return the maskAr.
   If the user does not define a mask for a particular strip, then the
mask from the previous strip will be used.

   This routine calls bluser() but it is the users responsibility to
enter the keys:
 m .. then define the mask with the cursor
 q .. to exit from bluser for each strip


EXAMPLE:
   Suppose you've call cormapinp and you want to create a mask that
does not include continuum sources in the map. Use the total power in 
polA+polB to find the continuum. Suppose there are 120 samples per 
strip and 36 strips. The following code will call bluser 36 times. 

   istat=cormapinp(lun,scan,brdA,brdB,m,cals); input the map
   polAvg=total(m.p)/2.            ; average pola,polB
   ver, -.001,.015                 ; vertical scale for plot
   maskArr=stripmasks(polAvg,/remavg)
   .. maskArr will now be dimensioned maskArr[120,36]
SEE ALSO:
   bluser()
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/stripmask.pro)</STRONG><P>
<HR>
 
<A NAME="STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.">
<H2>STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.</H2></A>
<A HREF="#STRIPMASK - INTERACTIVELY MAKE MASKS FOR STRIPS IN A MAP.
">[Previous Routine]</A>
<A HREF="#STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
strips - plot strips with offset and increment versus sample.
SYNTAX:  strips,y,offset,step,smo=n,title=title,xtitle=xtitle,
           ytitle=ytitle
ARGS:
   y[m,n]:       2d data to plot.
   offset: float offset to add to the first line plotted.
   step  : float value to add to plot the next line.
KEYWORDS:
   smo  : int  smooth each line by n before plottting.
 title  : string title of plot
 xtitle : string label for x axis
 ytitle : string label for y axis

DESCRPIPTION:
   Plot the 2d array y line by line. Offset the first line by off and
then space each line by step.
EXAMPLE:
   dat[100,20] is the data
   strips,dat,0,.02
You should setup the vertical scale with ver first.
SEE ALSO:
 stripsxy,ver,hor
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/strips.pro)</STRONG><P>
<HR>
 
<A NAME="STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.">
<H2>STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.</H2></A>
<A HREF="#STRIPS - PLOT STRIPS WITH OFFSET AND INCREMENT VERSUS SAMPLE.
">[Previous Routine]</A>
<A HREF="#STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
stripsxy - plot strips with offset and increment verus x.
SYNTAX: stripsxy,x,y,offset,step,over=over,smo=tosmo,dec=dec,title=title,$
       xtitle=xtitle,ytitle=ytitle,stepcol=stepcol,colar=colar,_extra=e
ARGS:
   x[n]  : float   data for x axis.
   y[n,m]: float   2d data to plot. m strips of n points.
   offset: float   offset first strip by this amount.
   step  : float   separate each strip by this amount.
KEYWORDS:
   over  :     if set then continue plotting from a previous call.
   smo   : int number of points to smooth each line.
   dec   : int number of points to decimate each each line.
   title : string title of plot
   xtitle: string xlabel 
   ytitle: string ylabel 
  colAr[]: int    lut indices to use for color
  stepcol: if set then alternate colors between each line. Use color
           indices 1-10. use ldcolph to load the color table.
   _extra:        pass this to the plot,oplot routine.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/stripsxy.pro)</STRONG><P>
<HR>
 
<A NAME="STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME">
<H2>STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME</H2></A>
<A HREF="#STRIPSXY - PLOT STRIPS WITH OFFSET AND INCREMENT VERUS X.
">[Previous Routine]</A>
<A HREF="#SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
strtovarnam - modify a string to be a valid variable name
SYNTAX: newstr=strstovarnam,str,noleading=noleading
ARGS:
   str[]: str   hold the string or strings to check

KEYWORDS:
   noleading:   if set then don't bother checking if the leading
                character is a letter.
RETURNS:
   newstr[]: str modified strings that are valid variable names.

DESCRIPTION:
   This routine will modify the strings passed in to be valid variable
names. A variable name must start with a letter and not contain the
characters: , . ! ; : + - / =
 This routine will make the following substitutions:
 , -> _
 . -> _
 + -> p lus
 - -> m inus
 / -> _
 = -> _
 ! -> _
 ) -> _
 ( -> _

If the string starts with a non letter then prepend the string with 
the letter v.

   This routine is normally used when creating a variable name
that is taken from the source name in the header.

EXAMPLE:
   a='B1934+123'
   aMod=strtovarnam(a)
   print,aMod
  .. 'B1934p123'

   a='1934-123:17'
   aMod=strtovarnam(a)
   print,aMod
  .. 'v1934m123_17'

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/strtovarnam.pro)</STRONG><P>
<HR>
 
<A NAME="SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION">
<H2>SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION</H2></A>
<A HREF="#STRTOVARNAM - MODIFY A STRING TO BE A VALID VARIABLE NAME
">[Previous Routine]</A>
<A HREF="#TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
SVDFITpp- Perform a general least squares fit. patched version

PURPOSE:
   Perform a general least squares fit with optional error estimates.

   This version uses the Numerical Recipies (2nd Edition) function
   SVDFIT.  A user-supplied function or a built-in polynomial or
   legendre polynomial is fit to the data.

CATEGORY:
   Curve fitting.

 CALLING SEQUENCE:
   Result = SVDFIT(X, Y, [M])

INPUTS:
   X:  A vector representing the independent variable.

   Y:  Dependent variable vector.  This vector must be same length 
       as X.

OPTIONAL INPUTS:

   M:  The number of coefficients in the fitting function.  For 
       polynomials, M is equal to the degree of the polynomial + 1.
               If not specified and the keyword A is set, THEN
       M = N_ELEMENTS(A).

INPUT KEYWORDS:

       A:  The inital estimates of the desired coefficients. If M
               is specified, THEN A must be a vector of M elements. 
               If A is specified, THEN the input M can be omitted and
               M=N_ELEMENTS(A). If not specified, the initial value
               of each coefficient is taken to be 1.0. If both M and A are
               specified, them must agree as to the number of paramaters.

   DOUBLE: Set this keyword to force double precision computations. This
               is helpful in reducing roundoff errors and improves the chances
               of function convergence.

    WEIGHTS:   A vector of weights for Y[i].  This vector must be the same
       length as X and Y.  If this parameter is ommitted, 1's
       (No weighting) are assumed.  The error for each term is
       weighted by Weights[i] when computing the fit.  Gaussian or
       instrumental uncertianties should be weighted as
       Weight = 1/Sigma where Sigma is the measurement 
               error or standard deviations of Y. For Poisson or statistical 
               weighting use Weight=1/Y, since Sigma=sqrt(Y).

FUNCTION_NAME:
       A string that contains the name of an optional user-supplied 
       basis function with M coefficients. If omitted, polynomials
       are used.

       The function is called: R=SVDFUNCT(X,M)

       where X and M are  scalar values, and the function value is an 
       M element vector evaluated at X with the M basis functions.  
               M is the degree of the polynomial +1 if the basis functions are
               polynomials.  For example, see the function SVDFUNCT or SVDLEG,
               in the IDL User Library:

       For more examples, see Numerical Recipes in C, second Edition,
               page 676-681.

       The basis function for polynomials, is R[j] = x)^j.

           The function must be able to return R as a FLOAT vector or
               a DOUBLE vector depending on the input type of X.
       
     LEGENDRE: Set this keyword to use the IDL function SVDLEG in the lib
               directory to fit the data to an M element legendre polynomial.
               This keyword overrides the FUNCTION_NAME keyword.

OUTPUTS:
   SVDFIT returns a vector of the M coefficients fitted to the
   supplied function.

 OPTIONAL OUTPUT PARAMETERS:

   CHISQ:  Sum of squared errors multiplied by weights if weights
       are specified.

   COVAR:  Covariance matrix of the coefficients.

    VARIANCE:  Sigma squared in estimate of each coeff(M).
               That is sqrt(VARIANCE) equals the 1 sigma deviations
               of the returned coefficients.

      SIGMA:   The 1-sigma error estimates of the returned parameters,
               SIGMA=SQRT(VARIANCE).

    SINGULAR:  The number of singular values returned.  This value should
       be 0.  If not, the basis functions do not accurately
       characterize the data.

   YFIT:   Vector of calculated Y's.

COMMON BLOCKS:
   None.

SIDE EFFECTS:
   None.

MODIFICATION HISTORY:
   Adapted from SVDFIT, from the book Numerical Recipes, Press,
   et. al., Page 518.
   minor error corrected April, 1992 (J.Murthy)

   Completely rewritten to use the actual Numerical Recipes routines
   of the 2nd Edition (V.2.06). Added the DOUBLE, SIGMA, A, and
   LEGENDRE keywords. Also changed Weight to Weights to match the
   other fitting routines.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/svdfitpp.pro)</STRONG><P>
<HR>
 
<A NAME="TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.">
<H2>TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.</H2></A>
<A HREF="#SVDFITPP- PERFORM A GENERAL LEAST SQUARES FIT. PATCHED VERSION
">[Previous Routine]</A>
<A HREF="#TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
tempplot - plot temperature in turret room for a range of days.
SYNTAX:
   tempplot,yymmdd1,yymmdd2 ,title=title,cs=cs,xp=xp,off=off,lun=lun,sep=sep,$
			clip=clip
ARGS:
   yymmdd1 - long  first day to plot
   yymmdd2 - long  last day to plot
KEYWORDS:
   title   - string title for top of each plot
   cs      - float  scale factor for labels. For multiple windows you may
                    want to increase this to 1.5 or 1.8. default is 1.
   xp      - float  xposition [0.,1.] where dates are printed. default:.02.
                    For hardcopy setting this to 1. puts the dates on the
                    right column.
   off     - float  number of degrees to offset each day within it's 
                    window so the plots don't lay on top of each other.
                    defaut:0.
   lun     - int    if supplied, then you've already opened the input file.
					 Use this to access previous years:
					 eg: /share/obs4/temp/Y01/temp.dat
   sep     -        if set then make 1 plot per day user should set
				     !p.multi before calling the routine. 
   clip[]  -float   clip the data to [mintemp,maxtemp]. allows auto scaling
					 with bad data points..
                    
DESCRIPTION
   plot the temperature in the turret room by hour of day for the
range of dates specified (the routine limits it to a maximum of 31 days).
The plot will have N subwindows with up to 7 consecutive days per window. 
Each day will be color coded witin a window. Any extra days (>28 will appear
in the last window). The routine internally uses daynumber of year for
computations so it will not cross year boundaries gracefully. It also reads
from the temperature file that holds info by year (so the current year 
is the only one that will work.

You should call ldcolph to setup the colortables for indices 0-10. You 
should also set the vertical scale to temperature range you want via 
ver,vmin,vmax. The horizontal scale should be set to hor,0,24.
The extra keywords that may be used are:
 charsize=cs. If the multiple windows cause the letters to come out
too small.

EXAMPLES:
   hor,0,24
   ver,70,90
   tempplot,010701,010731,title='turret room temps for jul01',$
            cs=1.6
NOTES:
   This routine reads from the file /share/obs4/temp/temp.dat. The routine
will only work when run at AO (since the file is not accessible at
remore sites). 
	The routine will not cross year boundaries very gracefully. The 
data files usually contain only one years worth of data. The previous
years data is in (/share/obs4/temp/yyyy/temp.dat where yyyy is the year.
   Tempread has not yet been updated to work on a pc (you need to run it
on a sun (big endian machine).
SEE ALSO:
   tempread.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/tempplot.pro)</STRONG><P>
<HR>
 
<A NAME="TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA">
<H2>TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA</H2></A>
<A HREF="#TEMPPLOT - PLOT TEMPERATURE IN TURRET ROOM FOR A RANGE OF DAYS.
">[Previous Routine]</A>
<A HREF="#
TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
tempread - read receiver room temperature data
SYNTAX: dat=tempread(yymmdd,lun=lun,nrec=nrec)
ARGS:
   yymmdd: long    day of year to input.
KEYWORDS: 
   lun     : int  if provided then this is open to the file to read from.
                  The default is to read from the temperature data file of
                  the current year.
   nrec    : long . if present, read this many records starting at yymmdd.
                    the default is to read 1 days worth of data.
RETURNS:
   dat[n]: {tempdat} temp data structure returned. 
                     dat.time : float daynumber of sample
                     dat.temp : float temp in degree F.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/tempread.pro)</STRONG><P>
<HR>
 
<A NAME="
TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.">
<H2>TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.
</H2></A>
<A HREF="#TEMPREAD - READ RECEIVER ROOM TEMPERATURE DATA
">[Previous Routine]</A>
<A HREF="#TVFREQ - RETURN TV CHANNELS AND FREQUENCIES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
tsysinit - initialize idl to process system temperature monitoring data.
SYNTAX: @tsysinit
ARGS:   none 
DESCRIPION:
   Initialize to process tsys data taken daily with the tsysall program
online.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/tsysinit.pro)</STRONG><P>
<HR>
 
<A NAME="TVFREQ - RETURN TV CHANNELS AND FREQUENCIES">
<H2>TVFREQ - RETURN TV CHANNELS AND FREQUENCIES</H2></A>
<A HREF="#
TSYSINIT - INITIALIZE IDL TO PROCESS SYSTEM TEMPERATURE MONITORING DATA.
">[Previous Routine]</A>
<A HREF="#VER - SET VERTICAL SCALE FOR PLOTTING.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
tvfreq - return tv channels and frequencies

SYNTAX: tvfreq,chan1,chan2,chan,freq,sound=sound,chroma=chroma
ARGS:
       chan1   - int first channel number (2-69)
       chan2   - int last  channel number (2-69)
RETURNS:
       chan[]  - long  channel numbers
       freq[]  - float frequencies 

KEYWORDS:
   sound   : int if set then return the sound carrier frequency
   chroma: : int if set then return the color carrier
DESCRIPTION:
   return the frequencies and channel numbers for the tv channels between
chan1 and chan2 (inclusive). Return the channel numbers in chan and the
frequencies in freq. By default the picture carrier frequency is returned 
(1.25 Mhz above the lower edge). If the sound keyword is set then return 
the frequency of the sound carrier (5.75 mhz above the lower edge). If the
chroma keyword is set then return the color carrier (3.579656 mhz above
the picture carrier)..

EXAMPLE:
   tvfreq,2,20,chan,freq
   chan[] will contain the numbers 2-20
   freq[] will contain the picture carriers for each channel.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/tvfreq.pro)</STRONG><P>
<HR>
 
<A NAME="VER - SET VERTICAL SCALE FOR PLOTTING.">
<H2>VER - SET VERTICAL SCALE FOR PLOTTING.</H2></A>
<A HREF="#TVFREQ - RETURN TV CHANNELS AND FREQUENCIES">[Previous Routine]</A>
<A HREF="#WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ver - set vertical scale for plotting.
SYNTAX: ver,ver1,ver2
ARGS:
   ver1: float min vertical value
   ver2: float max vertical value.
DESCRIPTION:
   Load the !y.range system value with the min,max yrange to plot.
To reset to auto scaling call ver with no args.
SEE ALSO:
   hor
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/ver.pro)</STRONG><P>
<HR>
 
<A NAME="WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE">
<H2>WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE
</H2></A>
<A HREF="#VER - SET VERTICAL SCALE FOR PLOTTING.">[Previous Routine]</A>
<A HREF="#WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
waitnxtgrp - wait for next group from the file to become available
SYNTAX:
     istat=waitnxtgrp(lun,[maxwaitSecs],bytesingrp=bytesingrp)
ARGS:
     lun: assigned to file
OPTIONAL ARGS:
     maxwait: maximum number of seconds to wait before returning. Default
             is 99999
RETURNS:
     istat: return status. 0 ok, -1 timedout, -2 not lined up with a header.
bytesingrp: long bytes in the next group. You can use this to position
 			      to the end of the new group
DESCRIPTION:
   Wait for the next group from the file to be available. Return 0
 if ok, -1 if timeout. You can then read the data in with corget. On
 return, the lun is left positioned at the start of the group to read.
EXAMPLE:
   Assume you are monitoring the online datafile.
   if waitnxtgrp(lun) ne 0 then .. error message
   istat=corget(lun,b)             ;input the data
SEE ALSO:
    corget
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/waitnxtgrp.pro)</STRONG><P>
<HR>
 
<A NAME="WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.">
<H2>WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.</H2></A>
<A HREF="#WAITNXTGRP - WAIT FOR NEXT GROUP FROM THE FILE TO BECOME AVAILABLE
">[Previous Routine]</A>
<A HREF="#WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
wappinit - initialize to use the idl wapp pulsar routines.
SYNTAX: @wappinit   
DESCRIPTION:
   call this routine before using any of the wapp idl routines.
It sets up the path for the idl wapp directory and defines the
necessary structures.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/wappinit.pro)</STRONG><P>
<HR>
 
<A NAME="WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.">
<H2>WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.</H2></A>
<A HREF="#WAPPINIT - INITIALIZE TO USE THE IDL WAPP PULSAR ROUTINES.
">[Previous Routine]</A>
<A HREF="#WINDOWFUNC - MAKE A WINDOW FUNCTION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
windinit - initialize idl to process wind monitoring data.
SYNTAX: @windinit
ARGS:   none 
DESCRIPION:
   Initialize to process wind data.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/windinit.pro)</STRONG><P>
<HR>
 
<A NAME="WINDOWFUNC - MAKE A WINDOW FUNCTION">
<H2>WINDOWFUNC - MAKE A WINDOW FUNCTION</H2></A>
<A HREF="#WINDINIT - INITIALIZE IDL TO PROCESS WIND MONITORING DATA.
">[Previous Routine]</A>
<A HREF="#X - SET OUTPUT TO XWINDOWS DEVICE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
windowfunc - make a window function
SYNTAX: val=windowfunc(len,double=double,type=type)
ARGS:
    len:  long  length of window function
KEYWORDS:
 double: if set the return a double array. the default is float
   type: char   type of window:
                'cos4'  cosine^4 window
                'ecb'   extended cosine bell
                'hsin'  half sine
                'han'   hanning window
                'ham'   hamming window
                 The default is a hanning window
DESCRIPTION:
   Create a window function that can be used in fourier transform
processing
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/windowfunc.pro)</STRONG><P>
<HR>
 
<A NAME="X - SET OUTPUT TO XWINDOWS DEVICE">
<H2>X - SET OUTPUT TO XWINDOWS DEVICE</H2></A>
<A HREF="#WINDOWFUNC - MAKE A WINDOW FUNCTION">[Previous Routine]</A>
<A HREF="#X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
x - set output to xwindows device
SYNTAX: x
ARGS:   none
DESCRIPTION:
   Set plot device to the xwindows terminal.
SEE ALSO:
ps,pscol,hardcopy.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/x.pro)</STRONG><P>
<HR>
 
<A NAME="X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.">
<H2>X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.</H2></A>
<A HREF="#X - SET OUTPUT TO XWINDOWS DEVICE">[Previous Routine]</A>
<A HREF="#X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
x102combineps - combine x102 ps files into 1 file.
SYNTAX: x102combineps(m,fdscript,psdir)
  ARGS:   m[]  : string array of filenames of a particular plot type to 
                 combine.
         fd    : int .. script file to write to
       psdir   : string.. directory to hold the combined postscript files
DESCRIPTION:
   The mueller2.idl routine for x102 calibration creates a large number of 
postscript files. For receivers with multiple frequencies it will create 
1 separate file for each board or frequency. This routine will create a 
csh file that will combine the N frequencies from a particular receiver into
a ps file with N pages (1 for each frequency).
To use:
   1. go to the directory that has the postscript files.
   2. in idl create a string array that has the plot type of the plots 
      to combine:
      eg:
         m4=spawn,'ls lbn*m4*'
   2. open the script file that will hold the commands to combine the files
         openw,lun,'combineps.sc',/get_lun
      When done you will execute this file in the shell to do the combination.
   3. decide on an output directory where you want the combined ps files 
      written.
      x102combineps,lun,'dirpath') 
      free_lun,lun
   4. get out of idl, look at the file to make sure it is ok.
      change the mode to executable, chmod +x combineps.sc
      and then execute it.. combineps.sc

The filenames look like:
lbn_1300_bd0_B0035+130_m4_22-APR-2001.ps
 The routine strips off the first 3 sections to have:
   B0035+130_m4_22-APR-2001.ps

It gathers together all of the files that have this base filename. For each of
these sets it sorts the full name  by the second section _1300_ 
(the frequency).
The outputfile it chooses is:
lbn_all_B0035+130_m4_22-APR-2001.ps where B0035+130_m4_22-APR-2001.ps is the
base name. The script file will then look like:
 psidlmerge -o psdir/lbn_all_B0035+130_m4_22-APR-2001.ps \
  then a list of all frequencies for this source..

The script psidlmerge is in ~phil/Solaris/bin..
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/x102combineps.pro)</STRONG><P>
<HR>
 
<A NAME="X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.">
<H2>X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.</H2></A>
<A HREF="#X102COMBINEPS - COMBINE X102 PS FILES INTO 1 FILE.
">[Previous Routine]</A>
<A HREF="#YYMMDDTOJULDAY - CONVERT YYMMDD TO JULIAN DAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
x111init - initialize idl to process x111 data.
SYNTAX: @x111init
ARGS:   none 
DESCRIPION:
   Initialize to process x111 data. This is interference monitoring
data taken on the telescope. The routine calls @corinit, adds the
Cor2/x111 path and defines the {x111imghdr} structure.
SEE ALSO:
x111imgdisp (x111 software documentation).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/x111init.pro)</STRONG><P>
<HR>
 
<A NAME="YYMMDDTOJULDAY - CONVERT YYMMDD TO JULIAN DAY">
<H2>YYMMDDTOJULDAY - CONVERT YYMMDD TO JULIAN DAY</H2></A>
<A HREF="#X111INIT - INITIALIZE IDL TO PROCESS X111 DATA.
">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
yymmddtojulday - convert yymmdd to julian day

SYNTAX: julday=yymmddtojulday(yymmdd)
ARGS:
      yymmdd: long    to convert
RETURNS:
      julday: double  julian day

DESCRIPTION:
   Convert from yymmdd to julian day.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/yymmddtojulday.pro)</STRONG><P>
<HR>
 
</body>
</html>
