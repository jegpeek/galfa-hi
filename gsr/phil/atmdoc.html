<!-- This file was generated by mk_html_help_ph.pro -->
<html>
 
<head>
<TITLE>aeronomy idl routines</TITLE>
</head>
 
<body bgcolor=white>
<H1>aeronomy idl routines</H1>
<STRONG>Last modified: </STRONG>Fri Oct 22 15:09:59 2004.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ATMGET - INPUT 1 OR MORE ATM RECORDS">
ATMGET - INPUT 1 OR MORE ATM RECORDS</A>
<LI><A HREF="#ATMPWRCMP - DECODE/COMPUTE POWER PROFILE">
ATMPWRCMP - DECODE/COMPUTE POWER PROFILE</A>
<LI><A HREF="#METMON - MONITOR METEOR DATA">METMON - MONITOR METEOR DATA</A>
<LI><A HREF="#PLASMACUTOFF - PROCESS SINGLE PULSE PLASMA CUTTOFF DATA">
PLASMACUTOFF - PROCESS SINGLE PULSE PLASMA CUTTOFF DATA</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ATMGET - INPUT 1 OR MORE ATM RECORDS">
<H2>ATMGET - INPUT 1 OR MORE ATM RECORDS</H2></A>
<A HREF="#ATMPWRCMP - DECODE/COMPUTE POWER PROFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
atmget - input 1 or more atm records
SYNTAX: istat=atmget(lun,d,nrec=nrec,rectype=rectype,raw=raw,scan=scan,sl=sl,
                     search=search)

ARGS: lun    : unit number for file (already opened)
      d[]    : {atmrec} return data here.

KEYWORDS:
 nrec   : long   number of records to return. The default is 1. If nrec is
                 greater than 1, the routine will skip over any records that
                 do not match the requested record type.
                 Note: The routine will return when: nrec records 
                 of the same type are read,  eof is hit, or a record of
                 the same record type but with a different number of 
                 data elements is found.
                        
rectype : string record type to return. The default is the next 
                 available record. The possible values are:
                 'pwr' : power profile (ap version)
                 'clp' : codedlong pulse (ap version)
                'mracf': mracf (ap version)
                 'dspc': dynamic spectra (ap version)
               'rawdat': raw dat program (any data program)
                'rpwrb': rawDat barker code power profile 
               'rpwr88': rawDat 88 len code power profile 
               'rmracf': rawDat mracf;
               note: rmracf,rpwrb,rpwr88 use the codename to determine the
                     type of record.
     raw:        if set then return the data in a single float array.
                 By default the routine splits the data in each
                 record into tx,data,noise,cals, etc..
                 (but rawdat,rpwr,rmracf always return just the data)
    scan: long   scan to position to before reading the data.
    sl[]: {scanlist} array returned from getsl(lun). This can be used
                  for random access of files (see generic routines: getsl())
  search:        if set then search for the start of the first header.
                 use this in if the first rec of the file does not start
                 with a header.
 RETURNS:
  istat : int
           1 - requested number of records found
           2 - req number of recs not found, hit eof, at least 1 record found
           3 - req number of recs not found, hit rec with different data len,
               at least 1 record found
           0 - hit eof, no data returned
          -1 - could not position to scan/rec
          -2 - bad header id in hdr
          -3 - bad program id in header
NOTE:
   For now the rmracf,r

DESCRIPTION:
   Read the next nrec atm records from lun. Start at the current
record position unless the scan keyword is present. Atm files contain
more than 1 kind of data records (eg. pwr, mracf, clp, etc). By default
the record type returned is determined by the first record of the current
read. The user can use the rectype keyword to specify a particular kind
of record type to return.

   The file is left positioned after the last successful record read. If
eof() is hit while trying to complete the current request, the file will
be left positioned at the last successful read of the requested record
type. If the file does not end in this particular record type, then this
will not be at the end of the file.

   The data is returned in an array of structures d[nrec]. Each element
of the structure will contain the header followed by the data arrays. By
default the data arrays are split into tx,data,noise,cals, etc. The
raw keyword will return the data in each record as a single float array.

EXAMPLES:
   To use this routine:
   0. idl
   1. make sure the path to aodefdir() is in your path directory:
       at ao just enter @phil or
       !path='/home/phil/idl/gen' + !path  
       You can also put this in your IDL_STARTUP file if you like.
   2. @atminit     .. sets up the paths, headers for atm processing.
   3. openr,lun,'/share/aeron2/29jun03qz09.greg',/get_lun

    --> get 10 pwr records
    istat=atmget(lun,d,rectype='pwr',nrecs=10)

    --> get 20 mracf records, return in raw mode without splitting
        up the data into tx,data,cals,etc.
    istat=atmget(lun,d,rectype='mracf',nrecs=20,/raw)

 If you want to see each record of a file try:
   rew,lun
   scanlist,lun,/verb,/std
rec:  1 scn:        0 grp:  251 Id:clp      pos:        0 h,dlen:   444 154112
rec:  2 scn:        0 grp:  501 Id:clp      pos:   154556 h,dlen:   444 154112
   The position is the byteoffset in the file for the start of the record.
   h,dlen are the header,data lengths in bytes.

 -------------------------------------------------------------------------
RESTRICTIONS:

1. This routine currently works for the data taken in "raw datataking" mode.
   This uses the pc datataking system in raw datataking mode with the
   processing of the data being done in the PC via asp. The routine 
   will probably not work for the older data taken with the vme array
   processors (the record formats/header info was changed).

2. The routine needs to be positioned at the start of a header. If a 
   file starts with a partial record, use:
      rew,lun
      searchhdr(lun)
   This will position you at the start of the first header. The scan keyword
   allows for random positioning within the file. Unfortunatley, it uses 
   the scannumber keyword in the header and this header element is not
   filled in by the processing programs.

3. Be careful how many records you ask for. You need to have enough
   memory to hold all of them. Typical record lenghths are:
   pwr  : 8628  bytes/rec
   mracf: 11404 bytes/rec  128 spclen by 21  
   clp  : 154556 byes/rec (64 spclen by 602)

   
4. I've tested the routine with mracf,clp, and pwr. Record types of:
   tpsd, dspc are not yet implemented. Raw data (meteors etc..) using rectype
   rawdat will probably work.
 -------------------------------------------------------------------------
DATA FORMAT:

   A typical record will contain a header followed by data. The data 
format will depend on the type of record (pwr,mracf,...) unless the
/raw keyword is used. An example for a power record is:

   d.h               STRUCT    -> HDRPWR Array[1] header
   d.tx              FLOAT     Array[46]          tx samples   
   d.d               FLOAT     Array[1600]        height data
   d.calon           FLOAT     Array[200]         cal on
   d.caloff          FLOAT     Array[200]         cal off

 The same record read using /raw will look like:
   d.H               STRUCT    -> HDRPWR Array[1] header
   d.D1              FLOAT     Array[2046]        all the data
   
 -------------------------------------------------------------------------
HEADERS:

   Each record will have a header containing generic and program specific
entries. The generic parts are :
 h.std (standard header), h.ri , h.sps.
 The program specific headers are:
 h.pwr, h.mracf, h.tpsd,h.clp 

   A description of the generic headers are listed below

 IDL> help,d.h,/st
 ** Structure HDRPWR, 4 tags, length=444, data length=444:
   STD             STRUCT    -> HDRSTD Array[1]    standard header
   RI              STRUCT    -> HDRRIV2 Array[1]   ri header
   PWR             STRUCT    -> HDRSECPWR Array[1] program header (pwr )
   SPS             STRUCT    -> HDRSECSPSBG Array[1] sps header

 -------------------------------------------------------------------------
THE STD HEADER:
 ** Structure HDRSTD, 26 tags, length=128, data length=128:
   HDRMARKER       BYTE    Array[4]        'hdr_'
   HDRLEN          LONG         444        header len bytes
   RECLEN          LONG        8628        reclen bytes
   ID              BYTE     Array[8]       prog id: 'pwr','mracf',etc
   VERSION         BYTE     Array[4]       version
   DATE            LONG           2003185  yyyyddd where ddd is daynumber
   TIME            LONG             70263  time in seconds from midnite ast
   EXPNUMBER       LONG                 0
   SCANNUMBER      LONG                 0
   RECNUMBER       LONG                 0
   STSCANTIME      LONG                 0
   SEC             STRUCT    -> STRSEC Array[1]
   GRPNUM          LONG               500  first record of scan for this data
   GRPTOTRECS      LONG                 1  
   GRPCURREC       LONG                 1
   DATATYPE        BYTE          Array[4]
   AZTTD           LONG           1156032  az pointing direction in .0001 deg
   GRTTD           LONG            150000  za greg in .0001 deg units
   CHTTD           LONG            150002  za ch in .0001 deg units
   POSTMMS         LONG          70262024  millisec from midnite for positions

 -------------------------------------------------------------------------
THE RI HEADER:
 ** Structure HDRRIV2, 12 tags, length=48, data length=48:
   EXTTIMING       LONG                 1  using sps
   SMPMODE         LONG                 1  use gw pulses
   PACKING         LONG                12  12 bit sampling
   MUXANDSUBCYCLDE LONG                 0 
   FIFONUM         LONG                12  use both chan 1,2 (dual beam)
   SMPPAIRIPP      LONG              2046  total samples 1 ipp
   IPPSPERBUF      LONG                 2  ipps per output rec
   IPPNUMSTARTBUF  LONG               999  ipp number from start
   IPP             FLOAT           10000.0 ipp in usec
   GW              FLOAT           2.00000 gw in usec
   STARTON         LONG                 0
   FREE            LONG         544368000
   note: some of the ri header is duplicated in the sps header.
         when in doubt, use the sps header info.
 -------------------------------------------------------------------------
THE SPS HEADER:
 ** Structure HDRSECSPSBG, 16 tags, length=212, data length=212:
   ID              BYTE      Array[4]       section id
   VER             BYTE      Array[4]       version
   IPP             FLOAT           10000.0  ipp in usecs
   GW              FLOAT           2.00000  sample time in usecs
   BAUDLEN         FLOAT           4.00000  baudlen of code in usecs
   BWCODEMHZ       FLOAT          0.250000  bandwidth of code in mhz
   CODELENUSEC     FLOAT           52.0000  codelen in usecs
   TXIPPTORFON     FLOAT           373.000  tx ipp to rf on in usecs
   RFLEN           FLOAT           52.0000  rf len in usecs
   NUMRFPULSES     LONG                 1   number of rf pulses
   MPUNIT          FLOAT           52.0000  multipulse unit
   MPSEQ           LONG      Array[20]      multipulse seq (if mpunt gt 1)
   CODENAME        BYTE      Array[20]      name of code used
   SMPINTXPULSE    LONG                46   samples taken in tx pulse
   NUMRCVWIN       LONG                 2   number of receive windows.
   RCVWIN          STRUCT    -> HDRSPSRCVWIN Array[5]

   The SPS.RCVWIN structure:
  IDL> help,d.h.sps.rcvwin,/st
  ** Structure HDRSPSRCVWIN, 3 tags, length=12, data length=12:
   STARTUSEC       FLOAT           300.000  usecs from start of rf on
   NUMSAMPLES      LONG              1600   number of sample taken
   NUMSAMPLESCAL   LONG                 0   number samples that are cal samples

 -------------------------------------------------------------------------
POWER PROFILE RECORDS:

  istat=atmget(lun,d,rectype='pwr',nrec=10)
  help,d,/st
  Structure <829c52c>, 5 tags, length=8628, data length=8628, refs=1:
   H               STRUCT    -> HDRPWR Array[1] header
   TX              FLOAT     Array[46]      tx samples
   D               FLOAT     Array[1600]    data samples
   CALON           FLOAT     Array[200]     cal ON samples
   CALOFF          FLOAT     Array[200]     cal off samples

   the pwr header d.h.pwr contains:
IDL> help,d.h.pwr,/st
** Structure HDRSECPWR, 14 tags, length=56, data length=56:
   ID              BYTE      Array[4]
   VER             BYTE      Array[4]
   PROGMODE        LONG              1000
   DCDMODE         LONG                 0
   RECTYPE         LONG                 0
   TXSMPSCALE      FLOAT           0.00000
   SPCRECSPERGRP   LONG                 0
   SPCCURREC       LONG                 0
   HIPPSAVGED      LONG              1000
   SPCNUMHEIGHT    LONG                 0
   SPC1STHEIGHT    LONG                 0
   SPCLENFFT       LONG                 0
   SPCAVGED        LONG                 0
   SPCTHISREC      LONG                 0
   only the hippsavged (number of ipps averaged) is filled in.

 -------------------------------------------------------------------------
MRACF RECORDS:
   print,atmget(lun,d,rectype='mracf')
   IDL> help,d,/st
 * Structure <8266f94>, 5 tags, length=11404, data length=11404, refs=1:
   H               STRUCT    -> HDRMRACF Array[1]  header
   TXSPC           FLOAT     Array[128]            spectra of tx samples
   DSPC            FLOAT     Array[128, 16]        16 data spectra of 128 pnts
   NSPC            FLOAT     Array[128, 4]         4 noise spectra of 128 pnts
   DC              FLOAT     Array[46]             dc points (not returned)
   note: the last data spectra d.dspc[*,15] is not computed correctly 
         (it is overlapped with the first noise spectra).

   The mracf header d.h.mracf contains:
   IDL> help,d.h.mracf,/st
** Structure HDRSECMRACF, 20 tags, length=80, data length=80:
   ID              BYTE      Array[4]
   VER             BYTE      Array[4]
   IPPSAVGDATA     LONG              1000      ipps averaged
   IPPSAVGNOISE    LONG                 0
   NUMIFFREQ       LONG                 0
   NUMHEIGHTS      LONG                20      number of heights
   NUMLAGS         LONG                64      number of lags. spclen=2*numlags
   NUMDCPNTS       LONG                 0
   FIRSTTXSMP      LONG                 0
   RECISDATAREC    LONG                 0
   HEIGHTSTHISREC  LONG                 0
   DCPNTSTHISREC   LONG                 0
   TXSPIPP         LONG                 0
   TXHEIGHT        LONG                 0
   NUMFREQSW       LONG                 0
   TXFRQOFF1       FLOAT           0.00000
   TXFRQOFF2       FLOAT           0.00000
   TXFRQOFF3       FLOAT           0.00000
   TXFRQOFF4       FLOAT           0.00000
   FR3             LONG                 0
   the only elements returned are the 3 listed.

 -------------------------------------------------------------------------
CODED LONG PULSE RECORDS:
   print,atmget(lun,d,rectype='clp')
   IDL> help,d,/st
   * Structure <82630e4>, 2 tags, length=154556, data length=154556, refs=1:
   H               STRUCT    -> HDRCLP Array[1]  header 
   DSPC            FLOAT     Array[64, 602]      602 spectra of len 64

   The coded long pulse header contains:
   IDL> help,d.h.clp,/st
   *Structure HDRSECCLP, 14 tags, length=56, data length=56:
   ID              BYTE      Array[4]
   VER             BYTE      Array[4]
   IPPSAVG1FREQ    LONG              1000   ipps averaged
   NUMIFFREQ       LONG                 0
   NUMHEIGHTS      LONG               602   number of heights
   SPC1STHEIGHT    LONG                 0
   SPCHEIGHTSTEP   LONG                 0
   DECIMATEFACTOR  LONG                 8
   ZEROEXTDXFORM   LONG                 0
   FIRSTTXSMP      LONG                 0
   SPCLEN          LONG                64   length of spectra
   DECIMATEDCODELEN
                   LONG                 0
   SPCTHISREC      LONG                 0
   FILL            LONG                 0
   note: the current implementation assumes there are no tx or cal
         samples returned.
 -------------------------------------------------------------------------
RAWDAT RECORDS:
   print,atmget(lun,d,rectype='rawdat')
   IDL> help,d,/st
   * Structure <827d394>, 3 tags, length=123268, data length=123268, refs=1:
   H               STRUCT    -> HDRRD Array[1]  header
   D1              COMPLEX   Array[7680]        channel 1 ch if dual beam
   D2              COMPLEX   Array[7680]        channel 2 gr if dual beam
 
   The rawdat header contains: 
   IDL> help,d.h,/st
   * Structure HDRRD, 3 tags, length=388, data length=388:
   STD             STRUCT    -> HDRSTD Array[1]
   RI              STRUCT    -> HDRRIV2 Array[1]
   SPS             STRUCT    -> HDRSECSPSBG Array[1]
   
   The rawdat program always returns the data as a complex array. It does
not split the data up into cal or noise (as if /raw was always set).

</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/atm/atmget.pro)</STRONG><P>
<HR>
 
<A NAME="ATMPWRCMP - DECODE/COMPUTE POWER PROFILE">
<H2>ATMPWRCMP - DECODE/COMPUTE POWER PROFILE</H2></A>
<A HREF="#ATMGET - INPUT 1 OR MORE ATM RECORDS">[Previous Routine]</A>
<A HREF="#METMON - MONITOR METEOR DATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
atmpwrcmp - decode/compute power profile
SYNTAX: istat=atmpwrcmp(d,dcdpwr,usecal=usecal)
ARGS:
   d[n] :{rd}   array of rawdat power profile data.
KEYWORDS: 
  usecal:       if set then decode and return the cal with the data.

RETURNS:
   istat   :int    1 ok, 0 error
   dcdpwr[m]:float  array holding decoded power data starting at first
                    height (d.h.sps.rcvwin[0].startusec)
DESCRIPTION:
   Decode and compute power for power profile data using the barker
code or the 88 baud length code. The decoding is done with the 
theoretical codes (not the transmitter samples). All of the
ipps in d[n] are averaged together. By default the routine
decodes only the first receive window. If /usecal is included, then
the cal receive window (if it exists) will be part of the decoding.

EXAMPLE:
   usedome=0
   istat=atmget(lun,d,nrecs=1000,nrectype='rpwrb')
   istat=atmcmppwr(d,dcdpwr,/usecal)

;  figure out how to label the plot

   za=(keyword_set(usedome))?d[0].h.std.grttd/10000. $
                            :d[0].h.std.chttd/10000.
   lab=string(format=$
 '("power profile tm:",a," az:",f6.2," scan:",i9)',$
       fisecmidhms3(d[0].h.std.time),d[0].h.std.azttd*.0001,d[0].h.std.scannumber)

;  compute the height from the range   

   range=(findgen(n_elements(dcdpwr))*d[0].h.sps.gw  + d[0].h.sps.rcvwin[0].startusec)*.15
   hght =range*cos(za*!dtor)
    
   maxhght=(long(hght[n_elements(hght)-1L])+49L)/50L *50L
   maxpow=max(dcdpwr)
   maxpow=long(maxpow+49)/50l * 50
   hor,0,maxpow
   ver,0,maxhght
   plot,dcdpwr,hght,title=lab,xtitle='power',ytitle='altitude [km]' 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/atm/atmpwrcmp.pro)</STRONG><P>
<HR>
 
<A NAME="METMON - MONITOR METEOR DATA">
<H2>METMON - MONITOR METEOR DATA</H2></A>
<A HREF="#ATMPWRCMP - DECODE/COMPUTE POWER PROFILE">[Previous Routine]</A>
<A HREF="#PLASMACUTOFF - PROCESS SINGLE PULSE PLASMA CUTTOFF DATA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
metmon - monitor meteor data
SYNTAX: img=metmon(fbase,num,lun=lun,toavg=toavg,numDisp=numDisp,$
                   useCh=useCh,d=d,val=val,pixwin=pixwin,ilim=ilim)
ARGS:
  fbase: string Base filename to read from (eg '/share/aeron5/24jul03').
                Do not include the . or file number.
   num : int    file number of file to start on. 

KEYWORDS:
   lun : int    If provided, then process this file from the current 
                position. When done with the file return. In this case
                fbase and num are ignored. You also can not jump to other 
                files from the internal menu.
  toavg: long   number of ipps to average together. The default is 5
numDisp: long   The number of averaged ipps to display in the image. The
                default is 900 averaged ipps.
  useCh:        If set then start displaying the first data channel. This
                is the carriage house in dual beam experiments. The default
                for dual beam is the dome. You can change this from the
                internal menu.
 val[2]: float  Clip the  power (a/d levels squared) to [min,max] and
                then scale to the full range of the display device (
                0 to 255). The default is to clip the power at 6 sigma
                (as measured from the first image).

 pixwin:        if set then use a pixwin when drawing a new image. This
                cuts down on the flashing. It is useful when you are
                averaging only 1 or 2 ipps.
 ilim  : long   if supplied then limit image to these indices of the 
                data rec (0 based).
RETURNS:
   img[m,numDisp]:float    the last image displayed.
   d[n]         if this keyword is provided then the data read
                for the last image is returned here.
DESCRIPTION:
   metmon will make continuous images of meteor data. The mean is removed from
the voltages, power is computed, and then toavg ipps are averaged together.
numDisp averaged ipps are then displayed as height versus time. When 
the end of file is hit, the routine will advance to the next filenumber.
If no data is available, the routine will wait until it becomes available.
   The user can modify things by hitting any key and bringing up an
internal menu:

Cmd CurVal   function
 a dome      antenna ch, dome
 f   70      move to new fileNum
 l           list all files
 n           next file (or quit if 1 file)
 q           to quit
 r           rewind current file
 s  0        single step 0,1 (off,on)
 otherkey    continue

The commands are:

 a  dome/ch  This lets you switch between dome and carriage house display

 f  filenum  You can start displaying at the start of a different 
             filenumber. If the new filenumber is illegal then no 
             change is made.

 l           This will list all of the available files starting with
             fbase. The last file will also contain its size.

 n           move to the next file number.

 q           quit the routine.

 r           rewind and start over in the current file.

 s  0,1      turn on,off single step mode.When it is on, the routine
             will pause after every image waiting for the user to
             enter return.

 otherKey    any other key will cause the display to continue.
             This allows you to pause the display to look at it for
             a while.
EXAMPLES:
   An example of using this routine at AO:

 1. slogin to either fusion00,01, or 02
 2. idl
 3. @phil
 4. @atminit
 5. xloadct   .. then click on bw linear for scale color table

 6. setup the parameters for the call..
    file='/share/aeron5/23Dec03T1748' .. this should be the path and
                                         base filename for the files to use.
    usech=1            .. set this to 0 if you want the dome output
    num=272            .. first file number of your experiment to use.
 7.start the program:
       img=metmon(file,num,usech=usech)

 8. Hit any key to bring up the keyboard menu.

 Possible problems:

 By default the lut (color lookup table) is scaled to 6 sigma of the
 first image displayed. If this image has a large meteor in it, the
 other plots may not have the correct contrast. You can fix this by:
 a. hit any key, then from the menu enter q (to quit);
 b. plot,img  .. this makes a line plot of the last image (power scale)
 c. pick the range on the yaxis you want to use for the full scale
    lut display.
    then restart the program with the val parameter:
       img=metmon(file,num,usech=usech,val=[0,100])
    In this case,the full scale range of the grey scale (lut) will be
    0 thru 100. Anything above 100 will be mapped to the maximum
    color output.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/atm/metmon.pro)</STRONG><P>
<HR>
 
<A NAME="PLASMACUTOFF - PROCESS SINGLE PULSE PLASMA CUTTOFF DATA">
<H2>PLASMACUTOFF - PROCESS SINGLE PULSE PLASMA CUTTOFF DATA</H2></A>
<A HREF="#METMON - MONITOR METEOR DATA">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
plasmacutoff - process single pulse plasma cuttoff data
SYNTAX: istat=plasmacuttof(lun,spc,spcH,spcN,spcLen=spcLen,toavg=toavg,$
                           freq=freq,flip=flip,nonoise=nonoise,hdr=hdr)
ARGS:
   lun:    int file descriptor of file to read

KEYWORDS:
  spcLen: long length of transform to do. Default is 2048.
               there must be at least this many samples of data and/or noise
   toavg: long number of ipps to average default is 10000
    flip:      if set then flip the frequency order of the spectra on return.
 nonoise:      if set then do not process the noise samples (even if they are
               present).

RETURNS:
 istat     : int    1 returned ok
                    0 hit eof
                    lt 0 trouble reading a record (bad header, etc)
 spc[m,n,l]: float  height spectra with noise subtraction.
                    m=length of spectra
                    n=number of height spectra computed
                    l=number of antennas: 1 if 1 antenna, 
                                          2 if both antennas (dome is 2nd)
spcH[m,n,l]: float  height spectra without noise subtraction.
spcN[m,l]  : float  noise spectra
freq[m]    : float  frequency of the spectra in Mhz.
    hdr    : {hdr}  header from first record read

DESCRIPTION:
   Input and process single pulse plasma cutoff data. Each record should
contain only 1 ipp of data. The windows in the ipp can be:

 txSamples   - skipped
 hghtSamples - must be at least spcLen samples. The routine will compute
               hghtSamples/spcLen height Spectra

 noiseSamples- if present (and nonoise is not set) then there must be
               at least spclen noise samples. The routine will compute
               (and average together) noiseSamples/spclen noise spectra
               for each ipp.

   The routine will read toavg ipps. For each ipp it will compute the
height spectra and an average noise spectra. It then averages these 
spectra over toavg ipp's. 

   The height spectra with noise removal is returned in:
   spc[spcLen,numHghtSpc,numAntennas]. 

   The height spectra with no noise removed is returned in:
   spcH[spcLen,numHghtSpc,numAntennas]. 

   The noise spectra are returned in :
   spcN[spcLen,numAntennas]. 

   If the sps buffer has two receive windows, then the 2nd window is taken
as the noise samples. If only one receive window is present, no noise
subtraction is done.

   The flip keyword will flip the frequency order of all of the spectra.
If BBM sine (top) goes to digitizer (left) then you probably need 
to set /flip.

EXAMPLE:

idl
@phil
@atminit
openr,lun,'/share/aeron5/24Jul03.070',/get_lun
   .. avg 10000 ipps

istat=plasmacutoff(lun,spc,spch,spcN,spclen=2048,freq=freq,/flip)
ver,0,5e8
hor 
; plot the ch spectra 
stripsxy,freq,spcar[*,*,0],0,1e8,/step
; over plot the dome spectra 
stripsxy,freq,spcar[*,*,1],0,1e8,/step,/over

NOTE:
   The routine will not work:
   1. if there are more than 1 ipp per record.
   2. if there are fewer than spclen data or noise samples
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/atm/plasmacutoff.pro)</STRONG><P>
<HR>
 
</body>
</html>
