<!-- This file was generated by mk_html_help_ph.pro -->
<html>
 
<head>
<TITLE>ao pointing related idl routines</TITLE>
</head>
 
<body bgcolor=white>
<H1>ao pointing related idl routines</H1>
<STRONG>Last modified: </STRONG>Fri Oct 22 15:09:57 2004.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ABERANNUAL - COMPUTE THE ANNUAL ABERRATION OFFSET.">
ABERANNUAL - COMPUTE THE ANNUAL ABERRATION OFFSET.</A>
<LI><A HREF="#AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.">
AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.</A>
<LI><A HREF="#ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.">
ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.</A>
<LI><A HREF="#ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.">
ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.</A>
<LI><A HREF="#AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000">
AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000</A>
<LI><A HREF="#AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.">
AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.</A>
<LI><A HREF="#DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.">
DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.</A>
<LI><A HREF="#GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.">
GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.</A>
<LI><A HREF="#HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)">
HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)</A>
<LI><A HREF="#HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).">
HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).</A>
<LI><A HREF="#JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.">
JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.</A>
<LI><A HREF="#MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA">
MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA</A>
<LI><A HREF="#MODINP - INPUT MODEL COEFFICEINTS">
MODINP - INPUT MODEL COEFFICEINTS</A>
<LI><A HREF="#NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.">
NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.</A>
<LI><A HREF="#PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.">
PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.</A>
<LI><A HREF="#PRECNUT - PERFORM PRECESSION AND NUTATION.">
PRECNUT - PERFORM PRECESSION AND NUTATION.</A>
<LI><A HREF="#RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3">
RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3</A>
<LI><A HREF="#RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)">
RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)</A>
<LI><A HREF="#SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).">
SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).</A>
<LI><A HREF="#UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1">
UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1</A>
<LI><A HREF="#UTCTOUT1 - CONVERT UTC TO UT1">UTCTOUT1 - CONVERT UTC TO UT1</A>
<LI><A HREF="#VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES">
VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES</A>
<LI><A HREF="#VELLSRPROJ - LSR VELOCITY ALONG A GIVEN DIRECTION IN J2000 .">
VELLSRPROJ - LSR VELOCITY ALONG A GIVEN DIRECTION IN J2000 .</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ABERANNUAL - COMPUTE THE ANNUAL ABERRATION OFFSET.">
<H2>ABERANNUAL - COMPUTE THE ANNUAL ABERRATION OFFSET.</H2></A>
<A HREF="#AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
aberAnnual - compute the annual aberration offset.
SYNTAX: v=aberAnnual(julianDate)
ARGS:
   juliandate[n]: double julian data of interest. ut1 or utc base is equiv.
RETURNS:
          v[3,n]: double 3vector for the aberation correction. Add this
                         to the curret true ra,dec when going ra,dec->az,el.

 DESCRIPTION

 Return the annual aberration vector offset. This vector should be added
 to the true object position to get the apparent position of the object.

 Aberration requires the observer to point at a direction different from
 the geometrical position of the object. It is caused by the relative motion
 of the two objects (think of it as having to bend the umbrella toward your
 direction of motion to not get wet..). It is the velocity vector offset of
 the observer/object from the geometric direction measured in an inertial 
 frame.

 Complete aberration is called planetary aberration and includes the motion
 of the object and the motion of the observer. For distant objects the
 objects motion can be ignored. Stellar aberration is the portion due to the
 motion of the observer (relative to some inertial frame). It consists of
 secular aberration (motion of the solar system), annual aberration
 (motion of the earth about the sun), and diurnal aberration (caused by
 the rotation of the earth about its axis.

 Secular aberration is small and ignored (the solar system is assumed to be
 in  the inertial frame of the stars). The earths velocity about the sun of
 +/- 30km/sec = +/- .0001v/c gives  +/- 20" variation for annual aberration.
 diurnal variation gives a maximum of about +/- .32" at the equator over a day.
 This routine computes annual aberration using the approximate routines no
 page B17 and C24 of the AA.

 EXAMPLE:
   radedJ2000 -> precNut -> raDecCurrentTrue -> addAberV->radDecCurApparent
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/aberannual.pro)</STRONG><P>
<HR>
 
<A NAME="AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.">
<H2>AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.</H2></A>
<A HREF="#ABERANNUAL - COMPUTE THE ANNUAL ABERRATION OFFSET.
">[Previous Routine]</A>
<A HREF="#ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
agcazzadif - compute az,za offsets from agc data.

SYNTAX: stat=agcazzadif(rcvnum,raJ,decJ,agcDat,stSec,stDay,stYear,tmStepSec,
                        npts, azdif,zadif)
ARGS:
   rcvnum  :int      reciever number
   raJ     :double   J2000 ra in hours
   decJ    :double   J2000 dec in hours

agcDat[4,n]:fltarr   holds tmsecs,azPos,grPos,chPos in degrees
     stYear: long    year for starting time to use
   stdayNum: long    daynumber of year for starting time to use
      stSec: double  start sec
  tmStepSec: double  time step we want 
       npts: long    number of points to compute
KEYWORDS:
 raDecPacked: if set the ra is hhmmss.s and dec is ddmmss.s

RETURNS:
   azdif[npts]:double offset in azimuth (great circle arc minutes)
   zadif[npts]:double offset in za (great circle arc minutes)
   stat       : int   1 ok, 0 no data

DESCRIPTION:
   When doing on the fly mapping, the telescope is moving rapidly while the
correlator, ri is recording the data. The pointing system can be requested
to log the az,za positions in a file at a 25 hz rate. This routine will
then compute the actual great circle az,za offset of the correlator 
sampled data from the center of the map. To do this the user must input:

1. The center of the map in ra,dec J2000.. raJ, decJ.
2. The 25 hz sampled pointing data ... agcDat.
3. The start time of each correlator dump. You enter the 
   starting year,dayno, astSecond of the scan: stYear,stDay,stSec
   as well as the integration time for each record (solar secs): tmStepSec
   Finaly you must enter the number of records: npts.

The routine converts raJ,decJ to az,za for the center of each integration
using ao_radecjtoazza. It then interpolates the measured az,za positions
to these times and computes the az,za differences.

   Each sample of the 25Hz agc data is stored as 4 longs:
   agc.tm  long milliseconds from midnite (AST)
   agc.az  long azimuth position in degrees  *10000 (dome side)
   agc.gr  long za position of dome in degrees  *10000
   agc.ch  long za position of ch in degrees  *10000

   To input all the data of a file:
       filename='/share/obs1/pnt/pos/dlogPos.1' 
       openr,lun,filename,/get_lun
       fstat=fstat(lun)
       numSamples=fstat.size/(4*4)
   allocate array to hold all the data
       inparr=lonarr(4,numSamples)
   read the data
       readu,lun,inparr
       free_lun,lun
   convert to seconds and  degrees.
       datArr=fltarr(4,numSamples)
       datArr[0,*]= inpArr[0,*]*.001   ; millisecs to secs
       datArr[1,*]= inpArr[1,*]*.0001  ; az data to deg
       datArr[2,*]= inpArr[2,*]*.0001  ; gr data to deg
       datArr[3,*]= inpArr[3,*]*.0001  ; ch data to deg

SEE ALSO: ao_radecjtoazza

NOTE:
   The data in agcDat is stored with only a secsFrom midnite timestamp.
The first entry in agcDat should be the same day as stDay. If that
is true,then it is ok to cross midnite.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/agcazzadif.pro)</STRONG><P>
<HR>
 
<A NAME="ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.">
<H2>ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.</H2></A>
<A HREF="#AGCAZZADIF - COMPUTE AZ,ZA OFFSETS FROM AGC DATA.
">[Previous Routine]</A>
<A HREF="#ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME: 
alfabmpos - compute alfa beam positions from az,za,jd beam 0.
SYNTAX: alfbmpos,az,za,juldat,rahrs,decDeg,rotAngle=rotAngle,$
					hornOffsets=hornOffsets
  ARGS:
   az[n]:  float  azimuth of central pixel in degrees
   za[n]:  float  zenith angle of central pixel in degrees
juldat[n]: double julian date for each az,za. Should include the fraction
                  of the day.
KEYWORDS:
   rotAngl: float  rotation angle (deg)of alfa rotator. default is 0 degrees.
                   sitting on the rotator floor, positive is clockwise.
RETURNS:
   raHrs[7,n]: float ra in hours for the 7  beams and the n positions.
  decDeg[7,n]: float declination in degrees for the 7  beams and the 
                     n positions.
hornOffsets[2,7]:float The offsets of the horns relative to pixel 0 in
				      great circle arcseconds. The first dimension is
					  az,za. The second dimension is pixel number

DESCRIPTION:
	Given the az, za, and juldate for the center pixel of alfa, this routine
will compute the ra,dec for each of the 7 beams of alfa. The order returned
is pixel0,1,2,3,4,5,6,7. If az,za,juldat are arrays of length n then
the return data will be [7,n].
	By default the rotation angle for the array is 0 deg. You can uset a
different rotation angle using the rotangle keyword.
	The horn offsets relative to pixel 0 are returned in the hornOffsets
keyword. The units are arcseconds. The are the azOff,zaOff values that are
added to the az,za provided.
	
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/alfabmpos.pro)</STRONG><P>
<HR>
 
<A NAME="ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.">
<H2>ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.</H2></A>
<A HREF="#ALFABMPOS - COMPUTE ALFA BEAM POSITIONS FROM AZ,ZA,JD BEAM 0.
">[Previous Routine]</A>
<A HREF="#AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
anglestovec3 - convert from angles to 3 vectors.

SYNTAX: v=anglestovec3(c1Rd,c2Rd)

ARGS:
   c1Rd[npts] : float/double first  angular coordinate in radians.
   c2Rd[npts] : float/double second angular coordinate in radians.

RETURNS
   v[3,npts]  : float/double x,y,z vector

DESCRIPTION
 Convert the input angular coordinate system to a 3 vector Cartesian
 representation. Coordinate system axis are set up so that x points
 toward the direction when priniciple angle equals 0 (ra=0,ha=0,az=0).
 Y is towards increasing angle.

   c1   c2    directions

   ra   dec   x towards vernal equinox,y west, z celestial north.
          this is a righthanded system.
   ha   dec   x hour angle=0, y hour angle=pi/2(west),z=celestial north.
          This is a left handed system.
   az   alt   x north horizon,y east, z transit.
          This is a left handed system.

SEE ALSO:
 vec3ToAngles
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/anglestovec3.pro)</STRONG><P>
<HR>
 
<A NAME="AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000">
<H2>AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000</H2></A>
<A HREF="#ANGLESTOVEC3 - CONVERT FROM ANGLES TO 3 VECTORS.
">[Previous Routine]</A>
<A HREF="#AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ao_azzatoradec_j - convert AO az,za to J2000
SYNTAX: ao_azzatoradec_j,rcv,az,za,julDat,raHrs,decDeg
ARGS:
    rcvnum: int    receiver number 1..16,17 for alfa,  100 for ch
                   use 0 to bypass model corrections.

     az[n]: float/double   azimuth in degrees
     za[n]: float/double za in degrees
 julDat[n]: double julian date for each point.

KEYWORDS:
   last[n]: double local apparent siderial time (in radians).
            If supplied then this will be used rather then computing it from 
            the julday (take it from the pointing header b.b1.h.pnt.r.lastRd

RETURNS:
  raHrs[n]: double j2000 right ascension (hours).
 decDeg[n]: double j2000 declination (degrees).
DESCRIPTION:
   Convert az,za encoder readings for ao to ra,dec epoch J2000. These are the
values read from the encoders after all corrections are made (model, etc).
The azimuth encoder is always the encoder on the dome side of the
azimuth arm. The routine will recompute the precession, nutation
every julian day.  
   
EXAMPLE:
   Find the ra/dec position of telescope using the az/za
positions from the .std portion of an AO header (either ri or correlator
data). 

   1. correlator spectral data. 
       suppose you have an array of correlator recs b[n]:
       az=b.b1.h.std.azttd*.0001D
       za=b.b1.h.std.grttd*.0001D
       tm=b.b1.h.std.postmms*.001D
       dayno=b.b1.h.std.date mod 1000 + tm/86400D
       year =b.b1.h.std.date / 1000
   2. corpwr() data.. p[n]
       az=p.az*1D
       za=p.za*1D
       tm=p.time*1D
       dayno=(p.scan/100000L) mod 1000 + tm/86400D
       year =(p.scan/100000000L) + 2000L
       ..The time here is the end of the integration. The az,za position
         is probably from 1 sec before the end of the integration. If 
         you are doing 1 sec dumps then you are probably going to be
         of by 1 sec of time..
   3. ridata. suppose you have a long scan of ri data   d[n].
      The header data is sampled once per ri record. Your accuracy will
      then be the ri record spacing.
       az=d.h.std.azttd*.0001D
       za=d.h.std.grttd*.0001D
       tm=d.h.std.postmms*.001D
       dayno=d.h.std.date mod 1000 + tm/86400D
       year =d.h.std.date / 1000

   juldayAr=daynotojul(dayno,year) + 4.D/24.D ; +4 is ao gmt offset
  ao_azzatoradec_j,rcvnum,az,za,juldayAr,raHrs,decDeg  

   The above example will have trouble with a scan that crosses midnight.
The time will go from 86399 to 0 while the day number will increment
on the next scan.
   The az,za data is stored once a second. If the header records (correlator
or ri) are sampled faster than this, then you will get the value at
each second (there will be duplicates in the ra,dec array).

NOTE:
   Be sure and define the juldat as a double so you have enough
precision.

SEE ALSO:
   agcazzadif
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/ao_azzatoradec_j.pro)</STRONG><P>
<HR>
 
<A NAME="AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.">
<H2>AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.</H2></A>
<A HREF="#AO_AZZATORADEC_J - CONVERT AO AZ,ZA TO J2000">[Previous Routine]</A>
<A HREF="#DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
ao_radecjtoazza - convert j2000 to AO az,za.
SYNTAX: radecjtoazza,rcv,raHr,decDeg,julDat,az,za
ARGS:
       rcv: int    receiver number 1..12, 100 for ch
   raHr[n]: float/double   J2000 ra in hours
 decDeg[n]: float/double   J2000 dec in Deg
 julDat[n]: double julian date for each point (utc based). 

RETURNS:
     az[n]: float/double   azimuth in degrees
     za[n]: float/double za in degrees
DESCRIPTION:
   Convert from J2000 ra, dec to actual azimuth, zenith angle encoder
values. These are the values that would be read off of the encoder
in actual operation (the model corrections have been included). The
juliandate should be utc based. If you use julday() function remember to
added 4./24D if you use ast hour,min,seconds. The precession nutation
is computed for each julian day of the input data.

NOTE:
   Be sure and define the juldat as a double so you have enough
precision.


EXAMPLE:
   using the daynotojuldat routine.. you could also use juldat()
   convert from hhmmss, ddmmss to hr.h deg.d
   ra=205716.4D
   dec=025846.1D
   raH=hms1_rad(ra)*!radeg/360.D*24D
   decD=dms1_rad(dec)*!radeg

   convert date to dayno with fraction

   mon=11
   day=19
   year=2002
   astHHMMSS=174258L
   daynoF=dmtodayno(day,mon,year) + hms1_rad(asthhmss)/(2.D*!dpi)
   compute julianday 
   julday=daynotojul(daynoF,year) + 4./24.D
   
   you could also have done this with:

   julday=julday(11.D,19.D,2002.D,17.D,42.D,58.D) + 4./24.D
   rcv=5               ; lbw

   ao_radecJtoazza,rcv,raH,decD,julday,az,za
   print,az,za
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/ao_radecjtoazza.pro)</STRONG><P>
<HR>
 
<A NAME="DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.">
<H2>DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.</H2></A>
<A HREF="#AO_RADECJTOAZZA - CONVERT J2000 TO AO AZ,ZA.">[Previous Routine]</A>
<A HREF="#GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
decToAzZa - convert from dec to az,za for a strip.

SYNTAX: decToAzZa,dec,az,za,step=step

ARGS:
   dec[3,npts] : declination,degrees,minutes,seconds

KEYWORDS:
           step: float. seconds per step   

RETURNS:
   az[npts]    : encoder azimuth angle in degrees. 
   za[npts]    : encoder zenith  angle in degrees. 

DESCRIPTION:
   Convert from declination to azimuth, zenith angle for a 
complete decstrip across the arecibo dish (latitude 18:21:14.2).
The points will be spaced step sidereal seconds in time. The routine
computes the track for +/- 2 hours and then limits the output points
to zenith angle <= 19.69 degrees.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/dectoazza.pro)</STRONG><P>
<HR>
 
<A NAME="GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.">
<H2>GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.</H2></A>
<A HREF="#DECTOAZZA - CONVERT FROM DEC TO AZ,ZA FOR A STRIP.
">[Previous Routine]</A>
<A HREF="#HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 galconv - convert between J2000 and galactic LII,BII.
SYNTAX:  galconv,ra,dec,l,b,conv=conv,hms=hms,deg=deg,usened=usened
ARGS:
     longin[n]: double l  (def)  or ra  input
      latin[n]: double b  (def)  or dec input
    longout[n]: double ra (def)  or l   output
     latOut[n]: double dec(def)  or b   output

KEYWORDS:
   togal:  if set then the input long,lat are ra,dec and the long,lat output
           output will be galactic. By default the input values are galactic
           and the output are ra,dec J2000.
            to convert ra,dec to l,b
     rad:  By default the input/output parameters are in degrees. If rad
           is set then the input parameter should be radians, and the
           output parameters will be radians.

 DESCRIPTION

 Transform from  galactic l,b to J200 ra,dec. If the keyword /togal is
set then convert from ra,dec J2000 to l,b. By default the input and output
parameters are in degrees. If the /rad keyword is set then the input
and output will be in radians.

   The position for the galactic pol is
NOTE:... THIS DOES NOT WORK YET. I'VE GOT 1 MORE ROTATION TO FIGURE OUT..
positions of galatic pole, center taken from ned
lb      ra           dec               ra            dec
(0,0)  266.40506655,-28.93616241 or (17:45:37.21597,-28:56:10.1847)
(0,90) 192.85949646,27.12835323  or (12:51:26.2791f, 27:07:42.0716) 
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/galconv.pro)</STRONG><P>
<HR>
 
<A NAME="HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)">
<H2>HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)</H2></A>
<A HREF="#GALCONV - CONVERT BETWEEN J2000 AND GALACTIC LII,BII.
">[Previous Routine]</A>
<A HREF="#HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
hatoazel - hour angle dec to az/el (3 vector)

SYNTAX: azelv=hatoazel(hadecV,latRd)

ARGS:
   hadecV[3,npts] : hour angle dec 3 vector (see radecdtohav).
   latRd          : float/double latitude in radians

RETURNS:
   azelv[3,npts]  : az,el 3 vector (for source position not feed).

DESCRIPTION
 Transform from  from an hour angle dec system to an azimuth elevation system.
 These are the source azimuth and elevation.

 The returned 3 vector has z pointing at zenith, y pointing east (az=90),
 and x pointing to north horizon (az=0). It is a left handed system.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/hatoazel.pro)</STRONG><P>
<HR>
 
<A NAME="HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).">
<H2>HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).</H2></A>
<A HREF="#HATOAZEL - HOUR ANGLE DEC TO AZ/EL (3 VECTOR)
">[Previous Routine]</A>
<A HREF="#JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 hatoradec - hour angle/dec to ra/dec (of date).
SYNTAX: v3out=hatoradec(v3,lst)
ARGS:
   v3[3,n]: double ha,dec data to convert to ra of date
  lstRd[n]: double local apparent sidereal time in radians
OUTPUTS
   v3out[3,n]:double ra,dec of date

 DESCRIPTION

 Transform from  from an hour angle dec system to a right ascension (of date)
 dec system. The  inputs are double precision 3 vectors. The lst is passed
 in radians.
 If the lst is the mean sidereal time , then the ra/dec and hour angle should
 be the mean positions. If lst is the apparent sidereal time then the
 ra/dec, hour angle should be the apparent positions.

 The transformation is simlar to the raDecToHa except that we reflect
 first (left handed to right handed system) before we do the rotation in 
 the opposite direction.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/hatoradec.pro)</STRONG><P>
<HR>
 
<A NAME="JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.">
<H2>JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.</H2></A>
<A HREF="#HATORADEC - HOUR ANGLE/DEC TO RA/DEC (OF DATE).
">[Previous Routine]</A>
<A HREF="#MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
juldaytolmst - julian day to local mean sidereal time.
SYNTAX: lmst=juldaytolmst(juldat,obspos=obspos)
  ARGS:
  julday[n]: double julian day

KEYWORDS:
   obsPosRd[2]: double [lat,westLong] of observatory in radians. def=ao.

RETURNS:
   lmst[n]: double local mean sidereal time in radians

DESCRIPTION

 Convert from julian day to local mean sidereal time. By default the
latitude,long of AO is used.

 If you need local apparent sidereal time, then add the equation of the
equinox to these values (see nutation_m()).
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/juldaytolmst.pro)</STRONG><P>
<HR>
 
<A NAME="MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA">
<H2>MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA</H2></A>
<A HREF="#JULDAYTOLMST - JULIAN DAY TO LOCAL MEAN SIDEREAL TIME.
">[Previous Routine]</A>
<A HREF="#MODINP - INPUT MODEL COEFFICEINTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
modeval - evaluate the model at the requested az,za

SYNTAX : modeval,az,za,modelData,azErrAsec,zaErrAsec

 ARGS    : 
   az[]  :     azimuth positions degrees.
   za[]  :     zenith angle positions degrees.
   modelData: {modelData} loaded by modinp. defined in ~phil/idl/h/hdrPnt.h
   azErrAsec:  [] return great circle az error in arc seconds.
   zaErrAsec:  [] return great circle za error in arc seconds.

   KEYWORDS:
   enc   :     if 1 include encoder correction. default don't include it
   mod   :     if 0 don't include model correction. default:include it.

 DESCRIPTION:
   Evaluate the model at the specified az, za locations. These are the
 feed locations (not the source azimuth). Use the model data in the
 structure modelData (this structure can be loaded via modinp).

 Return the model errors in great circle arc seconds evaluated at the
 az,za. The errors are defined such that:
 1. let azComp,zaComp be the computed az, za to move the feed to.
 2. compute azE, zaE from the model.
 3. azTouse = azComp + AzE*asecToRad
    zaTouse = zaComp + ZaE*asecToRad
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/modeval.pro)</STRONG><P>
<HR>
 
<A NAME="MODINP - INPUT MODEL COEFFICEINTS">
<H2>MODINP - INPUT MODEL COEFFICEINTS</H2></A>
<A HREF="#MODEVAL - EVALUATE THE MODEL AT THE REQUESTED AZ,ZA
">[Previous Routine]</A>
<A HREF="#NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
modinp - input model coefficeints

SYNTAX : modinp,modelData,model=model,suf=suf,mfile=mfile,efile=efile,$
                rcv=rcv

 ARGS  : 
modelData: {modelData} data returned here. Structure defined in
                       aodefdir()/idl/h/hdrPnt.h

 KEYWORDS:
    model:   model name: eg modelSB, modelCB.. filename should be in
             aodefdir()+"data/pnt" directory with a name modelXXX. You
             can override this with the rcvNmm keyword.
             default: modelSB
    suf  :   suffix for the model you want. suffixes are changed as
             new models are added. current suffix may00 is 11A.
             if not provided then use the current model.
    mfile:  string model filename (if not standard format).
    efile:  string encoder filename (if not standard format)
   rcvNum:  int    if supplied then use model for this receiver. 
                   overrides model= keyword
WARNING:
   If you are not at AO, then the model info was current when you downloaded
 the aoidl distribution. It may have been updated since then. Check
 the file aodefdir()+"data/pnt/lastUpdateTmStamp. It contains the date
 when your data was copied from the online archive.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/modinp.pro)</STRONG><P>
<HR>
 
<A NAME="NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.">
<H2>NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.</H2></A>
<A HREF="#MODINP - INPUT MODEL COEFFICEINTS">[Previous Routine]</A>
<A HREF="#PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 nutation_M - nutation matrix for mean position of date.
SYNTAX: nutM=nutation_M(juldate,eqOfEq=eqOfEq)
ARGS:
   juldate:    double scalar julian date for nutation.
RETURNS:
   nutM[3,3]: double matrix to go from mean coordinates of date to
   eqOfEq: double  if keyword supplied then the equation of the equinox will
                   be returned here. This is needed to go from mean to
                   apparent lst.
 DESCRIPTION

 Return nutation matrix that is used to go from mean coordinates of date to
 the true coordinates of date. The nutation matrix corrects for the short
 term periodic motions of the celestial pole (18 year and less....).
 This matrix should be applied after the precession matrix that goes from
 mean position of  epoch to mean position of date. This uses the 1980
 IAU Theory of Nutation.
 The equation of the equinox is also returned. This is the value to take
 you from mean sidereal time to apparent sidereal time (see page B6 of AA).
 It is nut[3] (counting from 0).

 Input is the julian date as a double

 To create the matrix we:
   1. rotate from mean equatorial system of date  to ecliptic system about x
      axis (mean equinox).
   2. rotate about eclipitic pole by delta psi (change in longitude due to
      nutation.
   3. rotate from true eclipitic system back to true equatorial by rotating
      about x axis (true equinox) by -(eps + delta) eps ( mean obliquity of
      eclipitic plus nutation contribution).

 Since the eclipitic pole  is not affected by nutation (we ignore the
 planetary contribution to the eclptic motion) only the equinox of the
 eclipitic is affected by nutation. When going back from true ecliptic
 to  true equatorial, use eps (avg obliquity) + deleps (obliquity due to
 nutation).

 Note that this method is the complete rotation versus the approximate value
 used on B20 of the AE 1992.

WARNING: juldate should actually be reference to UT1 not UTC. But the
         nutation matrix does not change fast enough to matter.

 REFERENCE
 Astronomical Almanac 1992, page B18,B20
 Astronomical Almanac 1984, page S23-S26 for nutation series coefficients.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/nutation_m.pro)</STRONG><P>
<HR>
 
<A NAME="PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.">
<H2>PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.</H2></A>
<A HREF="#NUTATION_M - NUTATION MATRIX FOR MEAN POSITION OF DATE.
">[Previous Routine]</A>
<A HREF="#PRECNUT - PERFORM PRECESSION AND NUTATION.">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 precj2todate_m - matrix to precess J2000 to current.
SYNTAX:  mat=precj2todate_m(juldat)
ARGS:  
   juldat: double   julian date in UTC system.
RETURNS:
   mat[3,3]:double to precess to J2000

 DESCRIPTION

 Return matrix that can be used to go from J2000 equatorial rectangular
 coordinates to  mean equatorial coordinates of  date (ra/dec). For
 equatorial rectangular coordinates, x points to equinox, z points north,
 and y points 90 to x increasing to the east.

 The input consists of the UTC julian date as a double. The routine
uses the UTC time rather than converting to UT1. The difference
is not important for the usage at AO.

 REFERENCE
 Astronomical Almanac 1992, page B18.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/precj2todate_m.pro)</STRONG><P>
<HR>
 
<A NAME="PRECNUT - PERFORM PRECESSION AND NUTATION.">
<H2>PRECNUT - PERFORM PRECESSION AND NUTATION.</H2></A>
<A HREF="#PRECJ2TODATE_M - MATRIX TO PRECESS J2000 TO CURRENT.
">[Previous Routine]</A>
<A HREF="#RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
 precNut - perform precession and nutation.
SYNTAX: precV3=precNut(vec3,juldate,toj2000=toj2000,eqOfeq=eqOfEq)
ARGS:
   vec3[3,n]: double    vectors to precess
   julDate  : double    julian date to use for precession matrix.
   
KEYWORDS:
  toj2000:if set then precess from date to j2000. default is j2000 to date.

DESCRIPTION
   Perform the J2000 to date or Date to J2000 precession and nutation on the
input vecotr vec3 (normalized 3 vector coordinates). The return
value is in precV3. By default the precession is from J2000 to date. The
keyword toj2000 will precess/nutate from date to J2000.

   The routine computes 1 precession,nutation matrix based on the 
average julDate and then applies it to all of the points n in vec3.
The juldate is normally utc based (actually it should be ut1 based but that 
makes little difference here).

REFERENCE
 Astronomical Almanac 1992, page B18.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/precnut.pro)</STRONG><P>
<HR>
 
<A NAME="RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3">
<H2>RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3</H2></A>
<A HREF="#PRECNUT - PERFORM PRECESSION AND NUTATION.">[Previous Routine]</A>
<A HREF="#RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
radecDtohaV - Current ra/dec Angles to hourAngle/dec V3

SYNTAX: hadecV=radecDtohaV(raRd,decRd,lstRd)

ARGS  :
  raRd      : float/double. right ascension of date  in radians
 decRd      : float/double. declination of date in radians
 lstRd[npts]: float/double. local sidereal time in radians

RETURNS:
   haDecV[3,npts]: hour angle/dec 3 vector.

DESCRIPTION

 Transform from  from a right ascension (of date) dec system to an
 hour angle dec system. The  inputs are ra,dec angles in radians and
 the local sidereal time in radians.

 The ra/dec system is a right handed coordinate system while the ha/dec
 frame is left handed. This requires a rotation and then a reflection
 to change the handedness (the minus sign around the y portion).
 The returned value is the ha dec 3 vector.

 RETURNS
 The resulting  haDec 3 vector is returned via the pointer phaDec. The function
 returns void.

SEE ALSO: hadecVtohaV
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/radecdtohav.pro)</STRONG><P>
<HR>
 
<A NAME="RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)">
<H2>RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)</H2></A>
<A HREF="#RADECDTOHAV - CURRENT RA/DEC ANGLES TO HOURANGLE/DEC V3
">[Previous Routine]</A>
<A HREF="#SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
radecVtohaV - current ra/dec (v3) to hourAngle/dec (v3)

SYNTAX: hadecV=radecVtohaV(radecV,lstRd)

ARGS  :
 radecv[3,Npts]: float/double. 3 vector ra,dec
    lstRd[npts]: float/double. local sidereal time in radians

RETURNS:
   haDecV[3,npts]: hour angle/dec 3 vector.

DESCRIPTION

 Transform from  from a right ascension (of date) dec system to an
 hour angle dec system. The  inputs are normalized 3 vectors and
 the local sidereal time in radians. See radecDtohaV for a version
 that uses angles for input.

 The ra/dec system is a right handed coordinate system while the ha/dec
 frame is left handed. This requires a rotation and then a reflection
 to change the handedness (the minus sign around the y portion).
 The returned value is the ha dec 3 vector.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/radecvtohav.pro)</STRONG><P>
<HR>
 
<A NAME="SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).">
<H2>SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).</H2></A>
<A HREF="#RADECVTOHAV - CURRENT RA/DEC (V3) TO HOURANGLE/DEC (V3)
">[Previous Routine]</A>
<A HREF="#UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
sunazza - compute sun az,za (approximate).

SYNTAX: [az,za]=sunazza(ra1,dec1,ra2,dec2,gmtSecs)
ARGS:
   ra1[3]: double,float  hour, min,sec sun start of gmt day 1
                         apparent right ascension
                    see astronomical almanac c4->
  dec1[3]: double,float  deg, min,sec sun start of gmt day 1
   ra2[3]: double,float  hour, min,sec sun start of gmt day 2
  dec2[3]: double,float  deg, min,sec sun start of gmt day 2
  gmtsecs: double        secsmidnite from ra1 day start for computation.
                         (ast+4 hours)
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/sunazza.pro)</STRONG><P>
<HR>
 
<A NAME="UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1">
<H2>UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1</H2></A>
<A HREF="#SUNAZZA - COMPUTE SUN AZ,ZA (APPROXIMATE).">[Previous Routine]</A>
<A HREF="#UTCTOUT1 - CONVERT UTC TO UT1">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
utcinfoinp - input parameters to convert utc to ut1
SYNTAX: utcinfoinp,juldate,utcInfo
  ARGS:
   juldate: double julian date 
RETURNS:
   utcInfo:{utcInfo} 

DESCRIPTION

Read the utc to ut1 information from the utcToUt1.dat file.
The UTC_INFO structure will return the information needed to go from utc to
UT1. the routine utcToUt1 converts from utc to ut1 using the information
read in here into the UTC_INFO structure. The conversion algorithm is:

  utcToUt1= ( offset + ((julDay - julDayAtOffset))*rate

The offset, rate, data are input from the utcToUt1.dat file.
 
The user passes in the julian date and the
utcToUt1.dat file will be searched for the greatest julian date that is 
less than or equal to the date passed in. If all of the values are after the
requested juliandate,  the earliest value in the file will be used and
and error will be returned. 

NOTE: The file is updated whenever a leap second occurs or whenever the
      drift rate changes (usually every 6 months or a year). If you have 
      downloaded this file from ao, then you need to redownload the
      newer versions occasionally. Check the file
      aodefdir()/data/pnt/lastUpdateTmStamp for when your file was 
      last updated.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/utcinfoinp.pro)</STRONG><P>
<HR>
 
<A NAME="UTCTOUT1 - CONVERT UTC TO UT1">
<H2>UTCTOUT1 - CONVERT UTC TO UT1</H2></A>
<A HREF="#UTCINFOINP - INPUT PARAMETERS TO CONVERT UTC TO UT1
">[Previous Routine]</A>
<A HREF="#VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
utctout1 - convert utc to ut1
SYNTAX: ut1FractOffset=utctout1(juldat)
ARGS:
   julDateUtc[n]: double julian date 
RETURNS:
   ut1FracOffset[n]: double add this to utc based times to get ut1

DESCRIPTION

 Return the offset from utc to ut1 as a fraction of a day. The returned
 value (dut1Frac) is defined as ut1Frac=utcFrac + dut1Frac;
 The fraction of a day can be  < 0. 
   
 The utc to ut1 conversion info is passed in via the structure UTC_INFO.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/utctout1.pro)</STRONG><P>
<HR>
 
<A NAME="VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES">
<H2>VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES</H2></A>
<A HREF="#UTCTOUT1 - CONVERT UTC TO UT1">[Previous Routine]</A>
<A HREF="#VELLSRPROJ - LSR VELOCITY ALONG A GIVEN DIRECTION IN J2000 .
">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
vec3ToAngles - convert 3 vector to angles

SYNTAX: vec3toangles,v,angle1,angle2
ARGS:
   v[3,npts]   : input 3 vector array

KEYWORDS:
   c1pos       : if set then the first angle will be returned >=0

RETURNS:
   c1Rd[npts]: 1st angle coordinate in radians
   c2Rd[npts]: 2nd angle coordinate in radians

DESCRIPTION:
 Convert the input 3 vector to angles (radians).
 If posC1 is set, then the first angle will always be returned as a positive
 angle (for hour angle system you may want to let the ha be negative ).

 The coordinate systems are:
   c1 - ra, ha, azimuth
   c2 - dec,dec, altitude
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/vec3toangles.pro)</STRONG><P>
<HR>
 
<A NAME="VELLSRPROJ - LSR VELOCITY ALONG A GIVEN DIRECTION IN J2000 .">
<H2>VELLSRPROJ - LSR VELOCITY ALONG A GIVEN DIRECTION IN J2000 .</H2></A>
<A HREF="#VEC3TOANGLES - CONVERT 3 VECTOR TO ANGLES">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
NAME:
velLsrProj - lsr velocity along a given direction in J2000 .
SYNTAX: projVel=velLsrProj(dirJ2000,helioVelProj,packed=packed)
ARGS:
   dirJ2000[3] : double 3 vector for J2000 position (unless packed keyword
                        set.
   helioVelProj: double The observers heliocentric velocity projectd
                        along the dirJ2000 direction units:v/c
KEYWORDS:
   packed:       if set then dirJ2000 is an array of 2 that holds
                        [hhmmss,ddmmss] ra and dec.
RETURNS:
   projVel     : double observers lsr velocity projected onto the direction.
                        units: v/c. Positive velocities move away from the
                        coordinate center.
DESCRIPTION

Return the projected lsr velocity for an observer given the direction
in J2000 coordinates and their projected helioCentric velocity
(see velGHProj).
output:
The position for the lsr is:
         ra          dec
1900  18:00:00,dec:30:00:00
J2000 18:03:50.279,30:00:16.8 from rick fischer.
 raRd:4.7291355  decRd: 0.52368024

 Then I converted from angles to 3vec and multiplied by 20km/sec / c

EXAMPLE:
   Suppose you observered an object with 8km/sec topocentric doppler
shift, but you really wanted 8 km/sec lsr doppler shift. Here's how to
fix it (and that's why i wrote this!):
1. get the ra,dec J2000 from the pntheader.
   raRd =b.b1.h.pnt.r.raJcumRd
   decRd=b.b1.h.pnt.r.decJcumRd
2. convert to 3 vec
   vec=anglestovec3(raRd,decRd)
3. get the observers heliocentric velocity projected onto the direction
   obshelVel=b.b1.h.pnt.r.HELIOVELPROJ ; this is v/c units
4. get the projected lsr velocity of observer
   obsLsrVelProj=velLsrProj(vec,obshelvel) ; this routine
5. take difference object velocity, user velocity (- since we 
   are interested in the relative difference of the obj,user)
   vel=objVel/C - obsLsrVelProj
6. compute the doppler correction:
   dopCor=(1./(1.+vel))        ; this is what should have been used.
7. Get the doppler correction used from the header
   dopCorUsed=b.b1.h.dop.factor
8. compute the frequency error we made
   frqErr=restFreq*(dopCor-dopCorUsed)
9. The expected line will be at frequency:dopCor*restFreq rather than 
   the center of the band: dopCorUsed*restFreq
   cfrSbcUsed

NOTE:
   To use this routine do a addpath,'gen/pnt' before calling it.
</PRE><P>
<STRONG>(See /pkg/rsi/local/libao/phil/gen/pnt/vellsrproj.pro)</STRONG><P>
<HR>
 
</body>
</html>
